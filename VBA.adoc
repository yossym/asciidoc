= VBA
// 著者の名前(省略可)<メールアドレス(省略可能)>
// バージョンや作成日(省略可)
:Author:	yossym
:Email:     docomoxyz@gmail.com
:Date:      	2020-09-11
:Revision:  0.1


:toc:
:sectnums:
:toclevels: 5

:lang: ja
:doctype: book
:docname: VBA
:toclevels: 5
:sectnums:
:sectnumlevels: 5
// :source-highlighter: pygments
:source-language: VBscript
:toc: right
// :toc: left
:toc-title: 目次

== 変数

hoge, fuga, piyo, hogera

WorkBook::
        wb
WorkSheet::
        ws
Range::
        rng, rg

最初::
        FirstRow, FirstColumn
最終::
        LastRow, LastColumn


Controls ::
	ctl

=== 関数系

テキスト読み込み::
	s

Variant::
	Var


=== FilesystemObject

fso



== Workbook

=== Workbook 新規

[source,vbscript]
----
Dim wb As Workbook
Applicatioin.SheetsInNewWorkbook = 1
Set wb = Workbook.
----

=== Workbook 開く

[source,vbscript]
----
Workbook.Open "hoge.xlsx"
----

[source,vbscript]
----
Workbook.Open Filename:="hoge.xlsx",ReadOnly:=True
----

[source,vbscript]
----
Dim wb As Workbook
Set wb = Workbook.Open("hoge.xlsx")
----

[source,vbscript]
----
Dim wb As Workbook
Set wb = Workbook.Open(FileName:="hoge.xlsx",ReadOnly:=True)
----

=== Workbook 閉じる

[source,vbscript]
----
Applicatioin.DisplayAlerts=False
wb.Close
Applicatioin.DisplayAlerts=True
----

=== Workbook 保存

[source,vbscript]
----
Workbook.Save
----

[source,vbscript]
----
Dim SaveTime As String
Savetime = Format(Now,"yyyymmdd_hhmmss")

Workbook.SaveAs "hoge.xlsx"
----

=== ワークブックを開くとき、閉じるとき

.[ThisWorkbook]モジュール

[source,vbscript]
----
Private Sub Workbook_Open()
    ''起動時に自動実行する記述
End Sub

Private Sub Workbook_BeforeClose(Cancel As Boolean)
    ''終了時に自動実行する記述
End Sub
----


.[標準モジュール]
[source,vbscript]
----
Sub Auto_Open()
    ' '起動時に自動実行する記述
End Sub

Sub Auto_Close()
    ' '終了時に自動実行する記述
End Sub
----


==== メニュー追加


.[標準モジュール]
[source,vbscript]
----
Const READ_MENU01 As String = "MENU01"
Public Const MENUBARNAME = "Worksheet Menu Bar"

Sub auto_open()
    Call MenuBtnRegist(READ_MENU01, READ_MENU01, READ_MENU01, 300)
End Sub

Sub auto_close()

End Sub


Private Function MenuSearch(MenuTitle As String) As Boolean
    Dim i As Long
    With ThisWorkbook.Application.CommandBars(MENUBARNAME)
        For i = 1 To .Controls.Count
            If MenuTitle = .Controls.Item(i).Caption Then
                MenuSearch = True
                Exit Function
            End If

        Next

    End With
    MenuSearch = False
End Function

Private Sub MenuBtnRegist(MenuTitle As String, tipText As String, _
                            OnAction As String, FaceId As Long)
    Dim fMenu As CommandBarControl
    Dim MenuRegistFlag As Boolean: MenuRegistFlag = False

    MenuRegistFlag = MenuSearch(MenuTitle)
    If Not MenuRegistFlag Then
        With ThisWorkbook.Application.CommandBars(MENUBARNAME)
            Set fMenu = .Controls.Add(Type:=msoControlButton, Temporary:=True)

            fMenu.Caption = MenuTitle
            fMenu.Style = msoButtonIconAndCaption
            fMenu.TooltipText = tipText
            fMenu.OnAction = OnAction
            fMenu.FaceId = FaceId
        End With
        Set fMenu = Nothing
    End If

End Sub

Sub MENU01()
    MsgBox "aaa"
End Sub
----

== WorkSheets
=== WorkSheets 追加

.アクティブシートの左に追加
[source,vbscript]
----
WorkSheets.Add
WorkSheets.Add before:=ActiveSheet
----


.アクティブシートの左に追加
[source,vbscript]
----
WorkSheets.Add After:=Activesheet
----

.2番目のシート右に２枚追加
[source,vbscript]
----
Worksheets.Add After:=Worksheets(2),Count:=2
----

.最終シート？の右にシート追加
[source,vbscript]
----
Worksheets.Add After:=Worksheets(Worksheets.Count)
----


=== WorkSheets 削除

.アクティブシート削除
[source,vbscript]
----
Workbooks.Delete
----

== セル
=== 行の追加

==== 1行追加
[source,vbscript]
----
Rows(1).Insert
Range("C3").Insert
Rows("2:3").Insert
----

[source,vbscript]
----
Rows("B").Insert
----

==== 複数行追加
[source,vbscript]
----
Range(Rows(2), Rows(4)).Insert
----

==== 1列追加

[source,vbscript]
----
Columns(1).Insert
Columns("C").Insert
Range("C3").EntireColumn.Insert
----

==== 複数列追加

[source,vbscript]
----
Range(Columns(3), Columns(6)).Insert
----


=== 最終行取得

[source,vbscript]
----
Dim LastRow As Long
LastRow = Cells(Rows.Count, 1).End(xlUp).Row
----

=== 最終列取得

[source,vbscript]
----
Dim LastColumn As Long
LastColumn = Cells(1, Columns.Count).End(xlToLeft).Column
----

=== Selection


[source,vbscript]
----
Range("A3").CurrentRegion.Selct
----

[source,vbscript]
----
Range("A3").UsedRange.Select
----



=== セルの指定


[source,vbscript]
----
Range("C3").Select

	   A B C D E
	 ＋ーーーーーーーーーーーーーー
	1｜□□□
	2｜□□□
	3｜□□■
	4｜
	5｜
	6｜
	7｜
	8｜
	9｜
----

* [red]#エラーになる#
[source,vbscript]
----
Range(Cells(3,3)).Select
----

[source,vbscript]
----
Range("A3:B6").Select

	   A B C D E
	 ＋ーーーーーーーーーーーーーー
	1｜
	2｜
	3｜■■
	4｜■■
	5｜■■
	6｜■■
	7｜
	8｜
	9｜
----

[source,vbscript]
----
Range("A3,B6").Select

	   A B C D E
	 ＋ーーーーーーーーーーーーーー
	1｜
	2｜
	3｜■
	4｜
	5｜
	6｜　■
	7｜
	8｜
	9｜
----

[source,vbscript]
----
Range("A3","B6").Select
	   A B C D E
	 ＋ーーーーーーーーーーーーーー
	1｜
	2｜
	3｜■■
	4｜■■
	5｜■■
	6｜■■
	7｜
	8｜
	9｜
----

[source,vbscript]
----
Range("A3:B6","C9:D12").Select

	   A B C D E
	 ＋ーーーーーーーーーーーーーー
	1｜
	2｜
	3｜■■■■
	4｜■■■■
	5｜■■■■
	6｜■■■■
	7｜■■■■
	8｜■■■■
	9｜■■■■
	0｜■■■■
	1｜■■■■
	2｜■■■■
	3｜
----

[source,vbscript]
----
Range(Cells(3,3), Cells(6,6)).Select

	   A B C D E
	 ＋ーーーーーーーーーーーーーー
	1｜
	2｜
	3｜　　■■■■
	4｜　　■■■■
	5｜　　■■■■
	6｜　　■■■■
	7｜
----

[source,vbscript]
----
Range("A3:B6,C9:D12").Select

	   A B C D E
	 ＋ーーーーーーーーーーーーーー
	1｜
	2｜
	3｜■■
	4｜■■
	5｜■■
	6｜■■
	7｜
	8｜
	9｜　　■■
	0｜　　■■
	1｜　　■■
	2｜　　■■
	3｜
----



=== セルの追加


[source,vbscript]
----
' 引数なしなら左に移動'
Range("A3:B6").Insert
----

[source,vbscript]
----
Range("A3:B6").Insert shift:=xlShiftToRight
----

.XlInsertShiftDirection 列挙 (Excel)

[cols="4,1,4",options="header"]
|===
 | 名前           | 値    | 説明
 | xlShiftDown    | -4121 | セルを挿入後、下に伸ばす
 | xlShiftToRight | -4161 | セルを挿入後、右に伸ばす
|===

=== セルの値コピー(Fill*)

* 次の使用例は、シート 1 のセル A1 の内容をセル A1:A10 の範囲に複写します。
[source,vbscript]
----
Worksheets("Sheet1").Range("A1:A10").FillDown
----

* 次の使用例は、シート 1 のセル M1 の内容と書式をセル範囲 A1:M1 に複写します。
[source,vbscript]
----
Worksheets("Sheet1").Range("A1:M1").FillLeft
----

* 次の使用例は、シート 1 のセル A1 の内容と書式をセル範囲 A1:M1 に複写します。
[source,vbscript]
----
Worksheets("Sheet1").Range("A1:M1").FillRight
----

* 次の使用例は、シート 1 のセル A10 の内容と書式をセル範囲 A1:A10 に複写します。
[source,vbscript]
----
Worksheets("Sheet1").Range("A1:A10").FillUp
----

=== コピペ

.普通にコピペ
[source,VBSCRIPT]
----
Range("R25:R30").Select
Selection.Copy
Range("U25").Select
Selection.PasteSpecial
----

.1列をコピーして1行にペースト
[source,VBSCRIPT]
----
Range("R25:R30").Select
Selection.Copy
Range("U25").Select
Selection.PasteSpecial Transpose:=True
----

=== ソート
* A1:C5の範囲をA1を基準にソート
[source,VBSCRIPT]
----
Range(cells(1,1),cells(5,3))

Call Range("A1:C5").Sort(key1:=Range("A1"), _
    order1:=xlDescending)

Call Range(Cells(1, 1), Cells(5, 3)).Sort(key1:=Range(Cells(1, 1), Cells(1, 1)), _
    order1:=xlDescending)

Call Range(Cells(1, 1), Cells(5, 3)).Sort(key1:=Cells(1, 1), _
    order1:=xlDescending)
----

.A1:C5の範囲をA1,B1を基準にソート
[source,VBSCRIPT]
----
Call Range("A1:C5").Sort(key1:=Range("A1"), _
    order1:=xlAscending, _
    key2:=Range("B1"), _
    order2:=xlAscending)
----

== https://docs.microsoft.com/ja-jp/office/vba/api/excel.range(object)[Range オブジェクト (Excel) | Microsoft Docs]

=== Range.Address プロパティ (Excel)

コード記述時の言語で参照範囲を表す文字列型 (String) の値を返します。

.構文

[source,vbscript]
----
expression.Address (RowAbsolute, ColumnAbsolute, ReferenceStyle, External, RelativeTo)
----

expression は Range オブジェクトを表す変数です。

.パラメーター

[cols="1,1,1,4",options="header"]
|===
|名前 |必須 / オプション |データ型 |説明
|RowAbsolute |Optional |Variant |行部分の参照を絶対参照として返すには、 True を指定します。 既定値は True です。
|ColumnAbsolute |Optional |Variant |列部分の参照を絶対参照として返すには、 True を指定します。 既定値は True です。
|ReferenceStyle |省略可能 |XlReferenceStyle |参照形式を指定します。 既定値は xlA1 です。
|外部 |Optional |Variant |外部参照を返すには、 True を指定します。 ローカル参照を返すには、 False を指定します。 既定値は False です。|RelativeTo |Optional |Variant |RowAbsolute および ColumnAbsolute が False であるときに、ReferenceStyle が xlR1C1 である場合は、相対参照の開始点を含める必要があります。 この引数は開始点を定義する Range オブジェクトです。 +
注: Excel VBA 7.1 を使用したテストでは、明示的な開始点が必須ではないことが示されます。 $A$1 の既定の参照があるようです。
|===



.解説

参照に複数のセルが含まれている場合は、引数 RowAbsolute と引数 ColumnAbsolute
はすべての行と列に適用されます。

.例

次の使用例は、シート 1 の同じセル アドレスを 4 つの異なる方法で表します。 コー
ド中のコメントは、メッセージで表示されるアドレスを示しています。


[source,vbscript]
----
Set mc = Worksheets("Sheet1").Cells(1, 1) 
MsgBox mc.Address() ' $A$1 ★
MsgBox mc.Address(RowAbsolute:=False) ' $A1 
MsgBox mc.Address(ReferenceStyle:=xlR1C1) ' R1C1 ★
MsgBox mc.Address(ReferenceStyle:=xlR1C1, _ 
 RowAbsolute:=False, _ 
 ColumnAbsolute:=False, _ 
 RelativeTo:=Worksheets(1).Cells(3, 3)) ' R[-2]C[-2]
----


























































































== ファイル

=== ファイル読み込み(sjis,FileSystemObject)

参照設定::
Microsoft ScrptingRuntime

[source,VBSCRIPT]
----
Dim fso As New Scrpting.Filesystemobject
Dim ts as TextSream
Dim s As String

Set ts = fso.OpenTextFile(FileName)

Do While ts.AtEndOfStream <> True
    s = ts.ReadLine
    ...
Loop
ts.Close
----

=== ファイル読み込み(UTF-8,ADODB)

参照設定::
ActiveX Data Objects 6.1 Library

[source,VBSCRIPT]
----

----


=== ファイル書き込み(sjis,FileSystemObject)

参照設定::
Microsoft ScrptingRuntime

[source,VBSCRIPT]
----
Dim fso As New Scrpting.Filesystemobject
Dim ts as TextSream

' ファイルが存在すればサイズ0にして書き込み
Set ts = fso.OpenTextFile(FileName,ForWriting,True)
ts.WriteLine("This is a  pen.")
ts.Close
----

=== ファイル書き込み(UTF-8,ADODB)











=== ファイル一覧取得

参照設定::
Microsoft ScrptingRuntime

[source,VBSCRIPT]
----
Dim f As File
Dim fso As New Scripting.FileSystemObject

For Each f in fso.GetFolder(Path).Files
    f.Name,F.Type
Next
----

=== フォルダ一覧

参照設定::
Microsoft ScrptingRuntime

[source,VBSCRIPT]
----
Dim fd As Folder
Dim fso As New Scrpting.Filesystemobject

For Each fd In fso.getFolder(Path).subFolders
    fd.Name fd.Path
Next
----

=== フォルダを再起してファイル一覧取得

[source,VBSCRIPT]
----
Sub sample()
    Dim fs As New Collection
    Dim v As Variant

    Call FolderSearch("C:\Users\yossym\Desktop\share", fs)

    Dim i As Long: i = 1
    For Each v In fs
        Cells(i, 1) = v
        Cells(i, 2) = v.Type
        Cells(i, 3) = v.Name
        Cells(i, 4) = v.Path
        i = i + 1

    Next
End Sub

Public Sub FolderSearch(Path As String, fs As Collection)

    Dim fso As New Scripting.FileSystemObject
    Dim folder As folder
    Dim subfolder As folder
    Dim f As file

    Set folder = fso.GetFolder(Path)

    'フォルダ内のサブフォルダを列挙
    '（サブフォルダがなければループ内は通らず）
    For Each subfolder In folder.SubFolders
        '再帰的呼び出し
        Call FolderSearch(subfolder.Path, fs)
    Next subfolder

    'カレントフォルダ内のファイルを列挙
    For Each f In folder.Files
        ' file オブジェクトを代入
        fs.Add f
    Next f

End Sub
----

== 特殊フォルダ

参照設定::
Microsoft ScrptingRuntime


== ファイル選択Dialog


[source,vbscript]
----
Sub sample()
    Dim cs As New Collection
    Dim Var As Variant

    'ファイルを1つ選択
    Set cs = SelectFiles("CSVファイル(*.csv),*.csv", False)
    Debug.Print cs.Count
    For Each Var In cs
        Debug.Print Var
    Next

    'ファイルを複数選択
    Set cs = SelectFiles("CSVファイル(*.csv),*.csv", True, "せんたく")
    Debug.Print cs.Count
    For Each Var In cs
        Debug.Print Var
    Next

    'ファイルを複数選択　＆　filterも複数
    Dim s As String
    s = "テキストファイル(*.txt;*.log),*.txt;*.log,すべてのファイル(*.*),*.*"
    Set cs = SelectFiles(s, True, "せんたく")
    Debug.Print cs.Count
    For Each Var In cs
        Debug.Print Var
    Next

End Sub

Function SelectFiles(Filter As String, Multiselect As Boolean, Optional Title As String = "ファイル選択") As Collection
    Dim c As New Collection
    Dim fs As Variant

    fs = Application.GetOpenFilename( _
        FileFilter:=Filter, _
        Multiselect:=Multiselect, _
        Title:=Title)

    Dim i As Long
    If IsArray(fs) Then
        For i = LBound(fs) To UBound(fs)
            c.Add fs(i)
        Next
    Else
        If fs <> False Then
            c.Add fs
        End If
    End If

    Set SelectFiles = c
End Function
----


=== 1ファイル選択

[source,vbscript]
----
Dim myFile As Variant

ChDir ThisWorkbook.Path
myFile = Application.GetOpenFilename("CSVファイル(*.csv),*.csv")

If VarType(myFile) = vbBoolean Then
    MsgBox "キャンセルされました"
Else
    MsgBox myFile & " が選択されました"
End If
----

=== タイトルを変更

[source,vbscript]
----
myFile = Application.GetOpenFilename( _
	filefilter:="CSVファイル(*.csv),*.csv", _
	Title:="This is a pen.")
----


=== 複数ファイル

.Multiselectがポイント


[source,vbscript]
----
Dim f As Variant
fs = Application.GetOpenFilename( _
filefilter:="Excel ファイル (*.xls; *.xlsx),*.xls; *.xlsx", _
 MultiSelect:=True)

If IsArray(fs) Then
    For Each f In fs
        Debug.Print f
    Next
Else
    Debug.Print fs
End If
----

== フォルダ選択Dialog


[source,vbscript]
----
Private Function SelectFolder() As String
    Dim Result As String:  Result = ""
    With Application.FileDialog(msoFileDialogFolderPicker)
        .AllowMultiSelect = False
        .Title = "フォルダ選択"
        .ButtonName = "OK"
        If .Show Then
            Result = .SelectedItems(1)
        End If
    End With
    SelectFolder = Result
End Function
----


== FileSystemObject オブジェクト

参照設定::
Microsoft ScrptingRuntime


コンピューターのファイル システムへのアクセスを提供します。

.構文

[source,vbscript]
----
Scripting.FileSystemObject
----

.注釈

次のコードはFileSystemObjectオブジェクトを使用して読み書き可能な**TextStream**
オブジェクトを返す方法を示しています。


[source,vbscript]
----
Set fs = CreateObject("Scripting.FileSystemObject")
Set a = fs.CreateTextFile("c:\testfile.txt", True)
a.WriteLine("This is a test.")
a.Close
----

コード例では、次のとおりです。

* CreateObject 関数は FileSystemObject (fs) を返します。
* CreateTextFile メソッドは、ファイルを TextStream オブジェクト (a) として作成します。
*    WriteLine メソッドは、作成されたテキスト ファイルにテキスト行を書き込みます。
*    Close メソッドは、バッファーをフラッシュし、ファイルを閉じます。


.メソッド

[cols="1,4",options="header"]
|===
|メソッド |説明
|BuildPath |既存のパスに名前を追加します。
|CopyFile |1 つ以上のファイルを別の場所にコピーします。
|CopyFolder |1 つ以上のフォルダーを別の場所にコピーします。
|CreateFolder |新しいフォルダーを作成します。
|CreateTextFile |テキスト ファイルを作成し、ファイルの読み取りまたは書き込みに使用できる TextStream オブジェクトを返します。
|DeleteFile |指定した 1 つ以上のファイルを削除します。
|DeleteFolder |指定した 1 つ以上のフォルダーを削除します。
|DriveExists |指定したドライブが存在するかどうかを確認します。
|FileExists |指定したファイルが存在するかどうかを確認します。
|FolderExists |指定したフォルダーが存在するかどうかを確認します。
|GetAbsolutePathName |指定したパスのドライブのルートからの完全なパスを返します。
|GetBaseName |指定したファイルまたはフォルダーのベース名を返します。
|GetDrive |指定したパスのドライブに対応するドライブ オブジェクトを返します。
|GetDriveName |指定したパスのドライブ名を返します。
|GetExtensionName |指定したパスの最後のコンポーネントのファイル拡張子名を返します。
|GetFile |指定したパスのファイル オブジェクトを返します。
|GetFileName |指定したパスの最後のコンポーネントのファイル名またはフォルダー名を返します。
|GetFolder |指定したパスのフォルダー オブジェクトを返します。
|GetParentFolderName |指定したパスの最後のコンポーネントの親フォルダーの名前を返します。
|GetSpecialFolder |Windows の一部の特殊フォルダーのパスを返します。
|GetTempName |ランダムに生成された一時ファイルまたはフォルダーを返します。
|Move |指定したファイルまたはフォルダーを別の場所に移動します。
|MoveFile |1 つ以上のファイルを別の場所に移動します。
|MoveFolder |1 つ以上のフォルダーを別の場所に移動します。
|OpenAsTextStream |指定したファイルを開き、開いたファイルの読み取り、書き込み、または追加書き込みに使用できる TextStream オブジェクトを返します。
|OpenTextFile |ファイルを開き、ファイルへのアクセスに使用できる TextStream オブジェクトを返します。
|WriteLine |指定した文字列と改行文字を TextStream ファイルに書き込みます。
|===

.プロパティ

[cols="1,4",options="header"]
|===
|プロパティ |説明
|Drives |コンピューター上のすべての Drive オブジェクトのコレクションを返します。
|Name |指定したファイルまたはフォルダーの名前を設定するか返します。
|Path |指定したファイル、フォルダー、またはドライブのパスを返します。
|Size |ファイルの場合は、指定したファイルのバイト単位でのサイズを返します。フォルダーの場合、そのフォルダーに含まれるすべてのファイルとサブフォルダーのサイズをバイト単位で返します。
|Type |ファイルまたはフォルダーの種類に関する情報を返します (たとえば .TXT で終わるファイルの場合は、"Text Document" を返します)。
|===







=== メソッド

==== BuildPath メソッド

フォルダーパスとフォルダーまたはファイルの名前を結合し、有効なパス区切り記号と
の組み合わせを返します。

.構文

[source,vbscript]
----
object.BuildPath (path, name)
----

[cols="1,4",options="header"]
|===
| Part   | Description
| object | 必須です。 常に FileSystemObject の名前。
| path   | 必須。 _名前_を組み合わせる既存のパス。 絶対パスまたは相対パスを指
定することができ、既存のフォルダーを指定する必要はありません。
| name   | 必ず指定します。 既存の_パス_に追加されるフォルダーまたはファイルの
名前。
|===

.注釈

BuildPath メソッドでは、必要な場合に限り、既存のパスと名前の間に追加のパス区切
りを挿入します。


==== CopyFile メソッド

1 つまたは複数のファイルを別の場所にコピーします。

.構文

[source,vbscript]
----
object.CopyFile source, destination, [ overwrite ]
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必ず指定します。 object は、常に FileSystemObject の名前です。
|source |必須。 コピーする 1 つ以上のファイルを示す、ファイル指定用文字列。ワイルドカード文字も使用できます。
|destination |必須です。 source から 1 つ以上のファイルをコピーする先を指定する文字列。 ワイルドカード文字は使用できません。
|overwrite |省略可能。 既存のファイルを上書きできるかどうかを示すブール値です。 True の場合はファイルが上書きされ、False の場合は上書きされません。 既定値は True です。 destination に読み取り専用属性が設定されている場合は、overwrite の値にかかわらず CopyFile は失敗します。
|===

.解説

ワイルドカード文字を使用できるのは、 source 引数の最後のパス コンポーネントだ
けです。 たとえば、以下を使用できます。

[source,vbscript]
----
FileSystemObject.CopyFile "c:\mydocuments\letters\*.doc", "c:\tempfolder\"
----

以下のようには使用できません。

[source,vbscript]
----
FileSystemObject.CopyFile "c:\mydocuments\*\R1???97.xls", "c:\tempfolder"
----

source にワイルドカード文字が含まれている場合や、destination がパスの区切り文
字 (**) で終わっている場合は、destination は一致するファイルのコピー先となる既
存のフォルダーと見なされます。 それ以外の場合は、destination は作成するファイ
ルの名前と見なされます。 いずれの場合も、個々のファイルのコピー時に起こり得る
ことは 3 つあります。


1. destination が存在しない場合は、source がコピーされます。 これは通常のケー
   スです。

2. destination が既存のファイルの場合、 overwrite が False のときはエラーが発
   生します。 True のときは既存のファイルを上書きして source がコピーされます。

3. destination がディレクトリの場合は、エラーが発生します。

source でワイルドカード文字が使用されていて、どのファイルとも一致しなかった場
合も、エラーが発生します。 いずれかのエラーが発生した時点で CopyFile メソッド
の実行は停止されます。 エラーが発生するまでに行われた変更を取り消したり元に戻
したりする処理は一切行われません。

==== CopyFolder メソッド

フォルダーを再帰的に別の場所にコピーします。

.構文

[source,vbscript]
----
object.CopyFolder source, destination, [ overwrite ]
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必ず指定します。 常に FileSystemObject の名前。
|source |必須。 コピーする 1 つ以上のフォルダーを指定する文字列です。ワイルドカード文字を使用できます。
|destination |必須です。 source のフォルダーとサブフォルダーのコピー先を指定する文字列です。 ワイルドカード文字は使用できません。
|overwrite |省略可能。 既存のフォルダーを上書きするかどうかを示す ブール 値です。 True の場合はファイルが上書きされ、 False の場合は上書きされません。 既定値は True です。
|===

.解説

ワイルドカード文字を使用できるのは、 source 引数の最後のパス コンポーネントだ
けです。 たとえば、以下を使用できます。

[source,vbscript]
----
FileSystemObject.CopyFolder "c:\mydocuments\letters\*", "c:\tempfolder\"
----

以下のようには使用できません。

[source,vbscript]
----
FileSystemObject.CopyFolder "c:\mydocuments\*\*", "c:\tempfolder\"
----

source にワイルドカード文字が含まれている場合や、destination がパスの区切り文
字 ()) で終わっている場合は、destination は一致するフォルダーとサブフォルダー
のコピー先となる既存のフォルダーと見なされます。 

それ以外の場合は、destinationは作成するフォルダーの名前と見なされます。 

いずれの場合も、個々のフォルダーがコピーされるときに起こり得ることは 4 つあり
ます。


1. destination が存在しない場合は、source フォルダーとそのすべての内容がコピー
   されます。 これは通常のケースです。

2. destination が既存のファイルの場合は、エラーが発生します。

3. destination がディレクトリの場合は、フォルダーとそのすべての内容のコピーを
   しようとします。 source に含まれているファイルが destination に既に存在する
場合は、overwrite が False に設定されているとエラーが発生します。 それ以外の場
合、ファイルを既存のファイルにコピーしようとします。

4. destination が読み取り専用のディレクトリで、overwrite が False の場合、既存
   の読み取り専用のファイルをそのディレクトリにコピーしようとするとエラーが発
生します。

source でワイルドカード文字が使用されていて、どのフォルダーとも一致しなかった
場合も、エラーが発生します。

CopyFolder メソッドは、最初のエラーが発生した時点で処理を中止します。 エラーが
発生するまでに行われた変更を取り消したり元に戻したりする処理は一切行われません。

==== CreateFolder メソッド

フォルダーを作成します。

.構文

[source,vbscript]
----
object.CreateFolder (foldername)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|foldername |必ず指定します。 作成するフォルダーを識別する 文字列式です。
|===

.注釈

指定したフォルダーがすでに存在する場合は、エラーが発生します。




==== CreateTextFile メソッド

指定されたファイル名を作成し、ファイルの読み取りまたは書き込みに使用できる**TextStream** オブジェクトを返します。


.構文


[source,vbscript]
----
object.CreateTextFile (filename, [ overwrite, [ unicode ]])
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に**FileSystemObject** または**Folder** オブジェクトの名前を指定します。
|filename |必須。 作成するファイルを示す 文字列式。
|overwrite |省略可能。 既存のファイルを上書きできるかどうかを示す Boolean 値。 ファイルを上書きできる場合は True 、上書きできない場合は False です。 省略した場合、既存のファイルは上書きできます。
|unicode |省略可能。 Unicode ファイルを作成するか、ASCII ファイルを作成するかを示す Boolean 値です。 Unicode ファイルとして作成する場合は True 、ASCII ファイルとして作成する場合は False です。 省略した場合は、ASCII ファイルとみなされます。
|===

.注釈

次のコードは、 CreateTextFileメソッドを使用して、テキストファイルを作成して開
く方法を示しています。 _Overwrite_引数がFalseの場合、または指定されていない場
合は、既に存在する_ファイル名_に対してエラーが発生します。


[source,vbscript]
----
Sub CreateAfile
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set a = fs.CreateTextFile("c:\testfile.txt", True)
    a.WriteLine("This is a test.")
    a.Close
End Sub
----

==== DeleteFile メソッド

指定したファイルを削除します。

.構文

[source,vbscript]
----
object.DeleteFile filespec, [ force ]
----


[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|filespec |必須。 削除するファイルの名前です。 __ 最後のパス コンポーネントではワイルドカード文字を使用できます。
|force |省略可能。 読み取り専用属性が設定されているファイルを削除する場合は、 Trueを指定するブール型 (Boolean) の値を指定します。False(既定値)。
|===


.注釈

一致するファイルが見つからない場合はエラーが発生します。 DeleteFile メソッドは、
最初のエラーが発生した時点で中止されます。 エラーが発生する前に行われた変更は
ロールバックされません (元に戻されません)。

==== DeleteFolder メソッド

指定したフォルダーおよびその内容を削除します。

.構文

[source,vbscript]
----
object.DeleteFolder folderspec, [ force ]
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|folderspec |必須。 削除するフォルダーの名前。 folderspec の最後のパス コンポーネントにはワイルドカード文字を含むことができます。
|force |省略可能。 読み取り専用属性が設定されているフォルダーを削除する場合は、 Trueを指定するブール値。False(既定値)。
|===

.注釈

DeleteFolder メソッドでは、内容を持つフォルダーと内容を持たないフォルダーは区
別されません。 指定されたフォルダーは、内容を持つかどうかにかかわらず削除され
ます。

一致するフォルダーが見つからない場合は、エラーが発生します。 いずれかのエラー
が発生した時点で DeleteFolder メソッドの実行は停止されます。 エラーが発生する
前に行われた変更内容のロールバックまたは取り消しは行われません。


==== drive exists メソッド

指定したドライブが存在する場合は True、それ以外の場合は False を返します。

.構文

[source,vbscript]
----
object.DriveExists (drivespec)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|drivespec |必須。 ドライブのルートのドライブ文字またはパスの指定。
|===

.注釈

リムーバブル メディアを使用するドライブの場合、DriveExists メソッドはメディア
が存在しなくても True を返します。 ドライブの準備ができているかどうかを判断す
るには、 drive オブジェクトのisreadyプロパティを使用します。



==== FileExists メソッド

指定したファイルが存在する場合は True を返します。存在しない場合は False を返
します。

.構文

[source,vbscript]
----
object.FileExists (filespec)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|filespec |必須。 存在するかどうかを調べるファイルの名前を指定します。 ファイ
ルが現在のフォルダー内にないことが想定される場合は、完全なパス (絶対パスまたは
相対パス) を指定する必要があります。
|===

==== FolderExists メソッド

指定したフォルダーが存在する場合は、True を返します。存在しない場合は、False
を返します。

[source,vbscript]
----
object.FolderExists (folderspec)
----


[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|folderspec |必ず指定します。 存在するかどうかを調べるフォルダーの名前を指定し
ます。 フォルダーが現在のフォルダーにないと予想される場合は、完全なパス (絶対
パスまたは相対パス) を指定する必要があります。
|===


==== GetAbsolutePathName メソッド

指定したパス仕様から完全で明確なパスを返します。

.構文

[source,vbscript]
----
object.GetAbsolutePathName (pathspec)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|pathspec |必ず指定します。 完全で明確なパスに変更するパス仕様です。
|===

.注釈

指定したドライブのルートから完全な参照を提供しているパスは、完全で明確です。
完全なパスは、マップされたドライブのルートフォルダー*** を指定している場合にの
み、パス区切り文字 (*) で終わることができます。

次の表は、現在のディレクトリが c:\mydocuments\reports と仮定した場合の
GetAbsolutePathName メソッドの動作を示しています。

[cols="1,4",options="header"]
|===
|pathspec |返されるパス
|"c:" |"c:\mydocuments\reports"
|"c:.." |"c:\mydocuments"
|"c:\" |"c:"
|"c:. \ @ 97 |"c:\mydocuments\reports と仮定*/@ 97"
|"region1" |"c:\mydocuments\reports\region1"
|"c:....\mydocuments " |"c:\mydocuments"
|===

==== GetBaseNameメソッド

パスの最後のコンポーネントのファイル拡張子を除くベース名を含む文字列を返します。

.構文

[source,vbscript]
----
object.GetBaseName (path)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|path |必須。 ベース名を返すコンポーネントのパス指定。
|===

.注釈

GetBaseName メソッドは、path 引数に一致するコンポーネントがない場合は、長さ 0
の文字列 ("") を返します。


==== GetDrive メソッド

指定されたパスのドライブに対応する Drive オブジェクトを返します。

.構文

[source,vbscript]
----
object.GetDrive (drivespec)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|drivespec |必須。 _Drivespec_引数には、ドライブ文字 (c)、コロン (:) が追加されたドライブ文字、コロンとパスの区切り記号が追加されたドライブ文字 ()c:、または任意の\ネットワーク共有仕様 (computer2\share1) を使用できます。
|===

.注釈

ネットワーク共有の場合、共有が存在するかどうかが調べられます。

drivespec が許容されるどの形式にも従っていない場合、または存在しない場合は、エ
ラーが発生します。

GetDrive メソッドを通常のパス文字列で呼び出すには、次のシーケンスを使用して、
drivespec として使用するのに適した文字列を取得します。

[source,vbscript]
----
DriveSpec = GetDriveName(GetAbsolutePathName(Path))
----

==== GetDriveName メソッド

指定されたパスのドライブ名を含む文字列を返します。

.構文

[source,vbscript]
----
object.GetDriveName (path)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|path |必須。 ドライブ名を取得するコンポーネントのパスを指定します。
|===

.注釈

GetDriveName メソッドは、ドライブを特定できない場合には長さ 0 の文字列 ("") を
返します。

==== GetExtensionName メソッド

パスの最後の構成要素の拡張子名が含まれる文字列を返します。

.構文

[source,vbscript]
----
object.GetExtensionName (path)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|path |必須。 拡張子名を返すべき構成要素のパス指定。
|===

.注釈

ネットワークドライブの場合、ルートディレクトリ (**) はコンポーネントと見なされ
ます。

path 引数と一致する構成要素がない場合、GetExtensionName メソッドは長さ 0 の文
字列 ("") を返します。


==== GetFile メソッド

指定したパスのファイルに対応する**file** オブジェクトを返します。

.構文

[source,vbscript]
----
object.GetFile (filespec)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|filespec |必須。 filespec は、特定のファイルへのパス (絶対または相対) です。
|===

.注釈

指定されたファイルが存在しない場合は、エラーが発生します。


==== ★GetFileName メソッド

指定したパスの最後のコンポーネントを、ドライブの指定の一部ではないものとして返
します。

.構文

[source,vbscript]
----
object.GetFileName (pathspec)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|pathspec |必須。 特定のファイルのパス (絶対または相対)。
|===

.注釈

pathspec が名前付きのコンポーネントで終了していない場合、GetFileName メソッド
は長さがゼロの文字列 ("") を返します。

==== GetFolder メソッド

指定したパス内のフォルダーに対応する**folder** オブジェクトを返します。

.構文

[source,vbscript]
----
object.GetFolder (folderspec)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|folderspec |必須。 folderspec は、特定のフォルダーへのパス (絶対または相対) です。
|===

.注釈

指定されたフォルダーが存在しない場合は、エラーが発生します。

==== ★GetParentFolderName メソッド

指定したパスにある最後のコンポーネントの親フォルダー名が含まれる文字列を返します。

.構文

[source,vbscript]
----
object.GetParentFolderName (path)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|path |必ず指定します。 返される親フォルダー名のコンポーネントのパス仕様です。
|===

.注釈

path 引数で指定されたコンポーネントの親フォルダーがない場合、
GetParentFolderName メソッドは、長さ 0 の文字列 ("") を返します。

==== GetSpecialFolder メソッド

指定された特殊フォルダーを返します。

.構文

[source,vbscript]
----
object.GetSpecialFolder (folderspec)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|folderspec |必須。 取得する特殊フォルダーの名前です。 「設定値」に示した任意の定数を指定できます。
|===

.Settings

folderspec 引数には、次のいずれかの値を指定できます。

[cols="2,1,4",options="header"]
|===
|定数 |値 |説明
|WindowsFolder |.0 |Windows オペレーティング システムによってインストールされたファイルが格納されている Windows フォルダー。
|SystemFolder |1-d |ライブラリ、フォント、およびデバイス ドライバーが格納されている System フォルダー。
|TemporaryFolder |pbm-2 |一時ファイルの格納に使用される Temp フォルダー。 このパスは TMP 環境変数で指定されています。
|===


==== GetTempName メソッド

一時ファイルまたはフォルダーを必要とする演算を実行するのに役立つ、ランダムに生
成された一時ファイルまたはフォルダーの名前を返します。

.構文

[source,vbscript]
----
object.GetTempName
----
オプションの_object_は、常に**FileSystemObject** の名前です。

.注釈

GetTempName メソッドでは、ファイルが作成されません。 このメソッドでは、ファイ
ルを作成する CreateTextFile で使用できる一時ファイルの名前を提供するだけです。

==== MoveFile メソッド

1 つまたは複数のファイルを別の場所に移動します。

.構文

[source,vbscript]
----
object.MoveFile source, destination
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必ず指定します。 常に FileSystemObject の名前。
|source |必須。 移動するファイルのパス。 source 引数として指定する文字列では、パスの最後の構成要素に限ってワイルドカード文字を使用できます。
|destination |必須です。 ファイルの移動先のパス。 destination 引数には、ワイルドカード文字を使用できません。
|===

.解説

source でワイルドカード文字を使用した場合、または destination がパスの区切り文
字 ( *** ) で終わっている場合、destination は、該当するファイルを移動する既存
のフォルダーを指定していると見なされます。 それ以外の場合、destination は作成
する移動先ファイルの名前であると見なされます。 いずれの場合も、個々のファイル
の移動時に起こり得ることは 3 つあります。

* destination が存在しない場合は、そのファイルが移動されます。 これは通常のケースです。

* destination が既存のファイルの場合は、エラーが発生します。

* destination がディレクトリの場合は、エラーが発生します。

source で使用したワイルドカード文字がどのファイルとも一致しなかった場合も、エ
ラーが発生します。 MoveFile メソッドは、最初のエラーが発生した時点で処理を中止
します。 エラーが発生するまでに行われた変更を取り消したり元に戻したりする処理
は一切行われません。

==== MoveFolder メソッド

1 つまたは複数のフォルダーを別の場所に移動します。

.構文

[source,vbscript]
----
object.MoveFolder (source, destination)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必ず指定します。 常に FileSystemObject の名前。
|source |必須。 移動するフォルダーのパス。 source 引数として指定する文字列では、パスの最後の構成要素に限ってワイルドカード文字を使用できます。
|destination |必須です。 フォルダーの移動先のパス。 destination 引数には、ワイルドカード文字を使用できません。
|===

.解説

source でワイルドカード文字を使用した場合、または destination がパスの区切り文
字 ( *** ) で終わっている場合、destination は、該当するファイルを移動する既存
のフォルダーを指定していると見なされます。 それ以外の場合、destination は作成
する移動先フォルダーの名前であると見なされます。 いずれの場合も、個々のフォル
ダーの移動時に起こり得ることは 3 つあります。

* destination が存在しない場合は、そのフォルダーが移動されます。 これが通常の場合です。

* destination が既存のファイルの場合は、エラーが発生します。

* destination がディレクトリの場合は、エラーが発生します。

source で使用したワイルドカード文字がどのフォルダーとも一致しなかった場合も、
エラーが発生します。 MoveFolder メソッドは、最初のエラーが発生した時点で処理を
中止します。 エラーが発生するまでに行われた変更を取り消したり元に戻したりする
処理は一切行われません。


==== OpenTextFile メソッド

指定したファイルを開き、開いたファイルの読み取り、書き込み、または追加書き込み
に使用できる TextStream オブジェクトを返します。

.構文

[source,vbscript]
----
object.OpenTextFile (filename, [ iomode, [ create, [ format ]]])
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に FileSystemObject の名前。
|filename |必須です。 開くファイルを識別する文字列式です。
|iomode |省略可能。 入力/出力モードを示します。 ForReading、ForWriting、または ForAppending のいずれかの定数を指定できます。
|create |省略可能。 filename で指定したファイルが存在しない場合に新しいファイルを作成できるかどうかを示す ブール値です。 新しいファイルを作成する場合は True、作成しない場合は False を指定します。 既定値は False です。
|format |省略可能。 開くファイルの形式を示す Tristate の 3 つの値のいずれかです。 省略すると、ASCII 形式でファイルが開きます。
|===

.設定

iomode 引数には、次のいずれかを設定できます。


[cols="2,1,4",options="header"]
|===
|定数 |値 |説明
|ForReading |1-d |ファイルを読み取り専用として開きます。 このファイルには書き込むことはできません。
|ForWriting |pbm-2 |ファイルを書き込み専用として開きます。 既存のファイルを新しいデータで置き換える場合はこのモードを使用します。 このファイルからの読み取りはできません。
|ForAppending |8 |ファイルを開き、ファイルの最後に書き込みます。 このファイルからの読み取りはできません。
|===


[cols="2,1,4",options="header"]
|===
|定数 |値 |説明
|TristateUseDefault |-2 |システムの既定の設定でファイルを開きます。
|TristateTrue |-1 |Unicode 形式でファイルを開きます。
|TristateFalse |.0 |Ascii 形式でファイルを開きます。
|===

.解説

次のコードは、テキストを追加するために、 OpenTextFile メソッドを使用してファイ
ルを開く方法を示しています。


[source,vbscript]
----
Sub OpenTextFileTest
    Const ForReading = 1, ForWriting = 2, ForAppending = 8
    Dim fs, f
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.OpenTextFile("c:\testfile.txt", ForAppending, TristateFalse)
    f.Write "Hello world!"
    f.Close
End Sub
----


=== プロパティ

==== Drives プロパティ

ローカルコンピューターで使用できるすべての**Drive** オブジェクトで構成される
**Drives** コレクションを返します。

.構文

[source,vbscript]
----
object.Drives

The object is always a FileSystemObject.
----

.解説

Drives コレクションには、メディアが挿入されていない場合でも、リムーバブル メデ
ィア ドライブが表示されます。

 For Each... を使用して、Drives コレクションのメンバーを反復処理することが
できます。 次のコードに示されているように、次のコンストラクト。



[source,vbscript]
----
Sub ShowDriveList
    Dim fs, d, dc, s, n
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set dc = fs.Drives
    For Each d in dc
        s = s & d.DriveLetter & " - " 
        If d.DriveType = 3 Then
            n = d.ShareName
        Else
            n = d.VolumeName
        End If
        s = s & n & vbCrLf
    Next
    MsgBox s
End Sub
----


==== Name プロパティ

指定したファイルまたはフォルダーの名前を設定または取得します。 値の取得と設定
が可能です。

.構文


[source,vbscript]
----
object.Name [ = newname ]
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に、ファイル または**Folder** オブジェクトの名前を指定します。
|newname |省略可能。 指定した場合、newname が、指定した object の新しい名前になります。
|===


.注釈

次のコードは、 Nameプロパティの使用方法を示しています。

[source,vbscript]
----
Sub ShowFileAccessInfo(filespec)
    Dim fs, f, s
    Set fs = CreateObject("Scripting.FileSystemObject")
    Set f = fs.GetFile(filespec)
    s = f.Name & " on Drive " & UCase(f.Drive) & vbCrLf
    s = s & "Created: " & f.DateCreated & vbCrLf
    s = s & "Last Accessed: " & f.DateLastAccessed & vbCrLf
    s = s & "Last Modified: " & f.DateLastModified  
    MsgBox s, 0, "File Access Info"
End Sub
----


== TextStream オブジェクト

ファイルへの一連のアクセスを容易にします。

.構文

[source,vbscript]
----
TextStream. { property | method }
----

property 引数と method 引数は、TextStream オブジェクトに関連付けられている任意
のプロパティとメソッドになることができます。 実際の使用時に、TextStream は、
FileSystemObject から返される TextStream オブジェクトを表す変数プレースホルダ
ーに置き換えられます。

.解説

次のコードで、a は、FileSystemObject 上の CreateTextFile メソッドによって返さ
れる TextStream オブジェクトです。WriteLine と Close は、TextStream オブジェク
トの 2 つのメソッドです。

[source,vbscript]
----
Set fs = CreateObject("Scripting.FileSystemObject")
Set a = fs.CreateTextFile("c:\testfile.txt", True)
a.WriteLine("This is a test.")
a.Close
----

.メソッド

[cols="1,4",options="header"]
|===
|メソッド |説明
|Close |開いている TextStream ファイルを閉じます。
|Read |指定した文字数を TextStream ファイルから読み取り、結果を返します。
|ReadAll |TextStream ファイル全体を読み取り、結果を返します。
|ReadLine |TextStream ファイルから 1 行を読み取り、結果を返します。
|Skip |TextStream ファイルを読み取るときに、指定した文字数をスキップします。
|SkipLine |TextStream ファイルを読み取るときに、次の行をスキップします。
|Write |指定したテキストを TextStream ファイルに書き込みます。
|WriteBlankLines |指定した数の改行文字を TextStream ファイルに書き込みます。
|WriteLine |指定したテキストと改行文字を TextStream ファイルに書き込みます。
|===


.プロパティ

[cols="1,4",options="header"]
|===
|プロパティ |説明
|AtEndOfLine |TextStream ファイルの行末マーカーの直前にファイル ポインターがある場合は true を返し、そうでない場合は false を返します。
|AtEndOfStream |TextStream の最後にファイル ポインターがある場合は true を返し、そうでない場合は false を返します。
|Column |入力ストリーム内の現在の文字位置の列番号を返します。
|Line |TextStream ファイル内の現在の行番号を返します。
|===


=== メソッド

==== Close メソッド

開いている**TextStream** ファイルを閉じます。

.構文

[source,vbscript]
----
object.Close
----

object は常に TextStream オブジェクトの名前となります。


==== Read メソッド

TextStream ファイルから指定した数の文字を読み取って、結果の文字列を戻します。

.構文

[source,vbscript]
----
object.Read (characters)
----


[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に**TextStream** オブジェクトの名前を指定します。
|characters |必須。 ファイルから読み取る文字数を指定します。
|===

==== ReadAll メソッド

TextStream ファイル全体を読み取って、結果の文字列を返します。

.構文

[source,vbscript]
----
object.ReadAll
----

object は常に TextStream オブジェクトの名前となります。

.解説

大きなファイルで ReadAll メソッドを使用すると、メモリ リソースを大量に使用しま
す。 ファイルを1行ずつ読み取るなど、他の手法を使用してファイルを入力する必要が
あります。


==== ReadLine メソッド

TextStream ファイルから行全体 (改行文字の前まで) を読み取り、その文字列を返します。

.構文

[source,vbscript]
----
object.ReadLine
----

_Object_引数は常に**TextStream** オブジェクトの名前です。

==== Skip メソッド

TextStream を読み込むときに、指定された数の文字をスキップします。

.構文

[source,vbscript]
----
object.Skip (characters)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に**TextStream** オブジェクトの名前を指定します。
|characters |必須。 ファイルを読み込むときにスキップする文字数。
|===

.注釈

スキップした文字は破棄されます。

==== SkipLine メソッド

TextStream ファイルを読むときに、次の行をスキップします。

.構文

[source,vbscript]
----
object.SkipLine
----

object は常に TextStream オブジェクトの名前となります。

.解説

行をスキップするとは、次の改行文字まで、その改行文字を含め、行内のすべての文字
を読み取って破棄することを意味します。

ファイルが読み取り用に開かれていない場合、エラーが発生します。


==== Write メソッド

指定した文字列を TextStream ファイルに書き込みます。

.構文

[source,vbscript]
----
object.Write (string)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に**TextStream** オブジェクトの名前を指定します。
|string |必須。 ファイルに書き込むテキストです。
|===

.注釈

文字列を複数指定した場合、各文字列がスペースや文字で区切られずに続けて書き込ま
れます。 改行文字や最後が改行文字で終わる文字列を書き込む場合は、WriteLine メ
ソッドを使用します。

==== Write空白行メソッド

指定した数の改行文字を、TextStream ファイルに書き込みます。

.構文

[source,vbscript]
----
object.WriteBlankLines (lines)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に**TextStream** オブジェクトの名前を指定します。
|lines |必須。 ファイルに書き込む改行文字の数。
|===

==== WriteLine メソッド

指定された文字列および改行文字を TextStream ファイルに書き込みます。

.構文

[source,vbscript]
----
object.WriteLine ([ string ])
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に**TextStream** オブジェクトの名前を指定します。
|string |省略可能。 ファイルに書き込むテキスト。 省略した場合は、改行文字がファ
イルに書き込まれます。
|===

=== プロパティ

==== AtEndOfLine プロパティ

TextStream ファイルの行末マーカーの直前にファイル ポインターがある場合は True
を返す読み取り専用のプロパティです。ない場合は False を返します。

.構文

[source,vbscript]
----
object.AtEndOfLine
----

object は常に TextStream オブジェクトの名前となります。

.解説

AtEndOfLine プロパティは、読み取りを行うように開いた TextStream ファイルに対し
てのみ使用できます。それ以外の場合は、エラーが発生します。

次のコードは、AtEndOfLine プロパティの使用例を示しています。

[source,vbscript]
----
Dim fs, a, retstring
Set fs = CreateObject("Scripting.FileSystemObject")
Set a = fs.OpenTextFile("c:\testfile.txt", ForReading, False)
Do While a.AtEndOfLine <> True
    retstring = a.Read(1)
    ...
Loop
a.Close
----

==== AtEndOfStream プロパティ

TextStream ファイルの末尾にファイル ポインターがある場合は True を返す読み取り
専用のプロパティです。ない場合は False を返します。

.構文

[source,vbscript]
----
object.AtEndOfStream
----

object は常に TextStream オブジェクトの名前となります。

.解説

AtEndOfStream プロパティは、読み取りを行うように開いた TextStream ファイルに対
してのみ使用できます。それ以外の場合は、エラーが発生します。

次のコードは、AtEndOfStream プロパティの使用例を示しています。

[source,vbscript]
----
Dim fs, a, retstring
Set fs = CreateObject("Scripting.FileSystemObject")
Set a = fs.OpenTextFile("c:\testfile.txt", ForReading, False)
Do While a.AtEndOfStream <> True
    retstring = a.ReadLine
    ...
Loop
a.Close
----

==== Column プロパティ
TextStream ファイル内の現在の文字位置の列番号を返す読み取り専用プロパティです。

.構文

[source,vbscript]
----
object.Column
----

object は常に TextStream オブジェクトの名前となります。

.解説

改行文字が書き込まれた後から、その他の文字が書き込まれる前まで、Column は 1 と
等しくなります。

==== Line プロパティ

TextStream ファイル内の現在の行番号を返す読み取り専用のプロパティ。

.構文

[source,vbscript]
----
object.Line
----

object は常に TextStream オブジェクトの名前となります。

.解説

ファイルを初めて開き、書き込みを行う前は、Line は 1 です。
















== UserForm
=== ListBox


.クリア


[source,vbscript]
----
ListBox1.Clear
----

.追加

[source,vbscript]
----
ListBox1.Additem "This is a pen"
----

.追加選択

[source,vbscript]
----
ListBox1.Additem "This is a pen"
ListBox1.Selected(ListBox1.ListCount -1) = True
----


.全選択

[source,vbscript]
----
ListBox1.MultiSelect = fmmultiselectextended
Dim i As Long
For i = 0 To ListBox1.ListCount -1
    ListBox1.Selected(i) = True
Next
----


.選択行表示

[source,vbscript]
----
For i= 0 To ListBox1.ListCount -1
    If ListBox1.Selected(i)  Then
        Debug.Print ListBox1.List(i)
    End If
Next
----


.複数列追加

[source,vbscript]
----
ListBox1.ColumnCount = 2
ListBox1.ColumnWidths = "100:50"
ListBox1.AddItem ""
ListBox1.List(ListBox1.ListCount -1, 0) = "左"
ListBox1.List(ListBox1.ListCount -1, 1) = "右"
----




























































































































== Collection, Dictionary


[cols="1,4,4",options="header"]
|===
||Collection|Dictionary
|宣言|Dim c As New Collection| Dim d As New Scripting.Dictionary
| 追加| c.Add Item:=100,key:="This is a pen." +
c.Add 200."This" +
[red]#item, key# | d.Add key:="Orange",Item:=100 +
d.Add "Apple",200 +
[red]#key, item#
|item取得|Dim i As Long +
For i = 1 To c.Count +
    Debug.Peint c(i) +
Next +
[red]#1から始まる#| Dim i As Long +
Dim Kwys As Variant, Items As Variant +
Keys = d.keys +
Items = d.Items +
Fpr i = 0 To d.Count -1 +
    Debug.Print d.item(Keys(i)) +
    Debug.Print d.items(i) +
Next +
[red]#0から始まる#
||Dim v As Variant +
For Each v In c +
Debug.Print v +
Next |Dim v As Variant +
For Each v In d +
Debug.Print d.item(v) +
Next


|===


== Collection オブジェクト
https://docs.microsoft.com/ja-jp/office/vba/language/reference/user-interface-help/collection-object[Collection オブジェクト | Microsoft Docs]


Collection オブジェクトは、アイテムの順序が指定されたセットであり、1 つの単位
として参照できます。

.注釈

Collection オブジェクトを使用すると、関連性のあるアイテムのグループを 1 つのオ
ブジェクトとして簡単に参照できます。 コレクション内のアイテムつまりメンバーは、
コレクションに存在するという事実のみによって関連付けられる必要があります。 コ
レクションのメンバーは同じデータ型を共有する必要はありません。

コレクションは他のオブジェクトと同じ方法で作成できます。 以下に例を示します。

[source,vbscript]
----
Dim X As New Collection
----

コレクションを作成した後は、 Add メソッドを使用してメンバーを追加し、 Remove
メソッドを使用して削除できます。 特定のメンバーは、 Item メソッドを使用してコ
レクションから返すことができますが、For Each を使用してコレクション全体を反復
処理することもできます。 Next ステートメント。

.例

この例では、コレクションオブジェクトMyClasses() を作成し、ユーザーがコレクショ
ンにオブジェクトを追加できるダイアログボックスを作成します。

この動作を確認するには、[挿入] メニューから**** InstanceName[クラスモジュール]
コマンドを選択しInstanceName 、Class1 のモジュールレベルで呼び出されるパブリッ
ク変数を宣言して、各インスタンスの名前を保持します。 Leave the default name as
Class1. Copy and paste the following code into the General section of another
module, and then start it with the statement ClassNamer in another procedure.

(This example only works with host applications that support classes.)




[source,vbscript]
----
Sub ClassNamer()
    Dim MyClasses As New Collection    ' Create a Collection object.
    Dim Num    ' Counter for individualizing keys.
    Dim Msg As String    ' Variable to hold prompt string.
    Dim TheName, MyObject, NameList    ' Variants to hold information.
    Do
        Dim Inst As New Class1    ' Create a new instance of Class1.
        Num = Num + 1    ' Increment Num, then get a name.
        Msg = "Please enter a name for this object." & vbNewLine _
         & "Press Cancel to see names in collection."
        TheName = InputBox(Msg, "Name the Collection Items")
        Inst.InstanceName = TheName    ' Put name in object instance.
        ' If user entered name, add it to the collection.
        If Inst.InstanceName <> "" Then
            ' Add the named object to the collection.
            MyClasses.Add item := Inst, key := CStr(Num)
        End If
        ' Clear the current reference in preparation for next one.
        Set Inst = Nothing
    Loop Until TheName = ""
    For Each MyObject In MyClasses    ' Create list of names.
        NameList = NameList & MyObject.InstanceName & vbNewLine
    Next MyObject
    ' Display the list of names in a message box.
    MsgBox NameList, , "Instance Names In MyClasses Collection"

    For Num = 1 To MyClasses.Count    ' Remove name from the collection.
        MyClasses.Remove 1    ' Since collections are reindexed automatically, remove the first member on each iteration.
    Next
End Sub
----

=== Add メソッド (VBA)

Collection オブジェクトにメンバーを追加します。

.構文

[source,vbscript]
----
object.Add item, key, before, after
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須。 評価結果が [適用先] リストのオブジェクトになるオブジェクト式です。
|item |必須です。 コレクションに追加するメンバーを指定する任意の型の式です。
|key |省略可能。 コレクションのメンバーにアクセスするために位置インデックスの代わりに使用できるキー文字列を指定する一意の文字列式です。
|before |省略可能。 コレクション内の相対位置を指定する式です。 追加するメンバーは、before 引数によって識別されたメンバーの前のコレクション内に配置します。 数式の場合、before には、1 以上からコレクションの Count プロパティ値までの数値を指定する必要があります。 文字列式の場合、before は参照されているメンバーがコレクションに追加されたときに指定された key 引数に対応している必要があります。 before または after のどちらの位置でも指定できますが、両方を指定することはできません。
|after |省略可能。 コレクション内の相対位置を指定する式です。 追加するメンバーは、after 引数によって識別されたメンバーの後のレクション内に配置します。 数式の場合、after には、1 以上からコレクションの Count プロパティ値までの数値を指定する必要があります。 文字列の場合、after は、参照されているメンバーがコレクションに追加されたときに指定される key 引数に対応している必要があります。 before 位置または after 位置を指定できますが、両方とも指定することはできません。
|===

.解説

before 引数と after 引数は、文字列式であっても数式であっても、コレクションの既
存のメンバーを参照している必要があります。参照していない場合はエラーが発生しま
す。

指定した key がコレクションの既存のメンバーの key と重複している場合もエラーが
発生します。

.例

この例では、Add メソッドを使用して、Inst オブジェクト (パブリック変数
InstanceName を含む Class1 と呼ばれるクラスのインスタンス) を MyClasses と呼ば
れるコレクションに追加します。 このしくみを確認するには、クラス モジュールを挿
入し、InstanceName と呼ばれるパブリック変数を Class1 のモジュール レベルで宣言
して (Public InstanceName 型)、各インスタンスの名前を保持します。 名前は既定の
Class1 のままとします。 次のコードをコピーして、フォーム モジュールの
Form_Load イベント プロシージャに貼り付けます。



[source,vbscript]
----
Dim MyClasses As New Collection    ' Create a Collection object.
Dim Num As Integer    ' Counter for individualizing keys.
Dim Msg
Dim TheName    ' Holder for names user enters.
Do
    Dim Inst As New Class1    ' Create a new instance of Class1.
    Num = Num + 1    ' Increment Num, then get a name.
    Msg = "Please enter a name for this object." & Chr(13) _
     & "Press Cancel to see names in collection."
    TheName = InputBox(Msg, "Name the Collection Items")
    Inst.InstanceName = TheName    ' Put name in object instance.
    ' If user entered name, add it to the collection.
    If Inst.InstanceName <> "" Then
        ' Add the named object to the collection.
        MyClasses. Add item := Inst, key := CStr(Num)
    End If
    ' Clear the current reference in preparation for next one.
    Set Inst = Nothing
Loop Until TheName = ""
For Each x In MyClasses
    MsgBox x.instancename, , "Instance Name"
Next
----

=== Item メソッド

Collection オブジェクトの特定のメンバーを位置またはキー別に返します。

.構文

[source,vbscript]
----
object.Item(index)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須。 評価結果が [適用先] リストのオブジェクトになるオブジェクト式です。
|index |必須です。 コレクションのメンバーの位置を式で指定します。 数式の場合、index には、1 以上からコレクションの Count プロパティ値までの数値を指定します。 文字列式の場合、index は参照されているメンバーがコレクションに追加されたときに指定された_キー_引数に対応している必要があります。
|===

.解説

index として指定された値がコレクションの既存のどのメンバーとも一致しない場合は、
エラーが発生します。 Item メソッドは、コレクションの既定のメソッドです。 その
ため、次のコード行は同じです。

[source,vbscript]
----
Print MyCollection(1)
Print MyCollection.Item(1)
----

.例

この例では、Item メソッドを使用して、コレクション内のオブジェクトへの参照を取
得します。 Birthdays が Collection オブジェクトであると仮定した場合、次のコー
ドでは、"SmithBill" キーと "SmithAdam" キーが index 引数として使用され、コレク
ションから Bill Smith の誕生日と Adam Smith の誕生日を表すオブジェクトへの参照
が取得されます。

なお、最初の呼び出しでは Item メソッドが明示的に指定されていますが、2 つ目では
そのように指定されていません。 Item メソッドは Collection オブジェクトの既定で
あるため、いずれの呼び出しでも機能します。 Set で割り当てられている
SmithBillBD と SmithAdamBD への参照は、指定したオブジェクトのプロパティとメソ
ッドにアクセスするために使用できます。

このコードを実行するには、コレクションを作成し、それに少なくとも 2 つの参照メ
ンバーを挿入します。

[source,vbscript]
----
Dim SmithBillBD As Object
Dim SmithAdamBD As Object
Dim Birthdays
Set SmithBillBD = Birthdays.Item("SmithBill")
Set SmithAdamBD = Birthdays("SmithAdam")
----


=== Remove メソッド (VBA)

Collection オブジェクトからメンバーを削除します。

.構文

[source,vbscript]
----
object.Remove (index)
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須。 評価結果が [適用先] リストのオブジェクトになるオブジェクト式です。
|index |必須です。 コレクションのメンバーの位置を式で指定します。 数式の場合、index には、1 以上からコレクションの Count プロパティ値までの数値を指定します。 文字列式の場合、index は参照されているメンバーがコレクションに追加されたときに指定された_キー_引数に対応している必要があります。
|===

.解説

index の値がコレクションの既存のメンバーのいずれとも一致しない場合は、エラーが
発生します。

.例

次の例では、Remove メソッドを使用して Collection オブジェクト MyClasses からオ
ブジェクトを削除しています。 このコードは、ループの反復ごとに、インデックスが
1 のオブジェクトを削除します。

[source,vbscript]
----
Dim Num, MyClasses
For Num = 1 To MyClasses.Count    
    MyClasses.Remove 1    ' Remove the first object each time
            ' through the loop until there are 
            ' no objects left in the collection.
Next Num
----

=== Count プロパティ (VBA)

コレクション内のオブジェクト数を含む Long (長整数型) を返します。 読み取り専用
です。

.例

この例では、コレクション オブジェクトのCountプロパティを使用して、と呼ばれる
MyClassesコレクションのすべての要素を削除するために必要な反復回数を指定します。
コレクションの数値インデックスは、既定で 1 から始まります。 コレクションは削除
されたときに自動的に再インデックス化れるため、次のコードでは、各反復の最初のメ
ンバーを削除します。


[source,vbscript]
----
Dim Num, MyClasses
For Num = 1 To MyClasses.Count    ' Remove name from the collection.
    MyClasses.Remove 1    ' Default collection numeric indexes
Next    ' begin at 1.
----

=== Collectionのソート

[source,vbscript]
----
Sub sample()
    Dim c As New Collection, v As Variant
    Dim cs As New Collection

    c.Add Item:="xyz"
    c.Add Item:="def"
    c.Add Item:="abc"
    Set cs = SortCollection(c)
    For Each v In cs: Debug.Print v;: Next

End Sub

Function SortCollection(c As Collection) As Collection
    Dim v As Variant, r As New Collection
    Dim i As Long

    With CreateObject("System.Collections.ArrayList")
        For Each v In c
            .Add v
        Next
        .Sort
        For Each v In .toarray
            r.Add v
        Next
    End With

    Set SortCollection = r
End Function
----






== https://docs.microsoft.com/ja-jp/office/vba/language/reference/user-interface-help/dictionary-object[Dictionary オブジェクト | Microsoft Docs]

データ キー/アイテムのペアを保存するオブジェクト。

.構文

[source,vbscript]
----
Scripting.Dictionary
----

.解説

Dictionary オブジェクトは PERL 連想配列に相当します。 アイテムには任意の形式の
データを使用でき、配列に格納されます。 各アイテムは一意のキーに関連付けられま
す。 キーは、個々のアイテムを取得するために使用され、通常は整数または文字列と
なりますが、配列以外の任意の形式を使用できます。

次のコードは、Dictionary オブジェクトを作成する方法を示しています。

[source,vbscript]
----
Dim d                   'Create a variable
Set d = CreateObject("Scripting.Dictionary")
d.Add "a", "Athens"     'Add some keys and items
d.Add "b", "Belgrade"
d.Add "c", "Cairo"
...
----

.メソッド

[cols="1,4",options="header"]
|===
|メソッド |説明
|Add |Dictionary オブジェクトに新しいキー/アイテムのペアを追加します。
|Exists |指定したキーが Dictionary オブジェクト内に存在するかどうかを示すブール値を返します。
|Items |Dictionary オブジェクト内のすべてのアイテムの配列を返します。
|Keys |Dictionary オブジェクト内のすべてのキーの配列を返します。
|Remove |Dictionary オブジェクトから、指定したキー/アイテムのいずれかのペアを削除します。
|RemoveAll |Dictionary オブジェクト内のすべてのキー/アイテムのペアを削除します。
|===

.プロパティ

[cols="1,4",options="header"]
|===
|プロパティ |説明
|CompareMode |Dictionary オブジェクト内でキーを比較するために比較モードを設定するか返します。
|Count |Dictionary オブジェクト内のキー/アイテムのペアの数を返します。
|Item |Dictionary オブジェクト内のアイテムの値を設定するか返します。
|Key |Dictionary オブジェクト内の既存のキー値に対して新しいキー値を設定します。
|===

=== メソッド
==== Add メソッド

Dictionary オブジェクトにキーとアイテムのペアを追加します。

.構文


[source,vbscript]
----
object.Add key, item
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に Dictionary オブジェクトの名前です。
|key |必ず指定します。 アイテムに関連付けられた追加するキーを指定します。
|item |必須。 キーに関連付けられた追加するアイテムを指定します。
|===

.注釈

key が既に存在する場合は、エラーが発生します。

==== Exists メソッド

指定したキーが**Dictionary** オブジェクトに存在する場合はTrueを返します。False
の場合は False。

.構文

[source,vbscript]
----
object.Exists (key)
----


[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に Dictionary オブジェクトの名前です。
|key |必須。 Dictionary オブジェクト内で検索する Key の値。
|===


==== Items メソッド

Dictionary オブジェクト内のすべてのアイテムを含む配列を返します。

.構文

[source,vbscript]
----
object.Items
----

.注釈

次のコードは、Items メソッドの使用方法を示しています。

[source,vbscript]
----
Dim a, d, i             'Create some variables
Set d = CreateObject("Scripting.Dictionary")
d.Add "a", "Athens"     'Add some keys and items
d.Add "b", "Belgrade"
d.Add "c", "Cairo"
a = d.Items             'Get the items
For i = 0 To d.Count -1 'Iterate the array
    Print a(i)          'Print item
Next
...
----

==== Keys メソッド

Dictionary オブジェクト内のすべての既存のキーを含む配列を返します。

.構文

[source,vbscript]
----
object.Keys
----

.注釈

次のコードは、Keys メソッドの使用方法を示しています。

[source,vbscript]
----
Dim a, d, i             'Create some variables
Set d = CreateObject("Scripting.Dictionary")
d.Add "a", "Athens"     'Add some keys and items.
d.Add "b", "Belgrade"
d.Add "c", "Cairo"
a = d.keys              'Get the keys
For i = 0 To d.Count -1 'Iterate the array
    Print a(i)          'Print key
Next
...
----



==== Remove メソッド

Dictionary オブジェクトからキーとアイテムのペアを削除します。

.構文

[source,vbscript]
----
object.Remove (key)
----

[cols="1,4",options="header"]
|===
|指定項目 |説明
|object |必須です。 常に Dictionary オブジェクトの名前です。
|key |必須。 Dictionaryオブジェクトから削除するキー/アイテムのペアに関連付けら
れている_キー_です。
|===

.注釈

指定したキー/アイテムのペアが存在しない場合は、エラーが発生します。

次のコードは、 Removeメソッドの使用方法を示しています。


[source,vbscript]
----
Public Sub Start()

    Dim d As Object
    Set d = CreateObject("Scripting.Dictionary")

    d.Add "a", "Athens"
    d.Add "b", "Belgrade"
    d.Add "c", "Cairo"

    Debug.Print "Keys, before using Remove."
    PrintKeys d

    d.Remove "b"

    Debug.Print "Keys, after removing key 'b'."
    PrintKeys d

End Sub

Private Sub PrintKeys(ByVal d As Object)

    Dim k As Variant
    For Each k In d.Keys
        Debug.Print k
    Next k

End Sub

' The example displays the following output:
' Keys, before using Remove.
' a
' b
' c
' Keys, after removing key 'b'.
' a
' c
----

==== RemoveAll メソッド

RemoveAllメソッドは、 Dictionary オブジェクトから、キーとアイテムのすべてのペ
アを削除します。

.構文

[source,vbscript]
----
object.RemoveAll
----
object は常に Dictionary オブジェクトの名前です。

.注釈

次のコードは、 RemoveAllメソッドの使用方法を示しています。

[source,vbscript]
----
Dim a, d, i             'Create some variables
Set d = CreateObject("Scripting.Dictionary")
d.Add "a", "Athens"     'Add some keys and items
d.Add "b", "Belgrade"
d.Add "c", "Cairo"
...
a = d.RemoveAll         'Clear the dictionary
----

=== プロパティ
==== CompareMode プロパティ

Dictionary オブジェクト内の文字列キーを比較するための比較モードを設定および取
得します。

.構文

[source,vbscript]
----
object.CompareMode [ = compare ]
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に、Dictionary オブジェクトの名前です。
|compare |省略可能。 指定した場合、 _compare_は、 StrComp などの関数で使用され
る比較モードを表す値です。
|===

.設定

compare 引数には、次の値を指定できます。

[cols="1,4",options="header"]
|===
|定数 |値 |説明
|vbUseCompareOption |-1 |Option Compare ステートメントの設定を使用して比較を実
行します。
|vbBinaryCompare |.0 |バイナリ比較を実行します。
|vbTextCompare |1-d |テキスト比較を実行します。
|vbDatabaseCompare |pbm-2 |Microsoft Access のみ。 データベース内の情報に基づ
いて比較を実行します。
|===

.注釈

データが既に含まれる Dictionary オブジェクトの比較モードの変更を試みた場合、エ
ラーが発生します。

CompareMode プロパティは、StrComp 関数の compare 引数と同じ値を使用します。 2
より大きい値は、特定のロケール Id (LCID) を使用して比較を参照するために使用で
きます。



==== Count プロパティ

コレクションまたは**Dictionary** オブジェクト内の項目数を含む長整数型 (long)
の値を返します。 読み取り専用です。

.構文

[source,vbscript]
----
object.Count
----

_オブジェクト_は、常に、Applies To リストの 1 つの項目名です。

.解説

次のコードは、Count プロパティの使用例です。

[source,vbscript]
----
Dim a, d, i             'Create some variables
Set d = CreateObject("Scripting.Dictionary")
d.Add "a", "Athens"     'Add some keys and items.
d.Add "b", "Belgrade"
d.Add "c", "Cairo"
a = d.Keys              'Get the keys
For i = 0 To d.Count -1 'Iterate the array
    Print a(i)          'Print key
Next
...
----

==== Item プロパティ

Dictionary オブジェクト内の指定した_キー_の_アイテム_を設定または取得します。
コレクションについては、指定した key に基づいて item を取得します。 値の取得と
設定が可能です。

.構文

[source,vbscript]
----
object.Item (key) [ = newitem ]
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 コレクション またはDictionaryオブジェクトの名前を常に指定
します。
|key |必須。 取得または追加された項目に関連付けられた Key です。
|newitem |省略可能。 Dictionaryオブジェクトのみに使用されます。コレクションに
対するアプリケーションがありません。 指定した場合、 _newitem_は指定した_キー_
に関連付けられている新しい値です。
|===

.注釈

item を変更するときに key がない場合は、指定した newitem で新しい key が作成さ
れます。 既存の項目を返そうとしたときに key がない場合は、新しい key が作成さ
れ、対応する項目は空のままになります。

==== Key プロパティ

Dictionary オブジェクトに_キー_を設定します。

.構文

[source,vbscript]
----
object.Key (key) = newkey
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須です。 常に Dictionary オブジェクトの名前です。
|key |必須。 変更されている_キー_の値を指定します。
|newkey |必ず指定します。 指定した__ キーを置き換える新しい値です。
|===

.注釈

__ キーを変更するとき、__ キーが見つからない場合は、実行時エラーが発生します。





=== Dictionaryのソート


[source,vbscript]
----
Function SortCollection(c As Collection) As Collection
    Dim v As Variant, r As New Collection
    Dim i As Long

    With CreateObject("System.Collections.ArrayList")
        For Each v In c
            .Add v
        Next
        .Sort
        For Each v In .ToArray
            r.Add v
        Next
    End With

    Set SortCollection = r
End Function

Function SortDictionary(d As Scripting.Dictionary) As Dictionary
    Dim v As Variant, r As New Scripting.Dictionary
    With CreateObject("System.Collections.ArrayList")
        For Each v In d.Keys
            .Add v
        Next
        .Sort
        For Each v In .ToArray
            Debug.Print d.Item(v)
            r.Add v, d.Item(v)
        Next
    End With
    Set SortDictionary = r
End Function
----

=== DictionaryにClassを追加

独自の構造体？を配列にするよりリストにしたいときは以下を使用する


参照設定::
	Microsoft Scripting Runtime

.クラスモジュール

クラス名のオブジェクト名::
	PointF


[source,vbscript]
----
Public Keyword As String
Public Width As Single
Public Height As Single
----


.標準モジュール

[source,vbscript]
----
Sub sample()
    Dim d As New Scripting.Dictionary

    Dim i As Long

    For i = 2 To 10
        Dim c As New PointF
        Set c = New PointF
        c.Keyword = CStr(i)
        c.Width = i * 0.2
        c.Height = i * 0.4
        d.Add c.Keyword, c
    Next

    Dim v As Variant

    For Each v In d
        Debug.Print v, d(v).Keyword, d(v).Width, d(v).Height
    Next

End Sub
----


































//



































































































































































== グラフ

=== グラフ作成

[source,VBSCRIPT]
----
Dim rng As Range

    Set rng = Range("C1").CurrentRegion

With ActiveSheet.Shapes.AddChart.Chart
    .ChartType = xlXYScatterLines
    .SetSourceData rng
End With
----


.Xlcharttype クラス列挙 (Excel)

[cols="4,1,4",options="header"]
|===
 | 名前                       | 値    | 説明
 | xl3DBarClustered           | 60    | 3-D 集合横棒
 | xl3DBarStacked             | 61    | 3-D 積み上げ横棒
 | xl3DBarStacked100          | 62    | 3-D 100% 積み上げ横棒
 | xl3DColumn                 | -4100 | 3-D 縦棒
 | xl3DColumnClustered        | 54    | 3-D 集合縦棒
 | xl3DColumnStacked          | 55    | 3-D 積み上げ縦棒
 | xl3DColumnStacked100       | 56    | 3-D 100% 積み上げ縦棒
 | xlLine                     | 2/4   | 折れ線
 | xlLineMarkers              | 65    | マーカー付き折れ線
 | xlLineMarkersStacked       | 66    | マーカー付き積み上げ折れ線
 | xlLineMarkersStacked100    | 67    | マーカー付き 100% 積み上げ折れ線
 | xlLineStacked              | 63    | 積み上げ折れ線
 | xlLineStacked100           | 64    | 100% 積み上げ折れ線
 | xlXYScatter                | -4169 | 散布図
 | xlXYScatterLines           | 74    | [red]#折れ線付き散布図#
 | xlXYScatterLinesNoMarkers  | 75    | 折れ線付き散布図 (データ マーカーなし)
 | xlXYScatterSmooth          | 72    | 平滑線付き散布図
 | xlXYScatterSmoothNoMarkers | 73    | 平滑線付き散布図 (データ マーカーなし)
|===

=== グラフのタイトル変更

[source,VBSCRIPT]
----
With ActiveSheet.ChartObjects(1).Chart
    .HasTitle = True	'　まずは有効にしてから内容を指定する
    .ChartTitle.Text = "タイトル"
End With
----

[source,VBSCRIPT]
----
ActiveSheet.ChartObjects(1).Select
With ActiveChart
    .HasTitle = True	'　まずは有効にしてから内容を指定する
    .ChartTitle.Caption = "title"
End With
----

=== 軸の設定
==== 軸のタイトル

[source,VBSCRIPT]
----
' グラフのX軸(横軸)のタイトルを設定
ActiveChart.Axes(xlCategory, xlPrimary).HasTitle = True
ActiveChart.Axes(xlCategory, xlPrimary).AxisTitle.Characters.Text = "X軸タイトル"
----

[source,VBSCRIPT]
----
' グラフのY軸(縦軸)のタイトルを設定
ActiveChart.Axes(xlValue, xlPrimary).HasTitle = True
ActiveChart.Axes(xlValue, xlPrimary).AxisTitle.Characters.Text = "Y軸タイトル" 
----

==== 横軸？の最小値、最大値


=== マーカー設定

markersize::
2 から 72

* XlMarkerStyle 列挙 (Excel)
折れ線グラフ、散布図、またはレーダー チャートで、データ要素またはデータ系列の
マーカーのスタイルを設定します。
[cols="4,1,4",options="header"]
|===
 | 名前                   | 値    | 説明
 | xlMarkerStyleAutomatic | -4105 | 自動マーカー
 | xlMarkerStyleCircle    | ~     | 円形のマーカー
 | xlMarkerStyleDash      | -4115 | 長い棒のマーカー
 | xlMarkerStyleDiamond   | pbm-2 | ひし形のマーカー
 | xlMarkerStyleDot       | -4118 | 短い棒のマーカー
 | xlMarkerStyleNone      | -4142 | マーカーなし
 | xlMarkerStylePicture   | -4147 | 画像マーカー
 | xlMarkerStylePlus      | i-9   | 正符号 (+) 付きの四角形のマーカー
 | xlMarkerStyleSquare    | 1-d   | 四角形のマーカー
 | xlMarkerStyleStar      | 5     | アスタリスク (*) 付きの四角形のマーカー
 | xlMarkerStyleTriangle  | 1/3   | 三角形のマーカー
 | xlMarkerStyleX         | -4168 | X 印付きの四角形のマーカー
|===



[source,VBSCRIPT]
----
Dim Co As ChartObject
Dim Sc As Series

For Each Co In ActiveSheet.ChartObjects
    Debug.Print Co.Name

    For Each Sc In Co.Chart.SeriesCollection
        Debug.Print Sc.MarkerSize
        Debug.Print Sc.MarkerStyle

        Sc.MarkerSize = 12
        Sc.MarkerStyle
    Next
Next
----

== https://docs.microsoft.com/ja-jp/previous-versions/windows/scripting/cc392484(v=msdn.10)[VBScript のオブジェクトとコレクション | Microsoft Docs]

[cols="3,2", options="header"]
|===
|内容 |言語要素
|クラスのイベントにアクセスする手段を提供します。 |Class オブジェクト
|Err オブジェクトは、実行時エラーに関する情報を保有しています。 |Err オブジェクト
|正規表現で一致した文字列の読み取り専用プロパティにアクセスする手段を提供します。 |Match オブジェクト
|正規表現の Match オブジェクトのコレクションです。 |Matches コレクション
|正規表現の機能を提供します。 |RegExp オブジェクト
|正規表現のサブマッチ文字列のコレクションです。 |<<SubMatches,SubMatches コレクション>>
|===


=== Match オブジェクト

正規表現で一致した文字列の読み取り専用プロパティにアクセスする手段を提供します。

.解説

Match オブジェクトは、RegExp オブジェクトの Execute メソッドによってのみ作成が
可能です。このメソッドが実際に返すのは、Match オブジェクトのコレクションです。
Match オブジェクトのプロパティは、すべて読み取り専用です。

正規表現で検索を実行すると、Match オブジェクトが 0 個以上作成されます。それぞ
れの Match オブジェクトは、正規表現で検索された文字列、文字列の長さ、および文
字列が検索された場所のインデックスにアクセスする手段を提供します。

次のコードは、Match オブジェクトの使用例です。

[source,vbscript]
----
Function RegExpTest(patrn, strng)
   Dim regEx, Match, Matches   ' 変数を作成します。
   Set regEx = New RegExp   ' 正規表現を作成します。
   regEx.Pattern = patrn   ' パターンを設定します。
   regEx.IgnoreCase = True   ' 大文字と小文字を区別しないように設定します。
   regEx.Global = True   ' 文字列全体を検索するように設定します。
   Set Matches = regEx.Execute(strng)   ' 検索を実行します。
   For Each Match in Matches   ' Matches コレクションに対して繰り返し処理を行います。
      RetStr = RetStr & "一致 " & I & " が、"
      RetStr = RetStr & Match.FirstIndex & " で見つかりました。一致した文字列は、"
      RetStr = RetStr & Match.Value & " です。" & vbCRLF
   Next
   RegExpTest = RetStr
End Function
MsgBox(RegExpTest("is.", "IS1 is2 IS3 is4"))
----

.プロパティ

Match オブジェクトのプロパティ


.参照

Matches コレクション | RegExp オブジェクト | SubMatches コレクション


==== Match オブジェクトのプロパティ


Match オブジェクトを使用すると、正規表現で一致した文字列の読み取り専用プロパテ
ィにアクセスできます。

.プロパティ

FirstIndex プロパティ

Length プロパティ

Value プロパティ


==== FirstIndex プロパティ

検索対象の文字列内で一致が見つかった場所を返します。

[source,vbscript]
----
object.FirstIndex
----

引数 object には、Match オブジェクトを指定します。

.解説

FirstIndex プロパティは、検索文字列の始めを基点の 0 とするオフセットを使用しま
す。つまり、文字列の最初の文字が 0 として識別されます。次のコードは、
FirstIndex プロパティの使用例です。

[source,vbscript]
----
Function RegExpTest(patrn, strng)
   Dim regEx, Match, Matches   ' 変数を作成します。
   Set regEx = New RegExp   ' 正規表現を作成します。
   regEx.Pattern = patrn   ' パターンを設定します。
   regEx.IgnoreCase = True   ' 大文字と小文字を区別しないように設定します。
   regEx.Global = True   ' 文字列全体を検索するように設定します。
   Set Matches = regEx.Execute(strng)   ' 検索を実行します。
   For Each Match in Matches   ' Matches コレクションに対して繰り返し処理を行います。
RetStr = RetStr & "一致 " & I & " が、"
RetStr = RetStr & Match.FirstIndex & " で見つかりました。一致した文字列は、"
RetStr = RetStr & Match.Value & " です。" & vbCRLF
   Next
   RegExpTest = RetStr
End Function
MsgBox(RegExpTest("is.", "IS1 is2 IS3 is4"))
----


==== Length プロパティ

検索対象の文字列内で一致した文字列の長さを返します。

[source,vbscript]
----
object.Length
----

引数 object には、Match オブジェクトを指定します。

.解説

次のコードは、Length プロパティの使用例です。

[source,vbscript]
----
Function RegExpTest(patrn, strng)
   Dim regEx, Match, Matches   ' 変数を作成します。
   Set regEx = New RegExp   ' 正規表現を作成します。
   regEx.Pattern = patrn   ' パターンを設定します。
   regEx.IgnoreCase = True   ' 大文字と小文字を区別しないように設定します。
   regEx.Global = True   ' 文字列全体を検索するように設定します。
   Set Matches = regEx.Execute(strng)   ' 検索を実行します。
   For Each Match in Matches   ' Matches コレクションに対して繰り返し処理を行います。
RetStr = RetStr & "一致 " & I & " が、"
RetStr = RetStr & Match.FirstIndex & " で見つかりました。一致した文字列の長さは、"
RetStr = RetStr & Match.Length
RetStr = RetStr & " 文字です。" & vbCRLF
   Next
   RegExpTest = RetStr
End Function
MsgBox(RegExpTest("is.", "IS1 is2 IS3 is4"))
----

.参照

FirstIndex プロパティ | Value プロパティ

対象: Match オブジェクト


==== Value プロパティ

検索対象の文字列内で一致した値またはテキストを返します。

[source,vbscript]
----
object.Value
----

引数 object には、Match オブジェクトを指定します。

.解説

次のコードは、Value プロパティの使用例です。

[source,vbscript]
----
Function RegExpTest(patrn, strng)
   Dim regEx, Match, Matches   ' 変数を作成します。
   Set regEx = New RegExp   ' 正規表現を作成します。
   regEx.Pattern = patrn   ' パターンを設定します。
   regEx.IgnoreCase = True   ' 大文字と小文字を区別しないように設定します。
   regEx.Global = True   ' 文字列全体を検索するように設定します。
   Set Matches = regEx.Execute(strng)   ' 検索を実行します。
   For Each Match in Matches   ' Matches コレクションに対して繰り返し処理を行います。
RetStr = RetStr & "一致 " & I & " が、"
RetStr = RetStr & Match.FirstIndex & " で見つかりました。一致した文字列は、"
RetStr = RetStr & Match.Value & " です。" & vbCRLF
   Next
   RegExpTest = RetStr
End Function
MsgBox(RegExpTest("is.", "IS1 is2 IS3 is4"))
----

=== Matches コレクション

正規表現の Match オブジェクトのコレクションです。

.解説

Matches コレクションには、個別の Match オブジェクトが格納されます。このコレク
ションは、RegExp オブジェクトの Execute メソッドによってのみ作成可能です。個別
の Match オブジェクトのプロパティと同様、Matches コレクションのプロパティは読
み取り専用です。

正規表現で検索を実行すると、Match オブジェクトが 0 個以上作成されます。それぞ
れの Match オブジェクトは、正規表現で検索された文字列、文字列の長さ、および文
字列が検索された場所のインデックスにアクセスする手段を提供します。

次のコードは、正規表現の検索で Matches コレクションを取得し、コレクションに対
して繰り返し処理を行う例です。

[source,vbscript]
----
Function RegExpTest(patrn, strng)
   Dim regEx, Match, Matches   ' 変数を作成します。
   Set regEx = New RegExp   ' 正規表現を作成します。
   regEx.Pattern = patrn   ' パターンを設定します。
   regEx.IgnoreCase = True   ' 大文字と小文字を区別しないように設定します。
   regEx.Global = True   ' 文字列全体を検索するように設定します。
   Set Matches = regEx.Execute(strng)   ' 検索を実行します。
   For Each Match in Matches   ' Matches コレクションに対して繰り返し処理を行います。
RetStr = RetStr & "一致する文字列が見つかった位置は、"
      RetStr = RetStr & Match.FirstIndex & " です。一致した文字列は、"
      RetStr = RetStr & Match.Value & " です。" & vbCRLF
   Next
   RegExpTest = RetStr
End Function
MsgBox(RegExpTest("is.", "IS1 is2 IS3 is4"))
----

.参照

For Each...Next ステートメント | Match オブジェクト | RegExp オブジェクト | SubMatches コレクション


=== RegExp オブジェクト

正規表現の機能を提供します。

.解説

次のコードは、RegExp オブジェクトの使用例です。

[source,vbscript]
----
Function RegExpTest(patrn, strng)
   Dim regEx, Match, Matches   ' 変数を作成します。
   Set regEx = New RegExp   ' 正規表現を作成します。
   regEx.Pattern = patrn   ' パターンを設定します。
   regEx.IgnoreCase = True   ' 大文字と小文字を区別しないように設定します。
   regEx.Global = True   ' 文字列全体を検索するように設定します。
   Set Matches = regEx.Execute(strng)   ' 検索を実行します。
   For Each Match in Matches   ' Matches コレクションに対して繰り返し処理を行います。
      RetStr = RetStr & "一致する文字列が見つかった位置は、"
      RetStr = RetStr & Match.FirstIndex & " です。一致した文字列は、"
      RetStr = RetStr & Match.Value & " です。" & vbCRLF
   Next
   RegExpTest = RetStr
End Function
MsgBox(RegExpTest("is.", "IS1 is2 IS3 is4"))
----

.プロパティとメソッド

Regular Expression オブジェクトのプロパティとメソッド

.参照

Match オブジェクト | Matches コレクション


=== Regular Expression オブジェクトのプロパティとメソッド

Regular Expression オブジェクトは、簡単な正規表現をサポートします。

.プロパティ

Global プロパティ

IgnoreCase プロパティ

Pattern プロパティ

.メソッド

Execute メソッド

Replace メソッド

Test メソッド


==== Global プロパティ

検索文字列全体についてのパターンとの一致を検索するか、最初の一致だけを検索する
かを示すブール (Boolean) 値を設定します。

[source,vbscript]
----
object.Global [= True | False ]
----

引数 object には、RegExp オブジェクトを指定します。Global プロパティの値は、文
字列全体に検索が適用されると True、適用されないと False です。既定値は False
です。

.解説

次のコードは、Global プロパティの使用例です。Global プロパティに代入された値を
変更し、結果を確認してください。

[source,vbscript]
----
Function RegExpTest(patrn, strng)
   Dim regEx, Match, Matches   ' 変数を作成します。
   Set regEx = New RegExp   ' 正規表現を作成します。
   regEx.Pattern = patrn   ' パターンを設定します。
   regEx.IgnoreCase = True   ' 大文字と小文字を区別しないように設定します。
   regEx.Global = True   ' 文字列全体を検索するように設定します。
   Set Matches = regEx.Execute(strng)   ' 検索を実行します。
   For Each Match in Matches   ' Matches コレクションに対して繰り返し処理を行います。
RetStr = RetStr & "一致する文字列が見つかった位置は、"
RetStr = RetStr & Match.FirstIndex & " です。一致した文字列は、"
RetStr = RetStr & Match.Value & " です。" & vbCRLF
   Next
   RegExpTest = RetStr
End Function
MsgBox(RegExpTest("is.", "IS1 is2 IS3 is4"))
----

.参照

IgnoreCase プロパティ | Pattern プロパティ

対象: RegExp オブジェクト

==== IgnoreCase プロパティ

パターン検索で大文字と小文字を区別するかどうかを示すブール (Boolean) 値を設定
します。

[source,vbscript]
----
object.IgnoreCase [= True | False ]
----

引数 object には、RegExp オブジェクトを指定します。IgnoreCase プロパティの値は、
検索するときに大文字と小文字を区別すると False、区別しないと True です。既定値
は False です。

.解説

次のコードは、IgnoreCase プロパティの使用例です。IgnoreCase プロパティに代入す
る値を変更して、結果を確認してください。

[source,vbscript]
----
Function RegExpTest(patrn, strng)
   Dim regEx, Match, Matches   ' 変数を作成します。
   Set regEx = New RegExp   ' 正規表現を作成します。
   regEx.Pattern = patrn   ' パターンを設定します。
   regEx.IgnoreCase = True   ' 大文字と小文字を区別しないように設定します。
   regEx.Global = True   ' 文字列全体を検索するように設定します。
   Set Matches = regEx.Execute(strng)   ' 検索を実行します。
   For Each Match in Matches   ' Matches コレクションに対して繰り返し処理を行います。
RetStr = RetStr & "一致する文字列が見つかった位置は、"
RetStr = RetStr & Match.FirstIndex & " です。一致した文字列は、"
RetStr = RetStr & Match.Value & " です。" & vbCRLF
   Next
   RegExpTest = RetStr
End Function
MsgBox(RegExpTest("is.", "IS1 is2 IS3 is4"))
----

.参照

Global プロパティ | Pattern プロパティ

対象: RegExp オブジェクト


==== Pattern プロパティ

検索される正規表現のパターンを設定します。値の取得も可能です。

[source,vbscript]
----
object.Pattern [= "searchstring"]
----

.引数

* object

必ず指定します。RegExp オブジェクト変数を指定します。

* searchstring

省略可能です。検索される文字列式を指定します。Settings セクションの表で定義された正規表現の文字をどれでも使用できます。

.設定値

正規表現のパターンの記述には、特別な文字およびエスケープ シーケンスが使用され
ます。次の表は、正規表現で使用できる文字およびエスケープ シーケンスの一覧です。
この表では、簡単な使用例も含めて説明します。

[cols="1,4",options="header"]
|===
|文字 |内容
|\ |次に続く文字が特別な文字またはリテラルであることを示します。たとえば、"n" は "n" という文字と一致します。"\n"は、改行文字と一致します。"\\" は、"\" と一致します。"\(" は "(" と一致します。
|^ |入力の開始と一致します。
|$ |入力の終端と一致します。
|* |直前の文字と 0 回以上一致します。たとえば、"zo*" は "z" とも "zoo" とも一致します。
|+ |直前の文字と 1 回以上一致します。たとえば、"zo+" は "zoo" とは一致しますが、"z" とは一致しません。
|? |直前の文字と 0 回または 1 回一致します。たとえば、"a?ve?" は "never" の "ve" に一致します。
|. |改行文字以外の任意の単独文字と一致します。
|(pattern) |引数 pattern に指定した文字と一致します。一致する文字列が見つかったら、記憶されます。一致した部分は、Matches コレクションの項目 [0]...[n] から取得できます。かっこ文字、() を指定するには、"\(" および "\)" を使用します。
|x｜y |x と y のどちらかと一致します。たとえば、"z｜wood" は "z" と "wood" に一致します。"(z|w)oo" は、"zoo" と "wood" に一致します。
|{n} |n には、0 以上の整数を指定します。直前の文字と正確に n 回一致します。たとえば、"o{2}" は、"Bob" の "o" とは一致しませんが、"foooood" の最初の 2 つの o とは一致します。
|{n,} |n には、0 以上の整数を指定します。直前の文字と少なくとも n 回一致します。たとえば、"o{2,}" は、"Bob" の "o" とは一致しませんが、"foooood" のすべての o と一致します。"o{1,}" は、"o+" と同じ意味になります。"o{0,}" は、"o*" と同じ意味になります。
|{n,m} |m および n には、0 以上の整数を指定します。直前の文字と n ～ m 回一致します。たとえば、"o{1,3}" は、"fooooood" の最初の 3 つの o と一致します。"o{0,1}" は、"o?" と同じ意味になります。
|[xyz] |文字セット。角かっこで囲まれた文字の中のいずれかと一致します。たとえば、"[abc]" は "plain" の "a" と一致します。
|[^xyz] |否定の文字セット。角かっこで囲まれた文字にはない任意の文字と一致します。"[^abc]" は、"plain" の "p" と一致します。
|[a-z] |文字の範囲。指定した範囲に含まれる任意の文字に一致します。たとえば、"[a-z]" は、"a" から "z" までの任意のアルファベットの小文字に一致します。
|[^m-z] |否定の文字の範囲。指定した範囲に含まれていない任意の文字に一致します。たとえば、"[^m-z]" は "m" から "z" までの範囲に含まれない任意の文字に一致します。
|\b |単語の境界と一致します。単語の境界とは、単語とスペースの間の位置のことです。たとえば、"er\b" は、"never" の "er" に一致します。"verb" の "er" には一致しません。
|\B |単語の境界ではない部分と一致します。たとえば、"ea*r\B" は、"never early" の "ear" と一致します。
|\d |数字と一致します。[0-9] と指定した場合と同じ意味になります。
|\D |数字以外の文字と一致します。[^0-9] と指定した場合と同じ意味になります。
|\f |フォームフィード文字と一致します。
|\n |改行文字と一致します。
|\r |キャリッジ リターン文字と一致します。
|\s |スペース、タブ、フォームフィードなどの任意の空白文字と一致します。"[ \f\n\r\t\v]" と指定した場合と同じ意味になります。
|\S |空白文字のない部分と一致します。"[^ \f\n\r\t\v]" と指定した場合と同じ意味になります。
|\t |タブ文字と一致します。
|\v |垂直タブ文字と一致します。
|\w |単語に使用される任意の文字と一致します。これには、アンダースコアも含まれます。"[A-Za-z0-9_]" と指定した場合と同じ意味になります。
|\W |単語に使用される文字以外の任意の文字と一致します。"[^A-Za-z0-9_]" と指定した場合と同じ意味になります。
|\num |>num には、正の整数を指定します。既に見つかり、記憶されている部分と一致します。たとえば、"(.)\1" は、連続する 2 つの同じ文字に一致します。
|\n |n に指定した 8 進数のエスケープ値と一致します。8 進数の値には、1 桁、2 桁、または 3 桁で指定します。たとえば、"\11" と "\011" は、両方ともタブ文字に一致します。"\0011" は、"\001" および "1" と同じ意味になります。8 進数のエスケープ値は、256 を超えることはできません。256 を超える数値を指定した場合、初めの 2 桁で値が評価されます。この表記により、正規表現で ASCII コードを使用できるようになります。
|\xn |n に指定した 16 進数のエスケープ値と一致します。16 進数のエスケープ値は、2 桁である必要があります。たとえば、"\x41" は、"A" に一致します。"\x041" は、"\x04" および "1"と同じ意味になります。この表記により、正規表現で ASCII コードを使用できるようになります。
|===

.解説

次のコードは、Pattern プロパティの使用例です。

[source,vbscript]
----
Function RegExpTest(patrn, strng)
   Dim regEx, Match, Matches   ' 変数を作成します。
   Set regEx = New RegExp   ' 正規表現を作成します。
   regEx.Pattern = patrn   ' パターンを設定します。
   regEx.IgnoreCase = True   ' 大文字と小文字を区別しないように設定します。
   regEx.Global = True   ' 文字列全体を検索するように設定します。
   Set Matches = regEx.Execute(strng)   ' 検索を実行します。
   For Each Match in Matches   ' Matches コレクションに対して繰り返し処理を行います。
RetStr = RetStr & "一致する文字列が見つかった位置は、"
RetStr = RetStr & Match.FirstIndex & " です。一致した文字列は、"
RetStr = RetStr & Match.Value & " です。" & vbCRLF
   Next
   RegExpTest = RetStr
End Function
MsgBox(RegExpTest("is.", "IS1 is2 IS3 is4"))
----

.参照

Global プロパティ | IgnoreCase プロパティ

対象: RegExp オブジェクト

==== Execute メソッド

指定された文字列を正規表現で検索します。

[source,vbscript]
----
object.Execute(string) 
----

.引数

* object

必ず指定します。RegExp オブジェクトの名前を指定します。

* string

必ず指定します。正規表現による検索の対象となるテキスト文字列を指定します。

.解説

正規表現による検索の実際のパターンは、RegExp オブジェクトの Pattern プロパティ
を使って設定されます。

Execute メソッドは、string 内で見つかった文字列ごとに存在する Match オブジェク
トを含む、Matches コレクションを返します。一致する文字列が見つからない場合、空
の Matches コレクションを返します。

次のコードは、Execute メソッドの使用例です。

[source,vbscript]
----
Function RegExpTest(patrn, strng)
Dim regEx, Match, Matches      ' 変数を作成します。
Set regEx = New RegExp         ' 正規表現を作成します。
regEx.Pattern = patrn         ' パターンを設定します。
regEx.IgnoreCase = True         ' 大文字と小文字を区別しないように設定します。
regEx.Global = True         ' 文字列全体を検索するように設定します。
Set Matches = regEx.Execute(strng)   ' 検索を実行します。
For Each Match in Matches      ' Matches コレクションに対して繰り返し処理を行います。
RetStr = RetStr & "一致する文字列が見つかった位置は、"
RetStr = RetStr & Match.FirstIndex & " です。一致した文字列は、"
RetStr = RetStr & Match.Value & " です。" & vbCRLF
  Next
  RegExpTest = RetStr
End Function
MsgBox(RegExpTest("is.", "IS1 is2 IS3 is4"))
----

.参照

Replace メソッド | Test メソッド

対象: RegExp オブジェクト


==== Replace メソッド

正規表現による検索で見つかったテキストを置換します。

[source,vbscript]
----
object.Replace(string1, string2) 
----

.引数

* object

    必ず指定します。RegExp オブジェクトの名前を指定します。

* string1

    必ず指定します。String1 には、検索および置換の対象となるテキスト文字列を指定します。

* string2

    必ず指定します。String2 には、置換するテキスト文字列を指定します。

.解説

置換されるテキスト文字列の実際のパターンは、RegExp オブジェクトの Pattern プロ
パティを使って設定されます。

Replace メソッドは、string1 のコピーと、string2 で置換された RegExp.Pattern の
テキストを返します。一致する文字列が見つからない場合、string1 のコピーが変更さ
れずに返されます。

次のコードは、Replace メソッドの使用例です。

[source,vbscript]
----
Function ReplaceTest(patrn, replStr)
Dim regEx, str1               ' 変数を作成します。
  str1 = "The quick brown fox jumped over the lazy dog."
Set regEx = New RegExp            ' 正規表現を作成します。
regEx.Pattern = patrn            ' パターンを設定します。
regEx.IgnoreCase = True           ' 大文字と小文字を区別しないように設定します。
ReplaceTest = regEx.Replace(str1, replStr)   ' 置換します。
End Function
----

[source,vbscript]
----
MsgBox(ReplaceTest("fox", "cat"))      ' 'fox' を 'cat' で置換します。
----

Replace メソッドを使って、パターンに一致する文字列どうしを置換することもできま
す。上の例に示された関数を次のように呼び出すと、元の文字列に含まれる単語の各ペ
アが交換されます。

[source,vbscript]
----
MsgBox(ReplaceText("(\S+)(\s+)(\S+)", "$3$2$1"))   ' 単語のペアを交換します。
----

.参照

Execute メソッド | Test メソッド

対象: RegExp オブジェクト






== 正規表現で1行を空白で分割

産業設定::
	Microsoft VBscript Reguler Expressions 5.5

[source,vbscript]
----
Sub sample()

    Dim re As New RegExp
    Dim s As String: s = "This is a              pen."
    Dim ms As MatchCollection
    Dim m As Match

    re.Pattern = "\S+"
    re.Global = True
    Debug.Print s
    Set ms = re.Execute(s)
    For Each m In ms
        Debug.Print m
    Next

End Sub

'This is a              pen.
'This
'is
'a
'pen.
----





== DoNotUpdate

.classに追加する

クラスモジュール

[source,vbscript]
----
Private Sub Class_Initialize()
    With Application
        .ScreenUpdating = False
        .Calculation = xlCalculationManual
        .EnableEvents = False
        .PrintCommunication = False
    End With
End Sub

Private Sub Class_Terminate()
    With Application
        .ScreenUpdating = True
        .Calculation = xlCalculationAutomatic
        .EnableEvents = True
        .PrintCommunication = True
    End With

End Sub
----






== INDIRECT関数を使う

.INDIRECT関数の他シート参照例

A1セルに"Sheet2"、B1セルに"A1"と入っているとします。

[source,vbscript]
----
=INDIRECT(A1&"!"&B1)
----

この結果は、Sheet2のA1セルの値が出力されます。

.INDIRECT関数の範囲指定例

A列に数値が入っていて、C1セルA2、C2セルA5と入っているとします。

=SUM(INDIRECT(C1&":" &C2))

この結果は、A2～A5の合計になります。

[source,vbscript]
----

	A	B	C
1	1		A2
2	2		A5
3	3		=SUM(INDIRECT(C1&":" &C2))
4	4
5	5
6	6
7	7
8	8


----

== 配列を使うのに役立つ4つの関数――Array、LBound、UBound、Splitの使い方

=== https://docs.microsoft.com/ja-jp/office/vba/language/reference/user-interface-help/array-function[Array 関数 (Visual Basic for Applications) | Microsoft Docs]

配列を含む Variant を返します。

.構文

[source,vbscript]
----
Array(arglist)
----

必須の arglist 引数は、Variant に含まれている配列の要素に割り当てられる値のコ
ンマ区切りのリストです。 引数を指定しない場合は長さ 0 の配列が作成されます。

.解説

配列の要素を参照するために使用される表記は、変数 名とそれに続く括弧で構成され、
括弧の中には目的の要素を示すインデックス番号が入ります。

次の例では、最初のステートメントにより、Variant として「A」という名前の変数が
作成されます。 2 つ目のステートメントにより、変数 A に配列が割り当てられます。
最後のステートメントにより、2 つ目の配列要素に含まれる値が別の変数に割り当てら
れます。

[source,vbscript]
----
Dim A As Variant, B As Long, i As Long
A = Array(10, 20, 30)  ' A is a three element list by default indexed 0 to 2
B = A(2)               ' B is now 30
ReDim Preserve A(4)    ' Extend A's length to five elements
A(4) = 40              ' Set the fifth element's value
For i = LBound(A) To UBound(A)
    Debug.Print "A(" & i & ") = " & A(i)
Next i
----

Array 関数を使用して作成した配列の下限は、Array がタイプ ライブラリの名前で修
飾 (VBA.Array など) されていない限り、Option Base ステートメントで指定した下限
によって決まります。 タイプ ライブラリの名前で修飾されている場合は、Array は
Option Base の影響を受けません。

CAUTION:  配列として宣言されていない Variant には、配列を含めることができます。 Variant
変数には、固定長の文字列とユーザー定義の型を除き、あらゆる型の配列を含めること
ができます。 配列が含まれている Variant は要素の型が Variant の配列とは概念的
に異なりますが、配列要素には同じ方法でアクセスされます。


.例

この例では、 Array 関数を使用して、配列を含む Variant を返します。

[source,vbscript]
----
Dim MyWeek, MyDay
MyWeek = Array("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
' Return values assume lower bound set to 1 (using Option Base
' statement).
MyDay = MyWeek(2)    ' MyDay contains "Tue".
MyDay = MyWeek(4)    ' MyDay contains "Thu".
----


=== https://docs.microsoft.com/ja-jp/office/vba/language/reference/user-interface-help/lbound-function[LBound 関数 (Visual Basic for Applications) | Microsoft Docs]

配列の指定ディメンションに対して使用できる最小下付き文字が含まれる長整数型
(Long) の値を返します。

.構文

[source,vbscript]
----
LBound(arrayname, [ dimension ])
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|arrayname |必須です。 配列変数の名前を指定します。標準の変数の名前付け規則に
従います。
|dimension |省略可能。Variant (Long)。 どの次元の下限が返されるかを示す整数。
最初の次元には1、2番目の次元では2というように使用します。 _次元_を省略すると、
1が想定されます。
|===

.注釈

LBound関数を使用して、 配列のサイズを決定します。 UBound 関数は、配列のディメ
ンションの上限を確認する目的で使用します。

LBound は、次のディメンションの配列に対して、次の表に示す値を返します。

[cols="1,4",options="header"]
|===
|Statement |戻り値
|LBound(A, 1) |1-d
|LBound(A, 2) |.0
|LBound(A, 3) |-3
|===

任意の次元の下限の既定値は、 Option Base ステートメントの設定に応じて0または1
のいずれかになります。 Array 関数を使用して作成された配列のベースが0です。
Option Baseによる影響はありません。

Dim、 Private、 Public、 ReDim、またはStaticステートメントでTo句を使用してディ
メンションが設定されている配列は、下限として任意の整数値を持つことができます。

.例

次の例では、LBound 関数を使用して、配列の指定ディメンションに対して使用できる
最小下付き文字を決定します。 また、Option Base ステートメントを使用して、既定
のベース配列の下付き文字の値 0 を上書きします。


[source,vbscript]
----
Dim Lower
Dim MyArray(1 To 10, 5 To 15, 10 To 20)     ' Declare array variables.
Dim AnyArray(10)
Lower = Lbound(MyArray, 1)     ' Returns 1.
Lower = Lbound(MyArray, 3)    ' Returns 10.
Lower = Lbound(AnyArray)    ' Returns 0 or 1, depending on
    ' setting of Option Base.
----

=== https://docs.microsoft.com/ja-jp/office/vba/language/reference/user-interface-help/ubound-function[UBound 関数 (Visual Basic for Applications) | Microsoft Docs]

配列の指定した次元で使用できる添字の最大値を含むLongデータ型を返します。

.構文

[source,vbscript]
----
UBound(arrayname, [ dimension ])
----

[cols="1,4",options="header"]
|===
|パーツ |説明
|arrayname |必須です。 配列変数の名前を指定します。標準の変数の名前付け規則に
従います。
|dimension |省略可能。Variant (Long)。 取得する次元の上限を示す整数。 最初の次
元には1、2番目の次元では2というように使用します。 _次元_を省略すると、1が想定
されます。
|===

.注釈

UBound関数は、配列のサイズを決定するために**LBound** 関数と共に使用されます。
配列の次元の下限を調べる場合は LBound 関数を使用します。

配列の次元と UBound が返す値の関係を次に示します。

[cols="1,4",options="header"]
|===
|Statement |戻り値
|UBound(A, 1) |100
|UBound(A, 2) |1/3
|UBound(A, 3) |2/4
|===


.例

次の例では、UBound 関数を使用して、配列の指定した次元で使用できる下付き文字の
最大値を調べます。

[source,vbscript]
----
Dim Upper
Dim MyArray(1 To 10, 5 To 15, 10 To 20)    ' Declare array variables.
Dim AnyArray(10)
Upper = UBound(MyArray, 1)    ' Returns 10.
Upper = UBound(MyArray, 3)    ' Returns 20.
Upper = UBound(AnyArray)      ' Returns 10.
----

=== https://docs.microsoft.com/ja-jp/office/vba/language/reference/user-interface-help/split-function[Split 関数 (Visual Basic for Applications) | Microsoft Docs]

指定された数のサブ文字列が含まれる 0 ベースの 1 次元配列を返します。

.構文

[source,vbscript]
----
Split(expression, [ delimiter, [ limit, [ compare ]]])
----

[cols="1,4",options="header"]
|===
|指定項目 |説明
|expression |必ず指定します。 サブ文字列と区切り記号が含まれる文字列式です。
expression が長さ 0 の文字列 ("") の場合、Split は、空の配列、つまり、要素とデ
ータのない配列を返します。
|delimiter |オプション。 サブ文字列の制限を識別するために使用する文字列です。
省略すると、空白文字 (" ") が delimiter とみなされます。 _Delimiter_が長さ0の
文字列である場合は、_式_の文字列全体を含む単一要素の配列が返されます。
|limit |省略可能です。 返されるサブ文字列の数。-1 は、すべてのサブ文字列が返さ
れることを示します。
|compare |省略可能。 サブ文字列を評価するときに使用する比較の種類を示す数値で
す。 値については、「設定」セクションを参照してください。
|===


.設定

compare 引数には、次の値を指定できます。

[options="header"]
|===
|定数 |値 |説明
|vbUseCompareOption |-1 |Option Compare ステートメントの設定を使用して比較を実行します。
|vbBinaryCompare |.0 |バイナリ比較を実行します。
|vbTextCompare |1-d |テキスト比較を実行します。
|vbDatabaseCompare |pbm-2 |Microsoft Access のみ。 データベース内の情報に基づいて比較を実行します。
|===

.例

この例では、 Split関数の使用方法を示します。

[source,vbscript]
----
Dim strFull As String
Dim arrSplitStrings1() As Variant
Dim arrSplitStrings2() As Variant
Dim strSingleString1 As String
Dim strSingleString2 As String
Dim strSingleString3 As String
Dim i As Long

strFull = "Some - Old - Hags - Can - Always - Hide - Their - Old - Age"    ' String that will be used. 

arrSplitStrings1 = Split(strFull, "-")      ' arrSplitStrings1 will be an array from 0 To 8. 
                                            ' arrSplitStrings1(0) = "Some " and arrSplitStrings1(1) = " Old ". 
                                            ' The delimiter did not include spaces, so the spaces in strFull will be included in the returned array values. 

arrSplitStrings2 = Split(strFull, " - ")    ' arrSplitStrings2 will be an array from 0 To 8. 
                                            ' arrSplitStrings2(0) = "Some" and arrSplitStrings2(1) = "Old". 
                                            ' The delimiter includes the spaces, so the spaces will not be included in the returned array values. 

'Multiple examples of how to return the value "Can" (array position 3). 

strSingleString1 = arrSplitStrings2(3)      ' strSingleString1 = "Can". 

strSingleString2 = Split(strFull, " - ")(3) ' strSingleString2 = "Can".
                                            ' This syntax can be used if the entire array is not needed, and the position in the returned array for the desired value is known. 

For i = LBound(arrSplitStrings2, 1) To UBound(arrSplitStrings2, 1)
    If InStr(1, arrSplitStrings2(i), "Can", vbTextCompare) > 0 Then
        strSingleString3 = arrSplitStrings2(i)
        Exit For
    End If 
Next i
----

=== https://docs.microsoft.com/ja-jp/office/vba/language/reference/user-interface-help/join-function[配列]

配列に含まれている数多くのサブ文字列を結合して作成した文字列を返します。

.構文

[source,vbscript]
----
Join(sourcearray, [ delimiter ])
----

Join 関数の構文には、次の名前付き引数があります。

.構文


[cols="1,4",options="header"]
|===
|パーツ |説明
|sourcearray |必須。 結合するサブ文字列を含む 1 次元配列。
|delimiter |省略可能。 返される文字列内のサブ文字列の区切り文字。 省略した場合は、空白文字 (" ") が使用されます。 _Delimiter_が長さ0の文字列 ("") の場合、リスト内のすべてのアイテムは区切り文字なしで連結されます。
|===


















































////
.AsciiDocの歴史
****
AsciiDocは、Stuart Rackhamが2002年11月にリリースした
AsciiDocは、DocBookやLaTeXのような専門的な文章を作成するためのもので、
より簡単な文法で専門的は文章が書けるようにデザインされていた。
****

[[app-listing]]
[source,ruby]
.app.rb
----
require 'sinatra'

get '/hi' do
  "Hello World!"
end
----
////
Version is {revision}



Visual Basic の概念に関するトピック | Microsoft Docs
https://docs.microsoft.com/ja-jp/office/vba/language/reference/user-interface-help/visual-basic-conceptual-topics


//	vim:fileencoding=utf-8:ff=unix:
