= Visual Basic for Applications (VBA) の言語リファレンス
// 著者の名前(省略可)<メールアドレス(省略可能)>
// バージョンや作成日(省略可)
:Author:	yossym
:Email:     docomoxyz@gmail.com
:Date:      	2020-09-11
:Revision:  0.1


:toc:
:sectnums:
:toclevels: 5

:lang: ja
:doctype: book
:docname: VBA
:toclevels: 5
:sectnums:
:sectnumlevels: 5
// :source-highlighter: pygments
:source-language: VBscript
:toc: right
// :toc: left
:toc-title: 目次

////
Excel VBA リファレンス

言語リファレンス
	概要
	概念
		Visual Basic
			概要
		Microsoft Forms の概念に関するトピック
	使用方法に関するトピック
	Visual Basic の操作手順のトピック
	Visual Basic 言語リファレンス
		定数 (Visual Basic for Applications)
		データ型の概要
		イベント (Visual Basic for Applications)
		関数 (Visual Basic for Applications)
		タスク別のキーワード
		オブジェクト (Visual Basic for Applications)
		Statements

Excel Visual Basic for Applications (VBA) リファレンス | Microsoft Docs
https://docs.microsoft.com/ja-jp/office/vba/api/overview/excel

Visual Basic for Applications (VBA) の言語リファレンス | Microsoft Docs
https://docs.microsoft.com/ja-jp/office/vba/api/overview/language-reference

Visual Basic 言語リファレンス | Microsoft Docs
https://docs.microsoft.com/ja-jp/office/vba/language/reference/user-interface-help/visual-basic-language-reference

/////


== Visual Basic 言語リファレンス

Visual Basic 言語 (すべてのメソッド、プロパティ、ステートメント、関数、演算子、
およびオブジェクト) に関するドキュメントが用意されています。



* 文字セット
* 定数
* データ型
* ディレクティブ
* イベント
* 関数
* キーワード
* Microsoft Forms
* オブジェクト
* Operators
* ステートメント
* Visual Basic アドイン モデル

.関連項目

* メソッドとプロパティ (オブジェクトの下になりました)
* オブジェクト ブラウザー
* Visual Basic ユーザー インターフェイスのヘルプ
* Office 用オブジェクト ライブラリ リファレンス (メンバー、プロパティ、メソッド)
* Office クライアントの開発リファレンス

=== 文字セット

* 文字セット (0 から 127)
* 文字セット (128 から 255)

.関連項目

=== 定数 (Visual Basic for Applications)

==== カレンダー定数

    2018/12/11

次の定数は、コード内の任意の場所で実際の値の代わりに使用できます。

[cols="1,4",options="header"]
|===
|定数 |値 |説明
|vbCalGreg |.0 |グレゴリオ暦を使用することを示します。
|vbCalHijri |1-d |回教暦 (イスラム暦) カレンダーを使用することを示します。
|===

==== CallType 定数

次の定数は、コード内の任意の場所で実際の値の代わりに使用できます。

[cols="1,1,4",options="header"]
|===
|定数 |値 |説明
|vbMethod |1-d |メソッドが呼び出されることを指定します。
|vbGet |pbm-2 |Property Get プロシージャを示します。
|vbLet |2/4 |Property Let プロシージャを示します。
|vbSet |8 |Property Set プロシージャを示します。
|===


==== カラー定数

[cols="3,3,1",options="header"]
|===
|定数 |値 |説明
|vbBlack |0x0 |黒
|vbRed |0xFF |赤
|vbGreen |0xFF00 |緑
|vbYellow |0xFFFF |黄
|vbBlue |0xFF0000 |青
|vbMagenta |0xFF00FF |紫
|vbCyan |0xFFFF00 |シアン
|vbWhite |0xFFFFFF |白
|===

==== 比較定数

[cols="2,1,4",options="header"]
|===
|定数 |値 |説明
|vbUseCompareOption |-1 |Option Compare ステートメントの設定を使用して比較を実行します。
|vbBinaryCompare |.0 |バイナリ比較を実行します。
|vbTextCompare |1-d |テキスト比較を実行します。
|vbDatabaseCompare |pbm-2 |Microsoft Access (Windows のみ) で、データベースに格納されている情報に基づいて比較を実行します。
|===






==== Tristate 定数

この定数は、この定数の定義を含む適切なタイプ ライブラリがプロジェクトで明示的
に参照される場合にのみ使用できます。

[options="header"]
|===
|定数 |値 |説明
|vbTrue |-1 |True
|vbFalse |;0 |False
|vbUseDefault |-2 |既定の設定を使用
|===


=== https://docs.microsoft.com/ja-jp/office/vba/language/reference/user-interface-help/data-type-summary[データ型の概要 | Microsoft Docs][[データ型の概要]]

データ型は、保持できるデータの種類を決定する変数の特性です。 データ型には、次
の表で示されているもの、ユーザー定義型、およびオブジェクトに固有の型が含まれま
す。

組み込みのデータ型を設定する

次の表では、サポートされる データ型および記憶域のサイズと範囲を示します。
組み込みのデータ型を設定する

[options="header"]
|===
|データ型 |記憶領域サイズ |範囲
|Boolean |2 バイト |True または False
|Byte |1 バイト |0 ～ 255
|Collection |不明 |不明
|Currency (スケーリングされた整数) |8 バイト |-922,337,203,685,477.5808 ～ 922,337,203,685,477.5807
|Date |8 バイト |100 年 1 月 1 日 から 9999 年 12 月 31 日
|Decimal |14 バイト |+/-79,228,162,514,264,337,593,543,950,335 (小数点なし) +
+/-7.9228162514264337593543950335 (小数点以下 28 桁) +
 +
+/-0.0000000000000000000000000001 (0 ではない最小の値) +
|Dictionary |不明 |不明
|Double (倍精度浮動小数点数) |8 バイト |-1.79769313486231E308 から-4.94065645841247E-324 (負の値) +
 +
4.94065645841247E-324 から 1.79769313486232E308 (正の値)
|Integer |2 バイト |-32,768 〜 32,767
|Long (Long 整数) |4 バイト |-2,147, 483,648 〜 2,147, 483,647
|LongLong (LongLong 整数) |8 バイト |-9,223,372,036,854,775,808 から 9,223,372, 036,854,775,807 +
 +
[red]#64 ビット プラットフォームでのみ有効。#
|LongPtr (32 ビット システムでは Long 整数、64 ビット システムでは LongLong 整数) |32 ビット システムでは 4 バイト +
 +
64 ビット システムでは 8 バイト |-2,147,483,648 から 2,147,483,647 (32 ビットシステム) +
 +
-9,223,372,036,854,775,808 から 9,223,372,036,854,775,807 (64 ビット システム)
|Object |4 バイト |任意の Object 参照
|Single (単精度浮動小数点数) |4 バイト |-3.402823E38 から -1.401298E-45 (負の値) +
 +
1.401298E-45 から 3.402823E38 (正の値)
|String (可変長) |10 バイト + 文字列の長さ |0 〜 約 20 億
|文字列型 (String) (固定長) |文字列の長さ |1 〜 約 65,400
|Variant (数値) |16 バイト |最大で Double の範囲までの任意の数値
|バリアント型 (Variant) (文字) |22 バイト + 文字列長 (64 ビット システムでは 24 バイト) |可変長 文字列型 と同じ範囲
|ユーザー定義 (Type を使用) |要素に必要な数 |各要素の範囲は、そのデータ型の範囲と同じです。
|===




.データ型を変換する

式を特定のデータ型に強制変換する次の関数の使用方法の例については、「データ型変
換関数」をご覧ください。CBool、CByte、CCur、CDate、CDbl、CDec、CInt、CLng、
CLngLng、CLngPtr、CSng、CStr、CVar。

次の各関数については、それぞれのページをご覧ください。CVErr、Fix、Int。


WARNING: CLngLng は、64 ビット プラットフォームでのみ有効です。

.データ型を確認する

データ型を確認するには、以下の関数をご覧ください。

* IsArray
* IsDate
* IsEmpty
* IsError
* IsMissing
* IsNull
* IsNumeric
* IsObject

.CStr の戻り値


 expression の値
CStr の戻り値
 
:-----------------
:-----------
 
Boolean
True または False を含む文字列。
 
Date
システムの短い日付形式の日付を含む文字列。
 
Empty
長さ 0 の文字列 ("")。
 
Error
Error という単語とエラー番号を含む文字列。
 
Null
実行時エラー。
 
その他の数値
数字を含む文字列。



====  Type Conversion 関数[[Type Conversion]]

各関数では、式が特定のデータ型に強制的に変換されます。

.構文

* CBool(expression)
* CByte(expression)
* CCur(expression)
* CDate(expression)
* CDbl(expression)
* CDec(expression)
* CInt(expression)
* CLng(expression)
* CLngLng(expression) (64 ビットのプラットフォームでのみ有効)
* CLngPtr(expression)
* CSng(expression)
* CStr(expression)
* CVar(expression)

必須の expression 引数は、任意の文字列式または数値式です。

.戻り値の型

次に示すように、戻り値の型は関数名によって異なります。


[cols="1,1,4",options="header"]
|===
|Function |戻り値の種類 |expression 引数の範囲
|CBool |Boolean |任意の有効な文字列式または数式を指定します。
|CByte |Byte |0 から 255。
|CCur |Currency |-922,337,203,685,477.5808 ～ 922,337,203,685,477.5807。
|CDate |Date |任意の有効な日付式。
|CDbl |Double |負の値の場合は -1.79769313486231E308 ～ -4.94065645841247E-324、正の値の場合は 4.94065645841247E-324 ～ 1.79769313486232E308。
|CDec |Decimal |ゼロスケールの値 (小数部分がない値) の場合は 79,228,162,514,264,337,593,543,950,335 です。 小数点以下が 28 桁の値の場合は 7.9228162514264337593543950335 です。 0 以外で可能な最小値は 0.0000000000000000000000000001 です。
|CInt |Integer |-32,768 から 32,767。小数点以下は丸められます。
|CLng |Long |-2,147,483,648 から 2,147,483,647。小数点以下は丸められます。
|CLngLng |LongLong |-9,223,372,036,854,775,808 から 9,223,372,036,854,775,807。小数点以下は丸められます (64 ビット プラットフォームのみで有効)。
|CLngPtr |LongPtr |32 ビットのシステムでは -2,147,483,648 ～ 2,147,483,647、64 ビットのシステムでは -9,223,372,036,854,775,808 ～ 9,223,372,036,854,775,807。32 ビットと 64 ビットのどちらのシステムでも、小数部分は丸められます。
|CSng |Single |負の値の場合は -3.402823E38 ～ -1.401298E-45、正の値の場合は 1.401298E-45 ～ 3.402823E38。
|CStr |String |CStr の戻り値は、expression 引数に依存します。
|CVar |Variant |数値の場合は Double と同じ範囲です。 数値以外の場合は String と同じ範囲です。
|===

.解説

関数に渡した expression 引数の値が変換されるデータ型の範囲を超える場合はエラー
が発生します。

WARNING:	LongLong (64 ビットのプラットフォームの LongPtr を含む) をそれ
よりも小さい整数型に明示的に代入するには、変換関数を使用する必要があります。
LongLong をそれよりも小さい整数に暗黙的に変換することはできません。

一般に、データ型の変換関数を使用してコードを文書化し、一部の演算の結果が既定の
データ型ではなく、特定のデータ型として表示されるように指定できます。 たとえば、
通常、単精度、倍精度、整数演算が発生する場合、CCur を使用して、通貨換算を強制
的に実行します。

国際的に通用する 1 つのデータ型から別のデータ型に変換するには、Val ではなく、
データ型の変換関数を使用する必要があります。 たとえば、CCur を使用すると、使用
しているコンピューターのロケールに応じて、異なる少数点の区切り文字や桁区切り記
号、さまざまな通貨オプションが適切に認識されます。

小数点以下が 0.5 の場合、CInt および CLng は、常に一番近い偶数に数値を丸めます。
たとえば、0.5 は 0 に、1.5 は 2 に丸められます。 <<Fix Int,Fix関数とInt関数>>
は、小数部分を丸めるのではなく切り捨てるので、CInt およびCLngとは異なります。
また、Fix および Int は、常に渡されたのと同じ型の値を返します。

date を日付または時刻に変換できるかどうかを確認するには、IsDate 関数を使用しま
す。 CDate では、日付リテラルと時刻リテラルだけでなく、許容範囲内の日付に当て
はまる数字も認識されます。 数字を日付に変換すると、整数全体が日付に変換されま
す。 数字の分数の部分は、午前 12 時を起点にした時刻に変換されます。

CDate は、システムのロケール設定に基づいて日付の形式を認識します。 認識されて
いる日付設定以外の書式設定が提供されている場合、日、月、年の順番を正しく決定で
きないことがあります。 さらに、1 週間の文字列が含まれる場合、長い日付の書式設
定は認識されません。

Visual Basic の旧バージョンとの互換性のために、CVDate 関数も提供されています。
CVDate 関数の構文は CDate 関数と同じですが、CVDate では、実際の Date 型ではな
く、サブタイプが Date 型である Variant 型が返されます。 組み込みの Date 型が利
用できるようになったため、CVDate を使用する必要がなくなりました。 式を Date に
変換してから Variant に代入することで、同じ処理を行うことができます。 これは、
他のすべての組み込みタイプを同等のバリアント型サブタイプに変換する方法と同じで
す。

WARNING:	CDec 関数は独立したデータ型を返しません。値が 10 進型サブタイ
プに変換されたバリアント型を常に返します。



.CBool 関数の例

この例では、CBool 関数を使用して、式を Boolean に変換します。 式が 0 以外の値
に評価される場合は CBool から True が返され、それ以外の場合は False が返されま
す。


[source,vbscript]
----
Dim A, B, Check 
A = 5: B = 5 ' Initialize variables. 
Check = CBool(A = B) ' Check contains True. 
 
A = 0 ' Define variable. 
Check = CBool(A) ' Check contains False. 
----

.CByte 関数の例

この例では、CByte 関数を使用して、式を Byte に変換します。


[source,vbscript]
----
Dim MyDouble, MyByte 
MyDouble = 125.5678 ' MyDouble is a Double. 
MyByte = CByte(MyDouble) ' MyByte contains 126. 
----

.CCur 関数の例

この例では、CCur 関数を使用して、式を Currency に変換します。

[source,vbscript]
----
Dim MyDouble, MyCurr 
MyDouble = 543.214588 ' MyDouble is a Double. 
MyCurr = CCur(MyDouble * 2) ' Convert result of MyDouble * 2 
 ' (1086.429176) to a 
 ' Currency (1086.4292). 
----

.CDate 関数の例

この例では CDate 関数を使用し、文字列を日付型に変換します。 一般に、この例で示すように、文字列として日付と時刻をハードコードするのはお勧めしません。 文字列の代わりに、#2/12/1969# や #4:45:23 PM# のような日付リテラルと時刻リテラルを使用してください。


[source,vbscript]
----
Dim MyDate, MyShortDate, MyTime, MyShortTime 
MyDate = "February 12, 1969" ' Define date. 
MyShortDate = CDate(MyDate) ' Convert to Date data type. 
 
MyTime = "4:35:47 PM" ' Define time. 
MyShortTime = CDate(MyTime) ' Convert to Date data type. 
----

.CDbl 関数の例

この例では、CDbl 関数を使用して、式を Double に変換します。

[source,vbscript]
----
Dim MyCurr, MyDouble 
MyCurr = CCur(234.456784) ' MyCurr is a Currency. 
MyDouble = CDbl(MyCurr * 8.2 * 0.01) ' Convert result to a Double. 
----

.CDec 関数の例

この例では、CDec 関数を使用して、値を Decimal に変換します。


[source,vbscript]
----
Dim MyDecimal, MyCurr 
MyCurr = 10000000.0587 ' MyCurr is a Currency. 
MyDecimal = CDec(MyCurr) ' MyDecimal is a Decimal. 
----

.CInt 関数の例

この例では、CInt 関数を使用して、値を Integer に変換します。


[source,vbscript]
----
Dim MyDouble, MyInt 
MyDouble = 2345.5678 ' MyDouble is a Double. 
MyInt = CInt(MyDouble) ' MyInt contains 2346. 
----

.CLng 関数の例

この例では、CLng 関数を使用して、値を Long に変換します。

[source,vbscript]
----
Dim MyVal1, MyVal2, MyLong1, MyLong2 
MyVal1 = 25427.45: MyVal2 = 25427.55 ' MyVal1, MyVal2 are Doubles. 
MyLong1 = CLng(MyVal1) ' MyLong1 contains 25427. 
MyLong2 = CLng(MyVal2) ' MyLong2 contains 25428. 
----

.CSng 関数の例

この例では、CSng 関数を使用して、値を Single に変換します。

[source,vbscript]
----
Dim MyDouble1, MyDouble2, MySingle1, MySingle2 
' MyDouble1, MyDouble2 are Doubles. 
MyDouble1 = 75.3421115: MyDouble2 = 75.3421555 
MySingle1 = CSng(MyDouble1) ' MySingle1 contains 75.34211. 
MySingle2 = CSng(MyDouble2) ' MySingle2 contains 75.34216. 
----

.CStr 関数の例

この例では、CStr 関数を使用して、数値を String に変換します。


[source,vbscript]
----
Dim MyDouble, MyString 
MyDouble = 437.324 ' MyDouble is a Double. 
MyString = CStr(MyDouble) ' MyString contains "437.324". 
----


.CVar 関数の例

この例では、CVar 関数を使用して、式を Variant に変換します。


[source,vbscript]
----
Dim MyInt, MyVar 
MyInt = 4534 ' MyInt is an Integer. 
MyVar = CVar(MyInt & 000) ' MyVar contains the string 
 ' 4534000. 
----

































































































=== ディレクティブ

[cols="3,4",options="header"]
|===
|コンパイラ ディレクティブ |操作
|<<Const ディレクティブ,Const ディレクティブ>> |コンパイラ定数を定義します。
|<<If...Then...Else ディレクティブ,If...Then...Else ディレクティブ>> |選択したコード ブロックをコンパイルします。
|===

==== #Const ディレクティブ

Visual Basic の 条件付きコンパイラ定数を定義するために使用されます。

.構文

[source,vbscript]
----
#Const constname = expression
----

#Const コンパイラ ディレクティブの構文には、次の指定項目があります。

[cols="1,4",options="header"]
|===
|パーツ |説明
|constname |必須。Variant (String)。 定数の名前です。変数の名前付け規則に従います。
|expression |必須。 リテラル、その他の条件付きコンパイラ定数、またはを除くすべての算術演算子または論理演算子を含む組み合わせ。
|===

.注釈

条件付きコンパイラ定数は常に、定義されているモジュールの Private 定数になりま
す。 #Constディレクティブを使用して、パブリックコンパイラ定数を作成することは
できません。 Public コンパイラ定数は、ユーザー インターフェイスでのみ作成でき
ます。

expression で使用できるのは、条件付きコンパイラ定数とリテラルだけです。 Const
を使用して定義された標準の定数を使用したり、未定義の定数を使用したりすると、エ
ラーが発生します。 反対に、 #Const キーワードを使用して定義された定数は、条件
付きコンパイルにのみ使用できます。

条件付きコンパイラ定数は、コード内の位置に関わらず、常にモジュール レベルで評
価されます。

.例

この例では、#Const ディレクティブを使用して、#If...#Else...#End If コンストラ
クトで使用するための条件付きコンパイラ定数を宣言します。


[source,vbscript]
----
#Const DebugVersion = 1 ' Will evaluate true in #If block.
----

==== #If...Then...#Else ディレクティブ


選択した Visual Basic コードのブロックを条件付きでコンパイルします。

.構文

[source,vbscript]
----
#If expression Then
statements
[ #ElseIf expression-n Then
[ elseifstatements ]]
[ #Else
[ elsestatements ]]
#End If
----

#If...Then...#Else ディレクティブの構文には、次の指定項目があります。

.構文

[cols="1,4",options="header"]
|===
|パーツ |説明
|expression |必ず指定します。 1 つ以上の条件付きコンパイラ定数、リテラル、および演算子のみで構成された、True または False に評価される任意の式です。
|statements |必須。 関連付けられている式が True の場合に評価される Visual Basic プログラムの行またはコンパイラ ディレクティブです。
|expression-n |省略可能。 1 つ以上の条件付きコンパイラ定数、リテラル、および演算子のみで構成された、True または False に評価される任意の式です。
|elseifstatements |省略可能。 expression-n が True の場合に評価される 1 つ以上のプログラム行またはコンパイラ ディレクティブです。
|elsestatements |省略可能です。 前の expression および expression-n がいずれも True に評価されなかった場合に評価される 1 つ以上のプログラム行またはコンパイラ ディレクティブです。
|===

.解説

#If...Then...#Else ディレクティブの動作は If...Then...Else ステートメントと同
じです。ただし、#If、#Else、#ElseIf、および #End If の各ディレクティブには単一
行の形式がありません。したがって、これらのディレクティブと同じ行に他のコードを
含めることはできません。

条件付きコンパイルは、通常、同じプログラムを異なるプラットフォーム用にコンパイ
ルするために使用されます。 また、実行可能なファイルにデバッグ コードが含まれな
いようにするためにも使用されます。 条件付きコンパイルで除外されたコードは、最
終的な実行可能ファイルから完全に削除されるため、サイズやパフォーマンスに影響を
与えることはありません。

各評価の結果に関係なく、すべての式が評価されます。 したがって、式で使用されて
いるすべての定数が定義されている必要があります。定義されていない定数は Empty
として評価されます。

CAUTION:	Option Compare ステートメントは、#If ステートメントと #ElseIf
ステートメントの式には影響を与えません。 条件付きコンパイラ ディレクティブの式
は常に Option Compare Text で評価されます。


.例

この例では、#If...Then...#Else コンストラクトで条件付きコンパイラ定数を参照し
て、特定のステートメントをコンパイルするかどうかを決定します。

[source,vbscript]
----
' If Mac evaluates as true, do the statements following the #If. 
#If Mac Then 
 '. Place exclusively Mac statements here. 
 '. 
 '. 
' Otherwise, if it is a 32-bit Windows program, do this: 
#ElseIf Win32 Then 
 '. Place exclusively 32-bit Windows statements here. 
 '. 
 '. 
' Otherwise, if it is neither, do this: 
#Else 
 '. Place other platform statements here. 
 '. 
 '. 
#End If
----

=== イベント (Visual Basic for Applications)

* <<Activate、Deactivate, Activate、Deactivate>>
* <<Initialize, Initialize>>
* <<QueryClose, QueryClose>>
* <<Resize, Resize>>
* <<Terminate, Terminate>>

==== Activate イベント、Deactivate イベント[[Activate、Deactivate]]

Activate イベントは、オブジェクトがアクティブ ウィンドウになると発生します。
Deactivate イベントは、オブジェクトがアクティブ ウィンドウでなくなると発生しま
す。

.構文


[source,vbscript]
----
Private Sub object_Activate( )
Private Sub object_Deactivate( )
----

object のプレースホルダーは、評価結果が [適用先] リストのオブジェクトとなるオ
ブジェクトの式を表します。

.解説

コードで Show メソッドを使用すると、オブジェクトをアクティブにできます。

Activate イベントは、オブジェクトが表示されている場合のみ発生します。 <<Load,
Load>> で
読み込まれた <<UserForm,UserForm>> は、<<Show,Show>> メソッドを使用しない限り
表示されません。

Activate イベントと Deactivate イベントは、アプリケーション内でフォーカスが移
動された場合のみ発生します。 別のアプリケーションで、オブジェクトからまたはオ
ブジェクトにフォーカスが移動されても、いずれのイベントもトリガーされません。

Deactivate イベントは、オブジェクトの読み込み解除では発生しません。



.例

次のコードでは、UserForm1 と UserForm2 の 2 つの UserForm を使用しています。
これらのプロシージャを UserForm1 モジュールにコピーしてから、UserForm2 を追加
します。 UserForm1 のキャプションが、その Activate イベント プロシージャに作成
されます。 ユーザーが UserForm1 のクライアント領域をクリックすると、UserForm2
が読み込まれて表示され、UserForm1 の Deactive イベントがトリガーされ、キャプシ
ョンが変更されます。

[source,vbscript]
----
' Activate event for UserForm1
Private Sub UserForm_Activate()
    UserForm1.Caption = "Click my client area"
End Sub

' Click event for UserForm1
Private Sub UserForm_Click()
    Load UserForm2
    UserForm2.StartUpPosition = 3
    UserForm2.Show
End Sub

' Deactivate event for UserForm1
Private Sub UserForm_Deactivate()
    UserForm1.Caption = "I just lost the focus!"
    UserForm2.Caption = "Focus just left UserForm1 and came to me"
End Sub
----



==== Initialize イベント[[Initialize]]

オブジェクトが読み込まれてから表示されるまでに発生します。

.構文

[source,vbscript]
----
Private Subobject_Initialize( )
----

object プレースホルダーは、[適用対象] リスト内のオブジェクトに評価されるオブジ
ェクト式を表します。


.解説

通常、Initialize イベントは、アプリケーションまたは UserForm を使用できるよう
に準備するために使用されます。変数には初期値が割り当てられ、コントロールは、初
期化データを収容できるように移動またはサイズ変更される場合があります。

.例

次の例は、プログラム内に 2 つの UserForm があると仮定しています。 UserForm1 の
Initialize イベントで、UserForm2 が読み込まれて表示されます。 ユーザーが
UserForm2 をクリックすると、UserForm2 は非表示となり、UserForm1 が表示されます。
UserForm1 がクリックされると、UserForm2 が再度表示されます。

[source,vbscript]
----
' This is the Initialize event procedure for UserForm1
Private Sub UserForm_Initialize()
    Load UserForm2
    UserForm2.Show
End Sub
' This is the Click event of UserForm2
Private Sub UserForm_Click()
    UserForm2.Hide
End Sub

' This is the click event for UserForm1
Private Sub UserForm_Click()
    UserForm2.Show
End Sub
----




==== QueryClose イベント[[QueryClose]]

UserForm が閉じる前に発生します。

.構文

[source,vbscript]
----
Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
----

QueryClose イベントの構文には、次の指定項目があります。


[cols="1,4",options="header"]
|===
|パーツ |説明
|Cancel |整数。 この引数を 0 以外の値に設定すると、読み込み済みのすべてのユーザー フォームで QueryClose イベントが停止され、UserForm とアプリケーションを閉じられなくなります。
|CloseMode |QueryClose イベントの原因を示す値または定数です。
|===


.戻り値

CloseMode 引数は、次の値を返します。

[cols="1,1,4",options="header"]
|===
|定数 |値 |説明
|vbFormControlMenu |.0 |ユーザーが、UserForm のコントロールメニューで [閉じる] コマンドを選択しました。
|vbFormCode |1-d |コードから Unload ステートメントが呼び出されます。
|vbAppWindows |pbm-2 |現在の Windows オペレーティング環境セッションが終了しようとしています。
|vbAppTaskManager |1/3 |Windows タスク マネージャーがアプリケーションを閉じようとしています。
|===

これらの定数は、オブジェクト ブラウザーの [Visual Basic for Applications] オブ
ジェクト ライブラリに一覧表示されます。 vbFormMDIForm もオブジェクト ブラウザ
ーで指定されますが、まだサポートされていません。

.解説

このイベントは通常、アプリケーションが閉じる前に、完了していないタスクがアプリ
ケーションのユーザー フォームに含まれていないかどうかを確認するために使用され
ます。 たとえば、ユーザーが UserForm 内の新しいデータを保存していない場合、デ
ータの保存を求めるプロンプトをアプリケーションで表示できます。

アプリケーションが閉じるときに、QueryClose イベント プロシージャを使用して
Cancel プロパティを True に設定することで、閉じるプロセスを停止できます。

.例

次のコードでは、UserFormクライアント領域をクリックして閉じるようにユーザーに強
制します。 ユーザーがタイトル バーの [閉じる] ボックスを使用しようとすると、
Cancel パラメーターが 0 以外の値に設定され、終了できなくなります。 一方、ユー
ザーがクライアント領域をクリックした場合は、CloseMode の値が 1 となり、Unload
Me が実行されます。

[source,vbscript]
----
Private Sub UserForm_Activate()
    Me.Caption = "You must Click me to kill me!"
End Sub

Private Sub UserForm_Click()
  Unload Me
End Sub

Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
    'Prevent user from closing with the Close box in the title bar.
    If CloseMode <> 1 Then Cancel = 1
    Me.Caption = "The Close box won't work! Click me!"
End Sub
----


==== Resize イベント[[Resize]]


ユーザー フォームのサイズが変更されると発生します。

.構文

[source,vbscript]
----
Private Sub UserForm_Resize( )
----

.解説

Resize イベント プロシージャを使用すると、親 UserForm のサイズが変更されたとき
に コントロールを移動したりそのサイズを変更したりすることができます。 このイベ
ント プロシージャを使用して、変数やプロパティを再計算することもできます。


.例

次の例では、Activate イベントと Click イベントを使用して、UserForm の Resize
イベントをトリガーする方法を示しています。 ユーザーがフォームのクライアント領
域をクリックすると、フォームが拡大または縮小してタイトル バーに新しい高さが示
されます。 Tag プロパティを使用して UserForm の最初の高さを格納しています。

[source,vbscript]
----
' Activate event for UserForm1
Private Sub UserForm_Activate()
    UserForm1.Caption = "Click me to make me taller!"
    Tag = Height    ' Save the initial height.
End Sub

' Click event for UserForm1
Private Sub UserForm_Click()
    Dim NewHeight As Single
    NewHeight = Height
    ' If the form is small, make it tall.
    If NewHeight = Val(Tag) Then
        Height = Val(Tag) * 2
    Else
    ' If the form is tall, make it small.
        Height = Val(Tag)
    End If
End Sub

' Resize event for UserForm1
Private Sub UserForm_Resize()
    UserForm1.Caption = "New Height: " & Height & "  " & "Click to resize me!"
End Sub
----


==== Terminate イベント[[Terminate]]

オブジェクトを参照するすべての変数が Nothing に設定され、オブジェクトのインス
タンスへの参照がメモリからすべて削除されるか、オブジェクトへの最後の参照がスコ
ープ外になったときに発生します。

.構文

[source,vbscript]
----
Private Sub object_Terminate( )
----

object のプレースホルダーは、評価結果が [適用先] リストのオブジェクトとなるオ
ブジェクトの式を表します。

.解説

Terminate イベントは、オブジェクトの読み込み解除後に発生します。 メモリから
UserForm またはクラスのインスタンスが削除された場合、アプリケーションは異常終
了しているため、**Terminate ** イベントはトリガーされません。

たとえば、クラスまたは UserForm の既存のすべてのインスタンスをメモリから削除す
る前にアプリケーションが End ステートメントを起動した場合、Terminate イベント
はそのクラスまたは UserForm に対してトリガーされません。


.例

ユーザーがフォームを閉じるためにクライアント領域をクリックすると、次のイベント
プロシージャにより UserForm で警告音が数秒間鳴ります。

[source,vbscript]
----
Private Sub UserForm_Activate()
    UserForm1.Caption = "Click me to kill me!"
End Sub

Private Sub UserForm_Click()
  Unload Me
End Sub

Private Sub UserForm_Terminate()
    Dim Count As Integer
    For Count = 1 To 100
        Beep
    Next
End Sub
----


=== 関数 (Visual Basic for Applications)


.変換関数

* <<Asc,Asc>>
* <<Chr,Chr>>
* <<CVErr,CVErr>>
* <<Format,Format>>
* 16 進数
* <<Oct,Oct>>
* <<Str,Str>>
* <<Val,Val>>

.数学関数

* <<Abs,Abs>>
* <<Atn,Atn>>
* <<Cos,Cos>>
* <<Derived Math,Derived Math>>
* <<Exp,Exp>>
* <<Int,Int>>、<<Fix,Fix>>
* <<Log,Log>>
* <<Rnd,Rnd>>
* <<Sgn,Sgn>>
* <<Sin,Sin>>
* <<Sqr,Sqr>>
* <<Tan,Tan>>

.データ型変換関数

* データ型変換関数

.その他の関数

* <<Array,Array>>
* <<CallByName,CallByName>>
* <<Choose,Choose>>
* <<Command, Command>>
* <<CreateObject,CreateObject>>
* <<CurDir,CurDir>>
* <<Date,Date>>
* <<DateAdd,DateAdd>>
* <<DateDiff,DateDiff>>
* <<DatePart,DatePart>>
* <<DateSerial,DateSerial>>
* <<DateValue,DateValue>>
* <<Day,Day>>
* <<DDB,DDB>>
* <<Dir,Dir>>
* <<DoEvents,DoEvents>>
* <<Environ,Environ>>
* <<EOF,EOF>>
* <<Error,Error>>
* <<FileAttr,FileAttr>>
* <<FileDateTime,FileDateTime>>
* <<FileLen,FileLen>>
* <<Filter,Filter>>
* <<FormatCurrency,FormatCurrency>>
* <<FormatDateTime,FormatDateTime>>
* <<FormatNumber,FormatNumber>>
* <<FormatPercent,FormatPercent>>
* <<FreeFile,FreeFile>>
* <<FV,FV>>
* <<GetAllSettings,GetAllSettings>>
* <<GetAttr,GetAttr>>
* <<GetObject,GetObject>>
* <<GetSetting,GetSetting>>
* <<Hour,Hour>>
* <<IIf,IIf>>
* <<IMEStatus,IMEStatus>>
* <<Input,Input>>
* <<InputBox,InputBox>>
* <<InStr,InStr>>
* <<InStrRev,InStrRev>>
* <<IPmt,IPmt>>
* <<IRR,IRR>>
* <<IsArray,IsArray>>
* <<IsDate,IsDate>>
* <<IsEmpty,IsEmpty>>
* <<IsError,IsError>>
* <<IsMissing,IsMissing>>
* <<IsNull,IsNull>>
* <<IsNumeric,IsNumeric>>
* <<IsObject,IsObject>>
* <<Join,Join>>
* <<LBound,LBound>>
* <<LCase,LCase>>
* <<Left,Left>>
* <<Len,Len>>
* <<Loc,Loc>>
* <<LOF,LOF>>
* <<LTrim,LTrim>>、<<RTrim,RTrim>>、および <<Trim,Trim>>
* <<MacID,MacID>>
* <<MacScript,MacScript>>
* <<Mid,Mid>>
* <<Minute,Minute>>
* <<MIRR,MIRR>>
* <<Month,Month>>
* <<MonthName,MonthName>>
* <<MsgBox,MsgBox>>
* <<Now,Now>>
* <<NPer,NPer>>
* <<NPV,NPV>>
* <<Partition,Partition>>
* <<Pmt,Pmt>>
* <<PPmt,PPmt>>
* <<PV,PV>>
* <<QBColor,QBColor>>
* <<Rate,Rate>>
* <<Replace,Replace>>
* <<RGB,RGB>>
* <<Right,Right>>
* <<Round,Round>>
* <<Second,Second>>
* <<Seek,Seek>>
* <<Shell,Shell>>
* <<SLN,SLN>>
* <<Space,Space>>
* <<Spc,Spc>>
* <<Split,Split>>
* <<StrComp,StrComp>>
* <<StrConv,StrConv>>
* <<String,String>>
* <<StrReverse,StrReverse>>
* <<Switch,Switch>>
* <<SYD,SYD>>
* <<Tab,Tab>>
* <<Time,Time>>
* <<Timer,Timer>>
* <<TimeSerial,TimeSerial>>
* <<TimeValue,TimeValue>>
* <<TypeName,TypeName>>
* <<UBound,UBound>>
* <<UCase,UCase>>
* <<VarType,VarType>>
* <<Weekday,Weekday>>
* <<WeekdayName,WeekdayName>>
* <<Year,Year>>

==== Array 関数[[Array]]

.構文

[source,vbscript]
----
Array(arglist)
----

必須の arglist 引数は、Variant に含まれている配列の要素に割り当てられる値のコ
ンマ区切りのリストです。 引数を指定しない場合は長さ 0 の配列が作成されます。

.解説

配列の要素を参照するために使用される表記は、変数 名とそれに続く括弧で構成され、
括弧の中には目的の要素を示すインデックス番号が入ります。

次の例では、最初のステートメントにより、Variant として「A」という名前の変数が
作成されます。 2 つ目のステートメントにより、変数 A に配列が割り当てられます。
最後のステートメントにより、2 つ目の配列要素に含まれる値が別の変数に割り当てら
れます。


[source,vbscript]
----
Dim A As Variant, B As Long, i As Long
A = Array(10, 20, 30)  ' A is a three element list by default indexed 0 to 2
B = A(2)               ' B is now 30
ReDim Preserve A(4)    ' Extend A's length to five elements
A(4) = 40              ' Set the fifth element's value
For i = LBound(A) To UBound(A)
    Debug.Print "A(" & i & ") = " & A(i)
Next i
----

Array 関数を使用して作成した配列の下限は、Array がタイプ ライブラリの名前で修
飾 (VBA.Array など) されていない限り、Option Base ステートメントで指定した下限
によって決まります。 タイプ ライブラリの名前で修飾されている場合は、Array は
Option Base の影響を受けません。


CAUTION:	配列として宣言されていない Variant には、配列を含めることがで
きます。 Variant 変数には、固定長の文字列とユーザー定義の型を除き、あらゆる型
の配列を含めることができます。 配列が含まれている Variant は要素の型が Variant
の配列とは概念的に異なりますが、配列要素には同じ方法でアクセスされます。


.例

この例では、 Array 関数を使用して、配列を含む Variant を返します。


[source,vbscript]
----
Dim MyWeek, MyDay
MyWeek = Array("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
' Return values assume lower bound set to 1 (using Option Base
' statement).
MyDay = MyWeek(2)    ' MyDay contains "Tue".
MyDay = MyWeek(4)    ' MyDay contains "Thu".
----


==== CallByName 関数[[CallByName]]

オブジェクトのメソッドを実行するか、オブジェクトのプロパティを設定するか返しま
す。

.構文

[source,vbscript]
----
CallByName (object, procname, calltype, [args()]))
----

CallByName関数の構文に使用される名前付き引数は次のとおりです。


[cols="1,4",options="header"]
|===
|パーツ |説明
|object |必須。Variant (Object)。 関数を実行するオブジェクトの名前。
|procname |必須。Variant (String)。 オブジェクトのプロパティまたはメソッドの名前を含む文字列式。
|calltype |必須。定数。 呼び出されるプロシージャの型を表す vbCallType 型の定数。
|args() |省略可能。Variant (Array)。
|===


.解説

CallByName 関数は、実行時に文字列名を使用してプロパティを取得または設定するか、
メソッドを呼び出すために使用されます。

次の例では、1 行目で CallByName を使用してテキスト ボックスの MousePointer プ
ロパティを設定し、2 行目で MousePointer プロパティの値を取得し、3 行目で Move
メソッドを呼び出してテキスト ボックスを移動します。


[source,vbscript]
----
CallByName Text1, "MousePointer", vbLet, vbCrosshair
Result = CallByName (Text1, "MousePointer", vbGet)
CallByName Text1, "Move", vbMethod, 100, 100
----

.例

この例では、CallByName 関数を使用して、コマンド ボタンの Move メソッドを呼び出
します。

例ではまた、ボタン (Command1) とラベル (Label1) を含むフォーム (Form1) を使用
します。 フォームが読み込まれると、ラベルの Caption プロパティが、呼び出すメソ
ッドの名前に設定されます (この例では "Move")。 ボタンをクリックすると、
CallByName 関数によって、ボタンの位置を変更するメソッドが呼び出されます。


[source,vbscript]
----
Option Explicit

Private Sub Form_Load()
    Label1.Caption = "Move"        ' Name of Move method.
End Sub

Private Sub Command1_Click()
    If Command1.Left <> 0 Then
        CallByName Command1, Label1.Caption, vbMethod, 0, 0
    Else
        CallByName Command1, Label1.Caption, vbMethod, 500, 500
    End If

----


==== Choose 関数[[Choose]]

引数の一覧から値を選択し、返します。

.構文

[source,vbscript]
----
Choose(index, choice-1, [ choice-2, ..., [ choice-n ]] )
----

Choose 関数の構文には、次の指定項目があります。


[cols="1,4",options="header"]
|===
|パーツ |説明
|index |必ず指定します。 1 から選択肢の数までの値になる 数式またはフィールドです。
|choice |必須です。 可能性のある選択肢のいずれか 1 つが含まれる バリアント型の式 です。
|===


.解説

Choose は、index の値に基づいて選択肢の一覧から値を返します。 index が 1 の場
合、Choose は一覧の 1 つ目の選択肢を返します。index が 2 の場合は 2 つ目という
ようになります。

Choose を使って、可能性の一覧に含まれる値を検索することができます。 たとえば、
index が 3 で、choice-1 = "1"、choice-2 = "2"、choice-3 = "3" と評価した場合、
Choose は "3" を返します。 この機能は、index がオプション グループの値を示す場
合に特に便利です。

Choose は、一覧の選択肢すべてを評価しますが、その 1 つだけが返されます。 その
ため、望ましくない副作用が生じないように注意する必要があります。 すべての選択
肢において、式 の一部として MsgBox 関数を使用する場合、メッセージ ボックスは評
価される各選択肢に対して表示されますが、Choose はそのうちの 1 つだけを返します。

もし index が 1 以下または一覧にある選択肢の数を超える場合、Choose 関数は Null
を返します。

index が整数ではない場合、最も近い整数に丸めてから評価されます。

.例

この例では、Choose 関数を使って、Ind パラメーターのプロシージャに渡される
index に応じた名前を表示します。

[source,vbscript]
----
Function GetChoice(Ind As Integer)
    GetChoice = Choose(Ind, "Speedy", "United", "Federal")
End Function
----

==== Command[[Command]]

Microsoft Visual Basic または Visual Basic で開発された実行可能なプログラムの
起動に使用されるコマンド ラインの引数部分を返します。 Visual Basic の関数機能
は、Microsoft Office のアプリケーションでは使用できません。

.構文

[source,vbscript]
----
Command
----

.解説

コマンドラインから Visual Basic が起動された場合、/cmd に続くすべてのコマンド
ライン部分がコマンドライン引数として、プログラムに渡されます。 次のコマンドラ
インの例で、cmdlineargs は、コマンド関数によって返される引数情報を表しています。

VB /cmd cmdlineargs

Visual Basic で開発され、.exe ファイルにコンパイルされたアプリケーションでは、
Command によって、コマンド ラインのアプリケーション名の後に表示されるすべての
引数が返されます。 次に例を示します。

MyApp cmdlineargs

使用しているアプリケーションのユーザー インターフェイスでのコマンド ライン引数
の変更方法の詳細については、ヘルプの「コマンド ライン引数」を参照してください。



.例

この例では、配列を含む Variant でコマンド ライン引数を返す関数内で、Command 関
数を使用してコマンド ライン引数を取得しています。 Microsoft Office では使用で
きません。


[source,vbscript]
----
Function GetCommandLine(Optional MaxArgs)
    'Declare variables.
    Dim C, CmdLine, CmdLnLen, InArg, I, NumArgs
    'See if MaxArgs was provided.
    If IsMissing(MaxArgs) Then MaxArgs = 10
    'Make array of the correct size.
    ReDim ArgArray(MaxArgs)
    NumArgs = 0: InArg = False
    'Get command line arguments.
    CmdLine = Command()
    CmdLnLen = Len(CmdLine)
    'Go thru command line one character
    'at a time.
    For I = 1 To CmdLnLen
        C = Mid(CmdLine, I, 1)
        'Test for space or tab.
        If (C <> " " And C <> vbTab) Then
            'Neither space nor tab.
            'Test if already in argument.
            If Not InArg Then
            'New argument begins.
            'Test for too many arguments.
                If NumArgs = MaxArgs Then Exit For
                NumArgs = NumArgs + 1
                InArg = True
            End If
            'Concatenate character to current argument.
            ArgArray(NumArgs) = ArgArray(NumArgs) & C
        Else
            'Found a space or tab.
            'Set InArg flag to False.
            InArg = False
        End If
    Next I
    'Resize array just enough to hold arguments.
    ReDim Preserve ArgArray(NumArgs)
    'Return Array in Function name.
    GetCommandLine = ArgArray()
End Function
----

==== 変換関数

===== 変換関数

* <<Asc,Asc 関数>>
* <<Chr,Chr 関数>>
* <<CVErr,CVErr 関数>>
* <<Format,Format 関数>>
* <<Hex,Hex 関数>>
* <<Oct,Oct 関数>>
* <<Str,Str 関数>>
* <<Val,Val 関数>>

.Type Conversion 関数

式を特定のデータ型に変換する関数については、<<Type Conversion,Type Conversion
関数>>ページを参照してください。

* CBool 関数
* CByte 関数
* CCur 関数
* CDate 関数
* CDec 関数
* CDbl 関数
* CInt 関数
* CLng 関数
* CLngLng 関数
* CLngPtr 関数
* CSng 関数
* CStr 関数
* CVar 関数






===== Asc 関数[[Asc]]

文字列の最初の文字に対応した文字コードを示す整数を返します。

.構文

[source,vbscript]
----
Asc(string)
----

必須の string 引数は、任意の有効な文字列式です。 string に文字が含まれていない
場合、実行時エラーが発生します。

.解説

戻り値の範囲は、非 DBCS システムでは 0–255 ですが、DBCS システムでは -32768–
32767 です。


CAUTION:	AscB 関数は、文字列に含まれるバイト データの場合に使用します。 先頭の文字の文
字コードを返す代わりに、AscB は最初のバイトを返します。 AscW 関数は、Unicode
文字コードを返します。ただし、Unicode がサポートされていないプラットフォームで
は、Asc 関数と同じ動作になります。

CAUTION:	Visual Basic for the Macintosh では、Unicode 文字列をサポート
していません。 このため、Windows 環境とは異なり、AscW (n) は 128 – 65,535 の
範囲の n の値に対するすべての Unicode 文字を返すことができません。 代わりに、
AscW (n) は、127 より大きい Unicode 値 n について "最適なものを推測" します。
したがって、Macintosh 環境では、AscW を使用してはいけません。。


関数<<Chr,Chr ()、ChrB ()、および ChrW ()>> は、 Asc ()、ascb ()、ascb () の逆
です。Chr () 関数は、整数を文字列に変換します。

.例

この例では、Asc 関数を使って、文字列の先頭の文字に対応する文字コードを返します。

[source,vbscript]
----
Dim MyNumber
MyNumber = Asc("A")    ' Returns 65.
MyNumber = Asc("a")    ' Returns 97.
MyNumber = Asc("Apple")    ' Returns 65.
----


===== Chr 関数[[Chr]]

指定した文字コードと関連付けられている文字を含む String を返します。

.構文

[source,vbscript]
----
Chr(charcode)
ChrB(charcode)
ChrW(charcode)
----

必須の charcode 引数は、文字を識別する Long です。

.解説

0 から 31 の数値は、標準の印刷できない ASCII コードと同じです。 たとえば、
  Chr(10) は改行文字を返します。 charcode の通常の範囲は 0 から 255 です。 た
だし、DBCS システムでは、charcode の実際の範囲は -32768 から 65535 です。

CAUTION:	ChrB関数は、String に含まれるバイト データの場合に使用します。
ChrBは、1 バイトまたは 2 バイトの文字ではなく、常に 1 バイトを返します。
ChrW 関数は、Unicode 文字を含む String を返します。ただし、Unicode がサポート
されていないプラットフォームでは、Chr 関数と同じ動作になります。

CAUTION:	Visual Basic for the Macintosh では、Unicode 文字列をサポート
していません。 このため、Windows 環境とは異なり、ChrW(n) は 128 から 65,535 の
範囲の n の値に対するすべての Unicode 文字を返すことができません。 代わりに、
ChrW(n) は、127 より大きい Unicode 値 n について "最適なものを推測" します。
したがって、Macintosh 環境では、ChrW を使用する必要はありません。

関数 <<Asc,Asc()、AscB()、および AscW()>> は Chr()、ChrB()、および ChrW() の反対です。
Asc() 関数は、文字列を整数に変換します。


.例

次の例では、Chr 関数を使用して、指定した文字コードと関連付けられている文字を返
します。


[source,vbscript]
----
Dim MyChar
MyChar = Chr(65)    ' Returns A.
MyChar = Chr(97)    ' Returns a.
MyChar = Chr(62)    ' Returns >.
MyChar = Chr(37)    ' Returns %.
----

===== CVErr 関数[[CVErr]]


ユーザーによって指定されたエラー番号を含むサブタイプ Error の Variant を返しま
す。

.構文


[source,vbscript]
----
CVErr(errornumber)
----

必須の errornumber 引数は、任意の有効なエラー番号です。

.解説

CVErr 関数は、ユーザーが作成するプロシージャでユーザー定義のエラーを作成するた
めに使用されます。 たとえば、複数の引数を受け取って普通に文字列を返す関数を作
成する場合は、関数で入力引数を評価し、受け付けられる範囲内の値であることを確認
できます。 そうでない場合、関数は期待する結果を返しません。 このような場合、
CVErr を使用することで、実行する処理の内容を通知するエラー番号を返すことができ
ます。

Error の暗黙的な変換はできないことに注意してください。 たとえば、CVErr の戻り
値を、Variant ではない変数に直接割り当てることはできません。 ただし、CVErr に
よって返される値の明示的な変換を実行し (CInt、CDbl などを使用)、それを適切なデ
ータ型の変数に割り当てることはできます。

.例

次の例では、CVErr 関数を使用して、VarType が vbError (10) である Variant を返
します。 ユーザー定義関数 CalculateDouble は、渡された引数が数値でない場合にエ
ラーを返します。 CVErr を使用して、ユーザー定義プロシージャからユーザー定義エ
ラーを返すことも、実行時エラーの処理を遅らせることもできます。 値がエラーを表
しているかどうかを調べるには、IsError 関数を使用します。


[source,vbscript]
----
' Call CalculateDouble with an error-producing argument.
Sub Test()
    Debug.Print CalculateDouble("345.45robert")
End Sub
' Define CalculateDouble Function procedure.
Function CalculateDouble(Number)
    If IsNumeric(Number) Then
        CalculateDouble = Number * 2    ' Return result.
    Else
        CalculateDouble = CVErr(2001)    ' Return a user-defined error 
    End If    ' number.
End Function
----

===== Format 関数[[Format]]

書式指定式の指示に従って書式設定される式を含む Variant (String) を戻します。


CAUTION:	複数のプラットフォーム間で Office エクスペリエンスを拡張するソ
リューションを開発することに関心がありますか? 新しい Office アドイン モデルを
参照してください。 Office アドインには、VSTO アドインおよびソリューションと比
較して、小さな設置面積があります。 HTML5、JavaScript、CSS3、XML など、ほぼすべ
ての web プログラミングテクノロジを使用して構築できます。

.構文

[source,vbscript]
----
Format(Expression, [Format], [FirstDayOfWeek], [FirstWeekOfYear])
----

Format 関数の構文には、次の指定項目があります。

[cols="1,4",options="header"]
|===
|指定項目 |説明
|Expression |必須。 必ず指定します。任意の有効な式。
|Format |省略可能。 有効な名前を持つ、またはユーザー定義の書式指定式。
|FirstDayOfWeek |省略可能。 週の最初の曜日を指定する定数です。
|FirstWeekOfYear |省略可能。 年内で、最初の週を指定する定数です。
|===

.設定

firstdayofweek 引数の設定は次のとおりです。


[cols="1,1,4",options="header"]
|===
|定数 |値 |説明
|vbUseSystem |0 |NLS API 設定を使用します。
|vbSunday |1 |日曜日 (既定)
|vbMonday |2 |月曜日
|vbTuesday |3 |火曜日
|vbWednesday |4 |水曜日
|vbThursday |5 |木曜日
|vbFriday |6 |金曜日
|vbSaturday |7 |土曜日
|===

firstweekofyear 引数の設定は次のとおりです。

[cols="1,1,4",options="header"]
|===
|定数 |値 |説明
|vbUseSystem |0 |NLS API 設定を使用します。
|vbFirstJan1 |1 |1 月 1 日が含まれる週から開始します (既定)。
|vbFirstFourDays |2 |4 日以上が含まれる最初の週が年の第 1 週目になります。
|vbFirstFullWeek |3 |1 週間全体が含まれる最初の週がその年の第 1 週目になります。
|===

.解説


[cols="1,4",options="header"]
|===
|書式設定の対象 |説明
|数値 |定義済みの名前付き数値書式を使用するか、ユーザー定義の数値書式を作成します。
|日付と時刻 |定義済みの名前付き日付/時刻書式を使用するか、ユーザー定義の日付/時刻書式を作成します。
|日付と時刻の連続番号 |日付および時間書式または数値書式を使用します。
|文字列 |自分のユーザー定義文字列書式を作成します。
|===

Format は、format を 257 文字に切り捨てます。

format を指定せずに数値を書式設定する場合、Format は Str 関数と同様の、ただし
国際対応がされた機能を提供します。 しかし、Format を使用して文字列として書式設
定された正の数値には、値の記号用に予約済みの先頭のスペースは含まれません。Str
を使用して変換された数値では、先頭のスペースは保持されます。

ローカライズされていない数値文字列を書式設定する場合、目的の書式を実現するには、
ユーザー定義数値書式を使用する必要があります。

CAUTION:	Calendar プロパティの設定が Gregorian で、format が日付書式を
指定する場合、指定する expression は Gregorian である必要があります。 Visual
Basic Calendar プロパティ設定が Hijri である場合、指定する expression は Hijri
である必要があります。


カレンダーがグレゴリオ暦である場合、format 式記号の意味は変わりません。 カレンダーがイスラム暦の場合、すべての日付書式記号 (たとえば、dddd、mmmm、yyyy) は同じ意味を持ちますが、イスラム暦に適用されます。 書式記号は英語のままです。テキスト表示 (たとえば、AM や PM) になる記号では、その記号に対応する文字列 (英語またはアラビア語) が表示されます。 カレンダーがイスラム暦の場合、特定の記号の範囲は変わります。

.日付記号

[cols="1,4",options="header"]
|===
|記号 |範囲
|d |1 〜 31 (前に 0 を付けない、月の日付)
|dd |01 〜 31 (前に 0 を付ける、月の日付)
|w |1 〜 7 (週の曜日。土曜日 = 1 から開始)
|ww |1 〜 53 (1 年のうちで何週目かを表す数値。前に 0 を付けず、1 月 1 日から開始。)
|m |1 〜 12 (月。前に 0 を付けず、1 月 = 1 から開始。)
|mm |01 〜 12 (月。前に 0 を付け、1 月 = 01 から開始。)
|mmm |月の省略名を表示 (イスラム暦の月の名前には省略形はありません)
|mmmm |完全な月名を表示
|y |1 〜 366 (1 年のうちで何日目かを表す数値)
|yy |00 〜 99 (西暦年の下 2 桁)
|yyyy |100 〜 9999 (3 桁または 4 桁の西暦年)
|===

.時間記号

[cols="1,4",options="header"]
|===
|記号 |範囲
|h |0 〜 23 (「AM」または「PM」を追加した 1 〜 12 の数値) (前に 0 を付けない、1 日の中の時間)
|hh |00 〜 23 (「AM」または「PM」を追加した 01 〜 12 の数値) (前に 0 を付ける、1 日の中の時間)
|n |0 〜 59 (前に 0 を付けない、1 時間の中の分)
|nn |00 〜 59 (前に 0 を付ける、1 時間の中の分)
|m |0 〜 59 (前に 0 を付けない、1 時間の中の分) h または hh が先行する場合のみ
|mm |00 〜 59 (前に 0 を付ける、1 時間の中の分) h または hh が先行する場合のみ
|s |0 〜 59 (前に 0 を付けない、1分の中の秒)
|ss |00 〜 59 (前に 0 を付ける、1分の中の秒)
|===

.使用例

この例では、名前付き書式とユーザー定義書式の両方を使用して値の書式設定を行う、
Format 関数のさまざまな使用例を示します。 日付の区切り記号 ( / )、時間の区切り
記号 (** :** )、リテラルの AM/PM、およびシステムで表示される実際の書式設定され
る出力は、コードが実行中のロケール設定に基づきます。 時間と日付が開発環境で表
示されるとき、コード ロケールでの短い時間形式と短い日付形式が使用されます。 コ
ードの実行により表示される場合は、システム ロケールの短い時間形式と短い日付形
式が使用されます。これはコード ロケールとは異なることがあります。 この例では、
English/U.S. を使用します。 MyTime と MyDate が、現在のシステムでの短い時間設
定と短い日付設定を使用して、開発環境で表示されます。

[source,vbscript]
----
Dim MyTime, MyDate, MyStr
MyTime = #17:04:23#
MyDate = #January 27, 1993#

' Returns current system time in the system-defined long time format.
MyStr = Format(Time, "Long Time")

' Returns current system date in the system-defined long date format.
MyStr = Format(Date, "Long Date")

MyStr = Format(MyTime, "h:m:s")    ' Returns "17:4:23".
MyStr = Format(MyTime, "hh:mm:ss am/pm")    ' Returns "05:04:23 pm".
MyStr = Format(MyTime, "hh:mm:ss AM/PM")    ' Returns "05:04:23 PM".
MyStr = Format(MyDate, "dddd, mmm d yyyy")    ' Returns "Wednesday, Jan 27 1993".
' If format is not supplied, a string is returned.
MyStr = Format(23)    ' Returns "23".

' User-defined formats.
MyStr = Format(5459.4, "##,##0.00")    ' Returns "5,459.40".
MyStr = Format(334.9, "###0.00")    ' Returns "334.90".
MyStr = Format(5, "0.00%")    ' Returns "500.00%".
MyStr = Format("HELLO", "<")    ' Returns "hello".
MyStr = Format("This is it", ">")    ' Returns "THIS IS IT".
----

.さまざまな数値のさまざまな書式

ユーザー定義の数値書式指定 式は、セミコロンで区切られた 1 から 4 のセクションを持つことができます。 書式引数に名前付き数値書式が含まれる場合は、1 つのセクションのみが許可されます。

[source,vbscript]
----
|使用するセクション数 |結果
|1 セクションのみ |書式指定式はすべての値に適用されます。
|2 セクション |最初のセクションは正の値と 0 に適用され、第 2 のセクションは負の値に適用されます。
|3 セクション |最初のセクションは正の値、第 2 のセクションは負の値、第 3 のセクションは 0 に適用されます。
|4 セクション |最初のセクションは正の値、第 2 のセクションは負の値、第 3 のセクションは 0、第 4 のセクションは Null 値に適用されます。
----


"$#,##0;($#,##0)"

間に何も入れずに複数のセミコロンを含めた場合、欠けているセクションは、正の値の
書式を使用して出力されます。 たとえば、以下の書式は、最初のセクションで書式を
使用して正と負の値を表示し、値が 0 の場合は、"Zero" を表示します。


[source,vbscript]
----
"$#,##0;;\Z\e\r\o"
----

さまざまな文字列値のさまざまな書式

文字列の書式指定式は、セミコロン (;) で区切られた 1 つまたは 2 つのセクション
を持つことができます。

[source,vbscript]
----
|使用するセクション数 |結果
|1 セクションのみ |書式はすべての文字列データに適用されます。
|2 セクション |最初のセクションは文字列データに適用され、第 2 のセクションは Null 値と長さ 0 の文字列 ("") に適用されます。
----

.名前付き日付/時刻書式

以下の表は、定義済みの日付および時間の書式名を示します。

[source,vbscript]
----
|書式名 |説明
|General Date |日付と時刻のどちらか、または両方を表示します (例: 4/3/93 05:34 PM)。 小数の部分がない場合、日付だけを表示します (例: 4/3/93)。 整数の部分がない場合、時間のみを表示します(例: 05:34 PM)。 日付表示はシステム設定に依存します。
|Long Date |システムの長い日付形式の書式に従って日付を表示します。
|Medium Date |ホスト アプリケーションの言語バージョンで適切な、中間の長さの日付書式を使用して日付を表示します。
|Short Date |システムの短い日付書式を使用して日付を表示します。
|Long Time |システムの長い時間形式を使用して時間を表示します。時間、分、秒が含まれます。
|Medium Time |時間と分を、12 時間の書式と AM/PM を使用して表示します。
|Short Time |24 時間の形式を使用して時間を表示します (例: 17: 45)。
----

.名前付き数値書式

以下の表は、定義済みの数値の書式名を示します。

[source,vbscript]
----
|書式名 |説明
|General Number |桁区切り記号を付けずに数を表示します。
|Currency |適切な場合は、桁区切り記号を付けて数を表示します。小数点記号の右 2 桁を表示します。 出力はシステム ロケール設定に基づきます。
|Fixed |少なくとも整数部 1 桁、小数部 2 桁を表示します。
|Standard |区切り記号を付けて、少なくとも整数部 1 桁、小数部 2 桁を表示します。
|Percent |数値を 100 倍して、右側にパーセント記号 (%) を付けて表示します。小数部は常に 2 桁です。
|Scientific |標準の指数表記を使用します。
|Yes/No |数値が 0 の場合は No を表示します。それ以外の場合は Yes を表示します。
|True/False |数値が 0 の場合は False を表示します。それ以外の場合は True を表示します。
|On/Off |数値が 0 の場合は Off を表示します。それ以外の場合は On を表示します。
----

.ユーザー定義文字列書式

以下の文字を使用して、文字列の書式指定式を作成できます。

[source,vbscript]
----
|文字 |説明
|@ |文字プレースホルダー。 文字またはスペースを表示します。 書式文字列でアット マーク (@ ) の表示位置に文字がある文字列の場合は、その文字が表示されます。それ以外の場合は、その位置にスペースが表示されます。 書式文字列に感嘆符 (** !** ) がある場合を除き、プレースホルダーは右側から左側に向かって埋められます。
|& |文字プレースホルダー。 文字が表示されるか、または何も表示されません。 アンパサンド (&) の表示位置に文字がある文字列の場合は、その文字が表示されます。それ以外の場合は、何も表示されません。 書式文字列に感嘆符 (** !** ) がある場合を除き、プレースホルダーは右側から左側に向かって埋められます。
|< |強制的に小文字にします。 すべての文字を小文字で表示します。
|> |強制的に大文字にします。 すべての文字を大文字で表示します。
|! |プレースホルダーを左から右に向かって埋めるように強制的に設定します。 既定では、プレースホルダーは右から左に向かって埋めように設定されています。
----

.ユーザー定義日付/時刻書式

以下の表は、ユーザー定義日付/時刻書式の作成に使用できる文字を示します。

[source,vbscript]
----
|文字 |説明
|(:) |時刻の区切り記号。 一部のロケールでは、時刻区切り文字を表す目的で他の文字が使用されることがあります。 時刻の値が書式設定されるときに、時刻区切り文字によって時、分、および秒が区切られます。 書式設定された出力で時刻区切り文字として使用される実際の文字は、システム設定によって決まります。
|(/) |日付の区切り記号。 一部のロケールでは、日付区切り文字を表す目的で他の文字が使用されることがあります。 日付値の書式が設定されている場合、日付、月、および年は、日付の区切り記号によって区切られます。 書式設定された出力で、日付の区切り文字として実際に使用される文字は、システム設定によって決まります。
|c |日付を ddddd、時刻を ttttt 形式で、日付、時刻の順序で表示します。 日付の連続数値に小数部がない場合は、日付情報だけを表示します。時刻に整数部がない場合は、時刻情報のみを表示します。
|d |日を先頭に 0 のない数値 (1 〜 31) で表示します。
|dd |日を先頭に 0 のある数値 (01 〜 31) で表示します。
|ddd |日を曜日の省略形 (日〜 土) で表示します。 ローカライズされています。
|dddd |日を曜日の完全な名前 (日曜日〜 土曜日) で表示します。 ローカライズされています。
|ddddd |日付を完全な日付 (日、月、および年を含む) で表示します。表示形式は各システムの短い日付形式の設定に従っています。 既定の短縮日付フォーマットは、m/d/yy です。
|dddddd |日付の連続数値を完全な日付 (日、月、および年を含む) で表示します。表示形式は各システムが認識する長い日付形式の設定に従っています。 既定の長い日付形式は、mmmm dd, yyyy です。
|w |曜日を数値 (日曜日が 1 で土曜日が 7) で表示します。
|ww |1 年のうちの何週目であるかを数値 (1 〜 54) で表示します。
|m |月を先頭に 0 のない数値 (1 〜 12) で表示します。 h または hh の直後に m が続く場合は、月ではなく分が表示されます。
|mm |月を先頭に 0 のある数値 (01 〜 12) で表示します。 h または hh の直後に m が続く場合は、月ではなく分が表示されます。
|mmm |月を月名の省略形 (1 月〜 12 月) で表示します。 ローカライズされています。
|mmmm |月を完全な月名 (1 月〜 12 月) で表示します。 ローカライズされています。
|q |1 年の四半期を数値 (1 〜 4) で表示します。
|y |1 年の何日目かを数値 (1 〜 366) で表示します。
|yy |西暦の年を下 2 桁の数値 (00 〜 99) で表示します。
|yyyy |西暦の年を 4 桁の数値 (100 〜 9999) で表示します。
|h |時を先頭に 0 のない数値 (0 〜 23) で表示します。
|Hh |時を先頭に 0 のある数値 (00 〜 23) で表示します。
|n |分を先頭に 0 のない数値 (0 〜 59) で表示します。
|nn |分を先頭に 0 のある数値 (00 〜 59) で表示します。
|s |秒を先頭に 0 のない数値 (0 〜 59) で表示します。
|ss |秒を先頭に 0 のある数値 (00 〜 59) で表示します。
|ttttt |時刻を完全な時刻 (時間、分、および秒を含む) で表示します。表示形式は、各システムが認識する時刻書式で定義された時刻区切り文字を使用します。 先頭に 0 を付ける形式が選択されていて、時刻が午前 10:00 または 午後 10:00 より前の場合は、時刻の前に 0 を表示します。 既定の時刻書式は、h:mm:ss です。
|AM/PM |12 時間形式を使用します。正午までの時間に大文字の AM を、正午から午後 11:59 時までの時間に大文字の PM を付けて表示します。
|am/pm |12 時間形式を使用します。正午までの時間に小文字の AM を、正午から午後 11:59 時までの時間に小文字の PM を付けて表示します。
|A/P |12 時間形式を使用します。正午までの時間に大文字の A を、正午から午後 11:59 時までの時間に大文字の P を付けて表示します。
|a/p |12 時間形式を使用します。正午までの時間に小文字の a を、正午から午後 11:59 時までの時間に小文字の p を付けて表示します。
|AMPM |12 時間形式を使用します。正午までの時間にはシステムで定義された AM 文字列リテラルを、正午から午後 11:59 時までの時間にはシステムで定義された PM 文字列リテラルを付けて表示します。 AMPM は大文字、小文字のどちらでもかまいません。ただし、表示される文字列の大文字、小文字の区別は、システムの設定で定義した文字列に一致します。 既定の形式は AM/PM です。 システムで 24 時間時計に設定されている場合は、文字列は通常、長さ 0 の文字列に設定されます。
----

.ユーザー定義数値書式

以下の表は、ユーザー定義数値書式の作成に使用できる文字を示します。

[source,vbscript]
----
|文字 |説明
|なし |書式指定なしで数値を表示します。
|(0) |桁のプレースホルダーです。 1 桁の数または 0 を表示します。 式で、書式指定文字列で 0 が指定されている場所に 1 桁の数字がある場合は、その数字が表示されます。それ以外の場合は、その場所に 0 を表示します。数値の整数部または小数部の桁数が、書式指定式内の 0 の桁数より少ない場合は、先行ゼロまたは後置ゼロを表示します。 数値の小数部の桁数が、書式指定式の小数部で指定されている 0 の数より多い場合は、0 の数と同じ桁数に数値が丸められます。 数値の整数部の桁数が、書式指定式の整数部の 0 の数より多い場合は、桁をそのまま表示します。
|(#) |桁のプレースホルダーです。 1 桁の数字または 0 を表示します。 式で、書式指定文字列で # が指定されている場所に該当する桁がある場合は、その数字が表示されます。それ以外の場合は、その場所には何も表示されません。 この記号は 0 桁プレースホルダーと同様の機能を持ちます。ただし、数値の桁数が、書式指定式の整数部および小数部にある # 記号よりも同じか少ない場合でも、先頭および末尾に 0 が表示されません。
|(.) |小数点のプレースホルダーです。 ロケールによっては、小数点の区切り記号としてコンマが使用されます。 小数点のプレースホルダーは、整数部および小数部に表示する桁数を決定します。 書式指定式でこの記号の左に # 記号だけがある場合、1 未満の数値の先頭は小数点区切り記号になります。 小数値の先頭に 0 を表示するには、整数部の最初の桁のプレースホルダーとして 0 を使用します。 書式指定結果で小数点のプレースホルダーとして実際に使用される記号は、システムで認識される数値書式によって異なります。
|(%) |パーセントのプレースホルダーです。 式を 100 倍します。 書式指定文字列の表示位置にパーセント記号 ( % ) が挿入されます。
|(,) |1,000 単位の区切り記号。 ロケールによっては、桁区切り記号としてピリオドが使用されます。 桁区切り記号は、整数部に 4 桁以上ある数値の百の位と千の位を区切ります。 書式にある桁区切り記号が桁のプレースホルダー (0 または #) で囲まれている場合は、桁区切り記号の標準使用が指定されます。 小数部の指定の有無にかかわらず、小数点のすぐ左に、桁区切り記号が 2 つ隣接する場合や、桁区切り記号がある場合は、"数値を 1000 で割って、必要に応じて丸める" ことを意味します。 たとえば、書式指定文字列 "##0,," を使用して、1 億を 100 として表せます。 百万より小さい数字は 0 として表示されます。 小数点のすぐ左以外の位置に 2 つの隣接する区切り記号がある場合は、通常の桁区切り記号を指定したものとして処理されます。 書式指定された出力で、実際に桁区切り記号として使用される記号は、システムで認識される数値書式によって異なります。
|(:) |時刻の区切り記号。 一部のロケールでは、時刻区切り文字を表す目的で他の文字が使用されることがあります。 時刻の値が書式設定されるときに、時刻区切り文字によって時、分、および秒が区切られます。 書式設定された出力で時刻区切り文字として使用される実際の文字は、システム設定によって決まります。
|(/) |日付の区切り記号。 一部のロケールでは、日付区切り文字を表す目的で他の文字が使用されることがあります。 日付値の書式が設定されている場合、日付、月、および年は、日付の区切り記号によって区切られます。 書式設定された出力で、日付の区切り文字として実際に使用される文字は、システム設定によって決まります。
|(E- E+ e- e+) |指数形式。 書式指定式で、E-、E+、e-、または e+ の左に少なくとも 1 つの桁プレースホルダー ( 0 または # ) がある場合、数値は、数値と指数部の間に E または e を挿入して指数形式で表示されます。 右にある桁プレースホルダーの数で、指数の桁数が決まります。 負の指数にマイナス記号を挿入するには、E- または e- を使用します。 負の指数にマイナス記号を入れて、正の指数にプラス記号を入れるには、E+ または e+ を使用します。
|- + $ ( ) |リテラル文字を表示します。 これ以外の文字をリテラルとして表示するには、その文字の前に円記号 (\) を付けるか、または二重引用符記号 (" ") で囲みます。
|(\) |書式指定文字列内の次の文字を表示します。 特殊な意味を持つ文字をリテラル文字として表示するには、その文字の前に円記号 (\) を付けます。 円記号自体は表示されません。 円記号を使用するのは、その文字を二重引用符記号で囲むことと同じです。 円記号自体を表示するには、円記号を 2 つ (\\) 使用します。 リテラル文字として表示できない文字には次のような文字があります。日付書式文字および時刻書式文字 (a、c、d、h、m、n、p、q、s、t、w、y、/、および :)、数値書式文字 (#、0、%、E、e、コンマ、およびピリオド)、および文字列書式文字 (@、&、<、>、および !)。
|("ABC") |二重引用符 (" ") で囲まれた文字列を表示します。 コードから**書式** に文字列を含めるには、Chr(34) を使ってテキストを囲みます (34 は引用符 (") を表す文字コードです)。
----


===== Hex 関数[[Hex]]

数値を 16 進数で表す String を返します。

.構文

[source,vbscript]
----
Hex(number)
----

必須の number 引数は、任意の有効な数値式または文字列式です。


[cols="1,4",options="header"]
|===
|number の値 |Hex の戻り値
|-2,147, 483,648 〜 2,147, 483,647 |最大 8 桁の 16 進文字
|Null |Null
|空 |ゼロ (0)
|===


.解説

number が整数ではない場合、最も近い整数に丸めてから評価されます。

16進数の逆にする場合は、16進数の値の前に &Hを付けます。 たとえば、Hex(255) は
文字列 FF を返し、&HFF は数値 255 を返します。

.例

次の例は、Hex 関数を使用して、数値の 16 進数値を返します。


[source,vbscript]
----
Dim MyHex
MyHex = Hex(5)    ' Returns 5.
MyHex = Hex(10)    ' Returns A.
MyHex = Hex(459)    ' Returns 1CB.
----

===== Oct 関数[[Oct]]



数値を 8 進数で表す Variant (String) を返します。

.構文

[source,vbscript]
----
Oct(number)
----

必須の number 引数は、任意の有効な数式または文字列式です。

.解説

number が整数ではない場合、最も近い整数に丸めてから評価されます。


[cols="1,4",options="header"]
|===
|number の値 |Oct の戻り値
|Null |Null
|空 |ゼロ (0)
|それ以外の値 |最大 11 桁の 8 進数
|===

適切な範囲の数値の前に &O を付けて記述すると、値を直接 8 進数で表すことができ
ます。 たとえば、10 進数の 8 の場合は、&O10 のように 8 進数で表記することがで
きます。

.例

次の例は、Oct 関数を使用して、数値の 8 進数値を返します。


[source,vbscript]
----
Dim MyOct
MyOct = Oct(4)     ' Returns 4.
MyOct = Oct(8)    ' Returns 10.
MyOct = Oct(459)    ' Returns 713.
----

===== Str 関数[[Str]]


数を示す Variant (String) を返します。

.構文

[source,vbscript]
----
Str(number)
----

必須の number 引数は、任意の有効な数式を含む Long です。

.解説

数値が文字列に変換されるとき、先頭のスペースは number の符号用に常に予約されま
す。 number が正の場合、返される文字列には先頭のスペースが含まれ、プラス記号は
省略されています。

日付、時刻、通貨、または他のユーザー定義書式として書式設定する数値を変換するに
は、Format 関数を使用します。 Str とは異なり、Format 関数は number の符号用に
先頭のスペースを含みません。

CAUTION:	Str 関数は、有効な桁区切り記号としてピリオド (.) のみを 認識し
ます。 他の桁区切り記号を使う場合は (国際アプリケーションの場合など)、CStr を
使って数値を文字列に変換します。

.例

この例では、Str 関数を使って、数値の文字列表現を返しています。 数値が文字列に
変換されるとき、先頭のスペースは常に符号用に予約されます。


[source,vbscript]
----
Dim MyString
MyString = Str(459)    ' Returns " 459".
MyString = Str(-459.65)    ' Returns "-459.65".
MyString = Str(459.001)    ' Returns " 459.001".
----


===== Val 関数[[Val]]


文字列に含まれる数値を、適切な型の数値として返します。

.構文

[source,vbscript]
----
Val(string)
----

必須の string 引数は、任意の有効な文字列式です。

.解説

Val 関数は、数値の一部として認識できない最初の文字で、文字列の読み取りを中止し
ます。 数値の一部と見なされることが多い記号や文字 (ドル記号、コンマなど) は、
認識されません。

ただし、この関数は、基数プレフィックス &O (8 進数) と &H (16 進数) を認識しま
す。 空白、タブ、およびライン フィード文字は、引数から削除されます。

次の例では、値 1615198 が返されます。


[source,vbscript]
----
Val("    1615 198th Street N.E.")
----

次のコード例の Val は、示されている 16 進数値の 10 進数値である -1 を返します。


[source,vbscript]
----
Val("&HFFFF")
----


CAUTION:	Val 関数は、ピリオド (.) のみを 有効な小数点の記号として認識し
ます。 別の小数点の記号を使用する場合は (国際的なアプリケーションの場合など)、
代わりに CDbl を使用して文字列を数値に変換します。

.例

次の例では、Val 関数を使用して、文字列に含まれる数値を返します。


[source,vbscript]
----
Dim MyValue
MyValue = Val("2457")    ' Returns 2457.
MyValue = Val(" 2 45 7")    ' Returns 2457.
MyValue = Val("24 and 57")    ' Returns 24.
----

==== CreateObject 関数[[CreateObject]]

ActiveX オブジェクトへの参照を作成して返します。

.構文

[source,vbscript]
----
CreateObject(class, [ servername ])
----

CreateObject 関数の構文は、次の指定項目があります。


[cols="1,4",options="header"]
|===
|指定項目 |説明
|class |必須。Variant (String)。 作成するオブジェクトのアプリケーション名とクラス。
|servername |省略可能。Variant (String)。 オブジェクトを作成するネットワーク サーバーの名前。 servername は、空の文字列 ("") である場合、ローカル コンピューターが使用されます。
|===

class 引数の構文は appname.objecttype で、指定項目は次のとおりです。

[cols="1,4",options="header"]
|===
|指定項目 |説明
|appname |必須。Variant (String)。 オブジェクトを提供するアプリケーションの名前。
|objecttype |必須。Variant (String)。 作成するオブジェクトの型またはクラス。
|===

.解説

オートメーションをサポートするアプリケーションはすべて、1 つ以上の型のオブジェ
クトを提供します。 たとえば、ワード プロセッシング アプリケーションでは、アプ
リケーション オブジェクト、文書オブジェクト、ツール バー オブジェクトが提供さ
れます。

ActiveX オブジェクトを作成するには、CreateObject によって返されたオブジェクト
をオブジェクト変数に割り当てます。


[source,vbscript]
----
' Declare an object variable to hold the object 
' reference. Dim as Object causes late binding. 
Dim ExcelSheet As Object
Set ExcelSheet = CreateObject("Excel.Sheet")
----


このコードでは、オブジェクトを作成するアプリケーション (この場合は Microsoft
Excel のスプレッドシート) を起動します。 作成されたオブジェクトをコードで参照
するには、定義したオブジェクト変数を使用します。 次の例では、オブジェクト変数
ExcelSheet とその他の Excel オブジェクト (Application オブジェクト、Cells コレ
クションなど) を使用して、新しいオブジェクトのプロパティおよびメソッドにアクセ
スします。


[source,vbscript]
----
' Make Excel visible through the Application object.
ExcelSheet.Application.Visible = True
' Place some text in the first cell of the sheet.
ExcelSheet.Application.Cells(1, 1).Value = "This is column A, row 1"
' Save the sheet to C:\test.xls directory.
ExcelSheet.SaveAs "C:\TEST.XLS"
' Close Excel with the Quit method on the Application object.
ExcelSheet.Application.Quit
' Release the object variable.
Set ExcelSheet = Nothing
----


As Object 句を使用してオブジェクト変数を宣言すると、任意の型のオブジェクトへの
参照を含めることができる変数が作成されます。 ただし、遅延バインディングの変数
を使用してオブジェクトにアクセスします。つまり、プログラムの実行時にバインドが
行われます。 事前バインドを発生させるオブジェクト変数を作成する、つまり、プロ
グラムがコンパイルされたときにバインドするには、特定のクラス ID を使用してオブ
ジェクト変数を宣言します。 たとえば、次のような Microsoft Excel の参照を宣言し
て作成することができます。


[source,vbscript]
----
Dim xlApp As Excel.Application 
Dim xlBook As Excel.Workbook
Dim xlSheet As Excel.WorkSheet
Set xlApp = CreateObject("Excel.Application")
Set xlBook = xlApp.Workbooks.Add
Set xlSheet = xlBook.Worksheets(1)
----

事前バインド変数を使用して参照すると、パフォーマンスは向上する可能性があります
が、宣言で指定したクラスへの参照しか含めることができません。

CreateObject 関数によって返されるオブジェクトを、オブジェクトを必要とする関数
に引数として渡すことができます。 たとえば、次のコードでは、Excel.Application
オブジェクトへの参照を作成して渡します。


[source,vbscript]
----
Call MySub (CreateObject("Excel.Application"))
----

コンピューターの名前を CreateObject の servername 引数に渡して、ネットワーク接
続されたリモート コンピューターにオブジェクトを作成することができます。 この名
前は、共有名のコンピューター名の部分と同じです。共有名が "\MyServer\Public" の
場合、servername は "MyServer" です。

次のコードは、MyServer という名前のリモート コンピューターで実行されている
Excel のインスタンスのバージョン番号を返します。


[source,vbscript]
----
Dim xlApp As Object
Set xlApp = CreateObject("Excel.Application", "MyServer")
Debug.Print xlApp.Version
----

このリモート サーバーが存在しない場合または使用できない場合は、実行時エラーが
発生します。


CAUTION:	CreateObject は、オブジェクトの現在のインスタンスがない場合に
使用します。 オブジェクトのインスタンスが既に実行されている場合は、新しいイン
スタンスが開始され、指定した型のオブジェクトが作成されます。 現在のインスタン
スを使用する、またはアプリケーションを起動してファイルを読み込ませるには、
GetObject 関数を使用します。

オブジェクトが単一インスタンスのオブジェクトとして登録されている場合は、
CreateObject を何回実行しても、そのオブジェクトのインスタンスは 1 つしか作成さ
れません。

.例

この例では、CreateObject 関数を使用して Microsoft Excel への参照 (xlApp) を設
定します。 この参照を使用して、Microsoft Excel の Visible プロパティにアクセス
し、Microsoft Excel の Quit メソッドを使用して終了します。 最後に、参照自体が
解放されます。


[source,vbscript]
----
Dim xlApp As Object    ' Declare variable to hold the reference.
    
Set xlApp = CreateObject("excel.application")
    ' You may have to set Visible property to True
    ' if you want to see the application.
xlApp.Visible = True
    ' Use xlApp to access Microsoft Excel's 
    ' other objects.
----

==== CurDir 関数[[CurDir]]




現在のパスを表す Variant (String) を返します。

.構文

[source,vbscript]
----
CurDir [ (drive) ]
----

省略可能な drive 引数は、既存のドライブを指定する文字列式です。 drive を指定し
ない場合、または drive に長さ 0 の文字列 ("") を指定した場合、CurDirは、現在の
ドライブのパスを返します。 Macintosh では、CurDir は指定された drive を無視し、
単に現在のドライブのパスを返します。

.例

次の例は、CurDir 関数を使用して現在のパスを返します。 Macintosh では、CurDirに
指定された drive は無視されます。 既定のドライブ名は、HD で、パス名の各部分は、
バックスラッシュではなくコロンで区切られます。 また、\Windows ではなく
Macintosh のフォルダーを指定します。


[source,vbscript]
----
' Assume current path on C drive is "C:\WINDOWS\SYSTEM" (on Microsoft Windows).
' Assume current path on D drive is "D:\EXCEL".
' Assume C is the current drive.
Dim MyPath
MyPath = CurDir    ' Returns "C:\WINDOWS\SYSTEM".
MyPath = CurDir("C")    ' Returns "C:\WINDOWS\SYSTEM".
MyPath = CurDir("D")    ' Returns "D:\EXCEL".
----

==== Date 関数[[Date]]


現在のシステム日付を含む Variant (Date) を返します。

.構文

[source,vbscript]
----
Date
----

.解説

システム日付を設定するには、Date ステートメントを使用します。

グレゴリオ暦の場合、Date と Date$ の動作は、Calendar プロパティの設定によって
変更されることはありません。 イスラム暦の場合、Date$ は mm-dd-yyyy という形式
の 10 文字の文字列を返します。ここで、mm (01 – 12)、dd (01 – 30)、および
yyyy (1400 – 1523) は、イスラム暦の月、日、および年を表します。 これに相当す
るグレゴリオ暦の範囲は 1980 年 1 月 1 日から 2099 年 12 月 31 日です。

.例

次の例では、Date 関数を使用して現在のシステム日付を返します。


[source,vbscript]
----
Dim MyDate
MyDate = Date    ' MyDate contains the current system date.
----

==== DateAdd 関数[[DateAdd]]

指定した時間間隔を日付に加算してその日付を含む Variant (Date) を返します。

.構文

[source,vbscript]
----
DateAdd(interval, number, date)
----

DateAdd 関数の構文に構文に使用される名前付き引数は次のとおりです。


[cols="1,4",options="header"]
|===
|指定項目 |説明
|interval |必須。 加算する時間間隔を表す文字列式。
|number |必須。 追加するサイクル間隔の数値を表す数値式です。 将来の日時を取得するには正の値を、過去の日時を取得するには負の値を指定します。
|date |必須。 時間間隔を加算する日付を表す Variant (Date)、またはリテラル。
|===

.設定

interval 引数の設定は次のとおりです。

[cols="1,4",options="header"]
|===
|設定 |説明
|yyyy |年
|q |四半期
|m |月
|y |通年での日数
|d |日
|w |平日
|ww |週
|h |時
|n |分
|s |秒
|===

.解説

DateAdd 関数を使用すると、指定した時間間隔を日付に加算したり、日付から減算した
りできます。 たとえば、DateAdd を使用して、今日から 30 日後の日付、または今か
ら 45 分後の時刻を計算することができます。

date に日数を加算する場合、年間通算日 ("y")、日 ("d")、または平日 ("w") を使用
できます。

CAUTION:	ある日付に日数を足す目的で、(日曜日から土曜日まですべての曜日
を含む) "w" サイクル間隔を使用するとき、DateAdd 関数は、その日までの、指定した
合計日数を追加します。その日までの、(月曜日から金曜日までの) 仕事日の数のみを
追加するのではないことに注意してください。

DateAdd 関数が無効な日付を返すことはありません。 次の例では、1 月 31 日に 1 か
月を追加します。


[source,vbscript]
----
DateAdd("m", 1, "31-Jan-95")
----

この場合、DateAdd は、1995 年 2 月 31 日ではなく、1995 年 2 月 28 日を返します。
date が 1996 年 1 月 31 日の場合は、1996 年は閏年であるため、1996 年 2 月 29
日を返します。

計算された日付が西暦 100 年よりも前になる場合 (つまり、date の年より多くの年を
引いた場合)、エラーが発生します。

number が Long 値ではない場合、最も近い整数に丸めてから評価されます。

CAUTION:	DateAdd の戻り値の形式は、date 引数で渡された形式ではなく、コ
ントロール パネルでの設定によって決まります。



CAUTION:	 Calendar プロパティの設定がグレゴリオ暦の場合、date にはグレ
ゴリオ暦の日付を指定する必要があります。 カレンダーがイスラム暦である場合、指
定する日付もイスラム暦である必要があります。 月の値が名前である場合、名前は現
在の Calendar プロパティの設定と一致している必要があります。 月名が現在の
Calendar プロパティ設定と競合する可能性を最小にするには、数字で示す月の値 (短
い日付形式) を入力します。

.例

次の例では、日付を受け取り、DateAdd 関数を使用して、指定された月数を加算した将
来の日付を表示します。


[source,vbscript]
----
Dim FirstDate As Date    ' Declare variables.
Dim IntervalType As String
Dim Number As Integer
Dim Msg As String
IntervalType = "m"    ' "m" specifies months as interval.
FirstDate = InputBox("Enter a date")
Number = InputBox("Enter number of months to add")
Msg = "New date: " & DateAdd(IntervalType, Number, FirstDate)
MsgBox Msg
----

==== DateDiff 関数[[DateDiff]]

2 つの指定した日付の時間間隔を指定する Variant (Long) を返します。

.構文

[source,vbscript]
----
DateDiff(interval, date1, date2, [ firstdayofweek, [ firstweekofyear ]] )
----

DateDiff 関数の構文には、次の名前付き引数があります。

|指定項目 |説明
|interval |必須。 date1 と date2 の時間間隔の計算に使用する時間単位を表す文字列式です。
|date1、date2 |必須。Variant (Date)。 計算に使用する 2 つの日付です。
|firstdayofweek |省略可能。 週の始まりの曜日を表す定数です。 省略すると、日曜日を指定したものと見なされます。
|firstweekofyear |省略可能。 年の第 1 週を指定する定数です。 省略すると、1 月 1 日を含む週が第 1 週と見なされます。

.設定

interval 引数の設定は次のとおりです。

[cols="1,4",options="header"]
|===
|設定 |説明
|yyyy |年
|q |四半期
|m |月
|y |通年での日数
|d |日
|w |平日
|ww |週
|h |時
|n |分
|s |秒
|===

firstdayofweek 引数の設定は次のとおりです。


[cols="1,1,4",options="header"]
|===
|定数 |値 |説明
|vbUseSystem |0 |NLS API 設定を使用します。
|vbSunday |1 |日曜日 (既定)
|vbMonday |2 |月曜日
|vbTuesday |3 |火曜日
|vbWednesday |4 |水曜日
|vbThursday |5 |木曜日
|vbFriday |6 |金曜日
|vbSaturday |7 |土曜日
|===


[cols="1,1,4",options="header"]
|===
|定数 |値 |説明
|vbUseSystem |0 |NLS API 設定を使用します。
|vbFirstJan1 |1 |1 月 1 日が含まれる週から開始します (既定)。
|vbFirstFourDays |2 |新年で少なくとも 4 日ある最初の週から開始します。
|vbFirstFullWeek |3 |年の最初の完全な週から開始します。
|===

.解説

DateDiff 関数を使用して、2 つの日付の間に指定した時間間隔がどのくらい存在する
かを確認します。 たとえば、DateDiff を使用して、2 つの日付間の日数や、今日から
年末までの週数を計算することができます。

date1 と date2 の間の日数を計算するには、年 ("y") または日 ("d") の日付を使用
できます。 interval が曜日 ("w") の場合、DateDiff は 2 つの日付間の週数を返し
ます。 date1 が月曜日の場合、DateDiff では date2 までの月曜日の数がカウントさ
れます。 date1 ではなく date2 がカウントされます。

一方、interval が週 ("ww") の場合、DateDiff 関数は 2 つの日付間のカレンダーの
週数を返します。 date1 と date2 間の日曜日の数がカウントされます。 DateDiff で
は、date2 が日曜日の場合は、date2 がカウントされます。date1 が日曜日の場合でも
date1 はカウントされません。

date1 が date2 よりも後の時点を示す場合、DateDiff 関数は負の数を返します。
firstdayofweek 引数は、"w" および "ww" の間隔記号を使用する計算に影響します。

date1 または date2 が日付リテラルの場合、指定した年はその日付の一部として恒久
的に保存されます。 ただし、date1 または date2 が二重引用符 (" ") で囲まれてい
て、年を省略した場合、date1 または date2 の式が評価されるたびに、現在の年がコ
ードに挿入されます。 これにより、別の年でも使用できるコードを記述することがで
きます。

連続する年の 12 月 31 日と 1 月 1 日を比較すると、1 日が経過しただけの場合でも、
年 ("yyyy") の DateDiff は 1 を返します。

CAUTION:	Calendar プロパティの設定がグレゴリオ暦の場合、date1 と date2
ではグレゴリオ暦の日付を指定する必要があります。 カレンダーがイスラム暦の場合
は、イスラム暦で日付を指定する必要があります。

.例

この例では、DateDiff 関数を使用して、指定された日付から今日までの日数を表示し
ます。


[source,vbscript]
----
Dim TheDate As Date    ' Declare variables.
Dim Msg
TheDate = InputBox("Enter a date")
Msg = "Days from today: " & DateDiff("d", Now, TheDate)
MsgBox Msg
----

==== DatePart 関数[[DatePart]]

WARNING:	 この関数の使用には問題があります。 一部のカレンダー年の最後の
月曜日は、週1である必要がある場合は、53週として返されます。 詳細および回避策に
ついては、「Format または DatePart 関数は、先週の最後の月曜日に間違った週番号
を返す」を参照してください。 日付の指定した部分を含む Variant (Integer) を返し
ます。

.構文

[source,vbscript]
----
DatePart(interval, date, [ firstdayofweek, [ firstweekofyear ]])
----

DatePart 関数の構文には、次の名前付き引数があります。

[cols="1,4",options="header"]
|===
|指定項目 |説明
|interval |必須。 戻す時間のサイクル間隔の 文字列式です。
|date |必須。 評価する Variant (Date) の値です。
|firstdayofweek |省略可能。 週の始まりの曜日を表す定数です。 省略すると、日曜日を指定したものと見なされます。
|firstweekofyear |省略可能。 年の第 1 週を指定する定数です。 省略すると、1 月 1 日を含む週が第 1 週と見なされます。
|===

.設定

interval 引数の設定は次のとおりです。

[cols="1,4",options="header"]
|===
|設定 |説明
|yyyy |年
|q |四半期
|m |月
|y |通年での日数
|d |日
|w |平日
|ww |週
|h |時
|n |分
|s |秒
|===

firstdayofweek 引数の設定は次のとおりです。

[cols="1,4",options="header"]
|===
|定数 |値 |説明
|vbUseSystem |.0 |NLS API 設定を使用します。
|vbSunday |1-d |日曜日 (既定)
|vbMonday |pbm-2 |月曜日
|vbTuesday |1/3 |火曜日
|vbWednesday |4 |水曜日
|vbThursday |5 |木曜日
|vbFriday |6 |金曜日
|vbSaturday |7 |土曜日
|===

_firstweekofyear_ 引数の設定は次のとおりです。

[cols="1,4",options="header"]
|===
|定数 |値 |説明
|vbUseSystem |.0 |NLS API 設定を使用します。
|vbFirstJan1 |1-d |1 月 1 日が含まれる週から開始します (既定)。
|vbFirstFourDays |pbm-2 |新年で少なくとも 4 日ある最初の週から開始します。
|vbFirstFullWeek |1/3 |年の最初の完全な週から開始します。
|===

.解説

DatePart 関数を使用して、日付を評価し、特定の時間間隔を返すことができます。 た
とえば、曜日または現在の時間を計算するために、DatePart を使用する場合がありま
す。

firstdayofweek 引数は、"w" および "ww" の間隔記号を使用する計算に影響します。

date が日付リテラルの場合、指定した年はその日付の一部として恒久的に保存されま
す。 ただし、date が二重引用符 (" ") で囲まれていて、年を省略した場合、date の
式が評価されるたびに、現在の年がコードに挿入されます。 これにより、別の年でも
使用できるコードを記述することができます。

WARNING:	<<Calendar,Calendar>> プロパティの設定がグレゴリオ暦の場合、
date にはグレゴリオ暦の日付を指定する必要があります。 カレンダーがイスラム暦で
ある場合、指定する日付もイスラム暦である必要があります。

戻された日付の部分は、現在のアラビア歴の期間の単位になります。 たとえば、現在
のカレンダーがイスラム暦で、戻された日付の部分が年の場合、年の値はイスラム暦年
になります。

.例

この例では、DatePart 関数を使用して日付を取得し、その日付が含まれる四半期が表
示されます。


[source,vbscript]
----
Dim TheDate As Date    ' Declare variables.
Dim Msg    
TheDate = InputBox("Enter a date:")
Msg = "Quarter: " & DatePart("q", TheDate)
MsgBox Msg
----


==== DateSerial 関数[[DateSerial]]

指定した年、月、日の Variant (Date) を返します。

.構文

[source,vbscript]
----
DateSerial(year, month, day)
----

DateSerial 関数の構文には、次の名前付き引数があります。

[cols="1,4",options="header"]
|===
|パーツ |説明
|year |必須。Integer。 100 以上 9999 以下の数値、または数式です。
|month |必須。Integer。 任意の数式。
|day |必須。Integer。 任意の数式。
|===

.解説

1991 年 12 月 31 日などの日付を指定するには、DateSerial の各引数の数値範囲がそ
     の単位の許容範囲内である必要があります。つまり、日の場合は 1 以上 31 以下、
月の場合は 1 以上 12 以下です。 ただし、特定の日付の前後の日数、月数、年数を表
す任意の数式を使用して、各引数の相対日付を指定することもできます。

次の例では、絶対日付数値の代わりに、数式を使用しています。 DateSerial 関数は、
月初めの前日 (1 - 1)、8 月から 2 か月前 (8 - 2)、1990 年から 10 年前 (1990 -
10)、つまり、1980 年 5 月 31 日を返します。

Windows 98 または Windows 2000 では、year 引数の 2 桁の年は、ユーザーが定義し
たマシン設定により解釈されます。 既定の設定では、0 以上 29 以下の値が 2000 年
から 2029 年として解釈されます。 30 以上 99 以下の既定値は、1930 年から 1999
年として解釈されます。 その他のすべての year 引数では、4 桁の年を使用します
(1800 など)。

以前の Windows バージョンでは、上記で説明した既定値に応じて、2 桁の年で解釈さ
れます。 関数が適切な値を確実に返すようにするには、4 桁の年を使用します。

いずれかの引数の値が引数の許容範囲を超えた場合は、必要に応じて次の上位の単位に
繰り越されます。 たとえば、35 日を指定した場合は、1 か月と数日と評価されます
(日数は月によって変わります)。 引数のいずれか 1 つでも -32,768 から 32,767 の
範囲を超えると、エラーが発生します。 3 つの引数で指定された日付が許容日付範囲
外の日付になると、エラーが発生します。


CAUTION:	year、month、および day は、カレンダー プロパティ設定がグレゴ
リオ暦の場合、指定した値はグレゴリオ暦と見なされます。 カレンダー プロパティの
設定がイスラム暦の場合、指定した値はイスラム暦と見なされます。

返される日付部分は、現在の Visual Basic のカレンダーの暦になります。 たとえば、
現在のカレンダーがイスラム暦で、返される日付部分が年の場合、年の値はイスラム暦
の年になります。 引数 year の場合、0 以上 99 以下の値は 1400 年から 1499 年と
して解釈されます。 その他のすべての year 値では、完全な 4 桁の年を使用します
(1520 など)。

.例

この例では、DateSerial 関数を使用して、指定した年、月、日の日付を返しています。


[source,vbscript]
----
Dim MyDate
' MyDate contains the date for February 12, 1969.
MyDate = DateSerial(1969, 2, 12)    ' Return a date.
----

==== DateValue 関数[[DateValue]]

Variant (Date) を返します。

.構文

[source,vbscript]
----
DateValue(date)
----

必須の date 引数は、通常、100 年 1 月 1 日から 9999 年 12 月 31 日までの日付を
表す文字列式です。 また、date には、この範囲内の日付や時刻、または日付と時刻の
両方を表す任意の式を指定することもできます。

.解説

date が有効な日付の区切り記号で区切られた数字のみを含む文字列である場合、
DateValue は、ユーザーがシステムに対して指定した短い日付形式に従って月、日、年
の順序を認識します。 また、DateValue は、月の名前 (長い形式または省略形) を含
んだ明確な日付も認識します。 たとえば、DateValue は、"12/30/1991" と
"12/30/91" だけでなく "December 30, 1991" と "Dec 30, 1991" も認識します。

date の年の部分を省略した場合、DateValue はコンピューターのシステム日付の現在
の年を使用します。

date 引数に時刻の情報が含まれている場合、DateValue はその時刻を返しません。 た
だし、date に無効な時刻の情報 ("89:98" など) が含まれているとエラーが発生しま
す。

CAUTION:	<<Calendar,Calendar>> プロパティの設定がグレゴリオ暦の場合、
date にはグレゴリオ暦の日付を指定する必要があります。 カレンダーがイスラム暦で
ある場合、指定する日付もイスラム暦である必要があります。 イスラム暦の日付を指
定する場合、引数 date は、"1/1/100" (グレゴリオ暦の 718 年 8 月 2 日) から
"4/3/9666" (グレゴリオ暦の 9999 年 12 月 31 日) の範囲内の日付を表す String で
す。


.例

次の例では、DateValue 関数を使用して文字列を日付に変換します。 "MyDate =
#2/12/69#" のように、日付リテラルを使用して Variant 変数または Date 変数に日付
を直接割り当てることもできます。


[source,vbscript]
----
Dim MyDate
MyDate = DateValue("February 12, 1969")    ' Return a date.
----


==== Day 関数[[Day]]

月の特定の 1 日を表す 1 から 31 の範囲の整数を指定する Variant (Integer) を返
します。

.構文

[source,vbscript]
----
Day(date)
----

必須の date 引数は、日を表す任意の Variant、数式、文字列式、または任意の組み合
わせです。 date に Null が含まれている場合は Null が返されます。

CAUTION:	<<Calendar,Calendar>> プロパティの設定がグレゴリオ暦の場合、返
される整数は、date 引数のグレゴリオ暦の日を示します。 Calendar がイスラム暦の
場合、返される整数は、date 引数のイスラム暦の日を示します。


.例

次の例では、Day 関数を使用して、指定した日付から日を取得します。 開発環境では、
日付リテラルは、コードのロケール設定を使用して短い形式で表示されます。


[source,vbscript]
----
Dim MyDate, MyDay
MyDate = #February 12, 1969#    ' Assign a date.
MyDay = Day(MyDate)    ' MyDay contains 12.
----

==== DDB 関数[[DDB]]


倍額定率法や、ユーザーが指定した他の方法を使用して、特定の期における資産の減価
償却費を指定する Double を返します。

.構文

[source,vbscript]
----
DDB(cost, salvage, life, period, [ factor ])
----

DDB 関数には、次の名前付き引数があります。

[cols="1,4",options="header"]
|===
|パーツ |説明
|cost |必須です。 資産の初期コストを指定する Double です。
|salvage |必須です。 耐用期間が終了した時点での資産の価格を指定する Double です。
|life |必須です。 資産の耐用期間を指定する Double です。
|period |必須。 資産の減価償却費を計算する期を指定する Double です。
|factor |省略可能。 減価償却率を指定する Variant です。 省略すると、2 (倍額定率法) を指定したと見なされます。
|===

.解説

倍額定率法では、減価償却費が加速的に計算されます。 減価償却費は、最初の期が最
も多く、その後の期では減少します。

引数の life と period は、同じ単位で指定する必要があります。 たとえば、life に
月数を指定した場合は、period にも月数を指定する必要があります。 すべての引数は、
必ず正の数で指定してください。

DDB 関数では、次の数式を使用して、指定した期の減価償却費を計算します。

価償却費/period = ((cost - salvage) * factor) / life

.例

この例では、DDB 関数を使用して、指定した期における資産の減価償却費を返します。
指定する項目は、初期コスト (InitCost)、資産の耐用期間が終了した時点での残存価
額 (SalvageVal)、資産の耐用年数 (LifeTime)、および減価償却費を計算する年単位の
期 (Depr) です。


[source,vbscript]
----
Dim Fmt, InitCost, SalvageVal, MonthLife, LifeTime, DepYear, Depr
Const YRMOS = 12    ' Number of months in a year.
Fmt = "###,##0.00"
InitCost = InputBox("What's the initial cost of the asset?")
SalvageVal = InputBox("Enter the asset's value at end of its life.")
MonthLife = InputBox("What's the asset's useful life in months?")
Do While MonthLife < YRMOS    ' Ensure period is >= 1 year.
    MsgBox "Asset life must be a year or more."
    MonthLife = InputBox("What's the asset's useful life in months?")
Loop
LifeTime = MonthLife / YRMOS    ' Convert months to years.
If LifeTime <> Int(MonthLife / YRMOS) Then
    LifeTime = Int(LifeTime + 1)    ' Round up to nearest year.
End If 
DepYear = CInt(InputBox("Enter year for depreciation calculation."))
Do While DepYear < 1 Or DepYear > LifeTime
    MsgBox "You must enter at least 1 but not more than " & LifeTime
    DepYear = InputBox("Enter year for depreciation calculation.")
Loop
Depr = DDB(InitCost, SalvageVal, LifeTime, DepYear)
MsgBox "The depreciation for year " & DepYear & " is " & _
Format(Depr, Fmt) & "."
----




==== Dir 関数[[Dir]]

指定したパターンまたはファイル属性に一致するファイル、ディレクトリ、フォルダー
の名前、またはドライブのボリューム ラベルを表す String を返します。

.構文

[source,vbscript]
----
Dir [ (pathname, [ attributes ] ) ]
----

Dir 関数の構文には、次の指定項目があります。

[cols="1,4",options="header"]
|===
|パーツ |説明
|pathname |省略可能。 ファイル名を指定する文字列式です。ディレクトリまたはフォルダー、およびドライブを含めることができます。 pathname が見つからない場合は、長さ 0 の文字列 ("") が返されます。
|attributes |省略可能。 ファイル属性を指定する定数または数式 (合計によって指定) です。 省略した場合は、pathname に一致する、属性のないファイルが返されます。
|===

.設定

attributes 引数の設定は次のとおりです。

[cols="2,1,4",options="header"]
|===
|定数 |値 |説明
|vbNormal |0 |(既定値) 属性のないファイル。
|vbReadOnly |1 |属性のないファイルと読み取り専用のファイル。
|vbHidden |2 |属性のないファイルと隠しファイル。
|vbSystem |4 |属性のないファイルとシステム ファイル。 Macintosh では使用できません。
|vbVolume |8 |ボリューム ラベル。他の属性を指定した場合は、vbVolume は無視されます。 Macintosh では使用できません。
|vbDirectory |16 |属性のないファイルとディレクトリまたはフォルダー。
|vbAlias |64 |指定されたファイル名はエイリアスです。 Macintosh でのみ使用できます。
|===


CAUTION:	これらの定数は、Visual Basic for Applications によって指定され、
コードの任意の場所で実際の値の代わりに使用できます。


.解説

Microsoft Windows では、Dir で複数の文字 (*) と 1 文字 (?) のワイルドカードを
使用して、複数のファイルを指定できます。 Macintosh では、これらの文字は有効な
ファイル名の文字と見なされ、複数のファイルを指定するためのワイルドカードとして
は使用できません。

Macintosh ではワイルドカードがサポートされないため、ファイルの種類を使用してフ
ァイルのグループを識別します。 MacID 関数を使用すると、ファイル名を使わずにフ
ァイルの種類を指定できます。 たとえば、次のステートメントでは、現在のフォルダ
ー内の最初のテキスト ファイルの名前が返されます。


[source,vbscript]
----
Dir("SomePath", MacID("TEXT"))
----

フォルダー内のすべてのファイルに対して反復処理を行うには、空の文字列を指定しま
す。


[source,vbscript]
----
Dir("")
----

Microsoft Windows では、Dir で MacID 関数を使用するとエラーが発生します。

attribute の値が 256 を超える場合は MacID の値と見なされます。

Dir 関数の最初の呼び出しの際に pathname を指定しないとエラーが発生します。 フ
ァイル属性も指定する場合は、pathname を指定する必要があります。

Dir は、pathname に一致する最初のファイル名を返します。 pathname に一致する追
加のファイル名を取得するには、引数なしで Dir を再度呼び出します。 一致するファ
イル名がなくなると、Dir は長さ 0 の文字列 ("") を返します。 長さ 0 の文字列が
返された後の呼び出しで、pathname を指定しないとエラーが発生します。

現在の pathname に一致するすべてのファイル名を取得せずに、新しい pathname に変
更することもできます。 ただし、Dir 関数を再帰的に呼び出すことはできません。
vbDirectory 属性を付けて Dir を呼び出しても、継続してサブディレクトリが返され
ることはありません。

Excel for Mac 2016 では、最初の Dir 関数呼び出しは成功します。 ただし、指定さ
れたディレクトリで繰り返して呼び出すと、エラーが発生します。 残念ですが、これ
は既知のバグです。


TIP:	ファイル名は特定の順序で取得されるわけではないため、必要に応じて、返さ
れたファイル名を配列に格納し、その配列を並べ替えます。

==== DoEvents 関数[[DoEvents]]


オペレーティング システムが他のイベントを処理できるように、実行を渡します。

.構文

[source,vbscript]
----
DoEvents( )
----

.解説

DoEvents 関数は、単体バージョンの Visual Basic (Visual Basic Professional
Edition など) で開かれているフォームの数を表す Integer を返します。 他のすべて
のアプリケーションでは、DoEvents はゼロを返します。

DoEvents はオペレーティング システムに制御を渡します。 オペレーティング システ
ムがキュー内のイベントの処理を終了し、SendKeys キューのすべてのキーが送信され
た後、制御が戻されます。

DoEvents は、たとえばユーザーが一旦開始した処理 (ファイルの検索など) を取り消
せるようにする、といった単純な処理を行う場合に最も役に立ちます。 長時間実行し
ているプロセスの場合にプロセッサを空けるには、タイマーを使用するか、またはタス
クを ActiveX EXE コンポーネントに委任する方が適しています。 後者の場合、アプリ
ケーションとは完全に独立してタスクを続行でき、オペレーティング システムがマル
チタスクとタイム スライスの処理を行います。

イベント プロシージャ内でプロセッサに一時的に制御を渡すときは、プロシージャが、
最初の呼び出しが戻る前とは異なるコード部分から再開されないようにする必要があり
ます。異なる場所から再開すると、予期しない結果になる可能性があります。 さらに、
制御を渡している間に、他のアプリケーションが予期しない方法でプロシージャとやり
取りする可能性がある場合は、DoEvents を使用しないでください。

.例

次の例では、DoEvents 関数を使用して、1,000 回ループするごとに 1 回、オペレーテ
ィング システムに制御を渡します。 DoEvents は、開いている Visual Basic フォー
ムの数を返しますが、これが行われるのは、ホスト アプリケーションが Visual Basic
の場合のみです。


[source,vbscript]
----
' Create a variable to hold number of Visual Basic forms loaded 
' and visible.
Dim I, OpenForms
For I = 1 To 150000    ' Start loop.
    If I Mod 1000 = 0 Then     ' If loop has repeated 1000 times.
        OpenForms = DoEvents    ' Yield to operating system.
    End If
Next I    ' Increment loop counter.
----

==== Environ 関数[[Environ]]



オペレーティング システムの環境変数に関連付けられた String を返します。
Macintosh では使用できません。

.構文

[source,vbscript]
----
Environ( { envstring | number } )
----

Environ 関数の構文には、次の名前付き引数があります。


[cols="1,4",options="header"]
|===
|パーツ |説明
|envstring |省略可能。 環境変数の名前を含む文字列式です。
|number |省略可能。 環境文字列テーブル内の環境文字列の数値順序に対応する数式です。 number 引数には任意の数式を使用できますが、評価される前に整数に丸められます。
|===

.解説

envstring が環境文字列テーブル内にない場合は、長さ 0 の文字列 ("") が返されま
す。 それ以外の場合、Environ は指定された envstring に割り当てられているテキス
トを返します。つまり、環境文字列テーブルでその環境変数の等号 (=) の後にあるテ
キストを返します。

number を指定した場合は、環境文字列テーブルでその数値位置にある文字列が返され
ます。 この場合、Environ は envstring を含むすべてのテキストを返します。 指定
された位置に環境文字列がない場合、Environ は長さ 0 の文字列を返します。

.例

この例では、Environ 関数を使用して、PATH ステートメントのエントリ番号と長さを
環境文字列テーブルから提供しています。 Macintosh では使用できません。


[source,vbscript]
----
Dim EnvString, Indx, Msg, PathLen    ' Declare variables.
Indx = 1    ' Initialize index to 1.
Do
    EnvString = Environ(Indx)    ' Get environment 
                ' variable.
    If Left(EnvString, 5) = "PATH=" Then    ' Check PATH entry.
        PathLen = Len(Environ("PATH"))    ' Get length.
        Msg = "PATH entry = " & Indx & " and length = " & PathLen
        Exit Do
    Else
        Indx = Indx + 1    ' Not PATH entry,
    End If    ' so increment.
Loop Until EnvString = ""
If PathLen > 0 Then
    MsgBox Msg    ' Display message.
Else
    MsgBox "No PATH environment variable exists."
End If
----

==== EOF 関数[[EOF]]

Random またはシーケンシャル Input で開かれたファイルの末尾に達した場合、
Boolean 値 True を含む整数を返します。

.構文

[source,vbscript]
----
EOF(filenumber)
----

filenumber 引数は必須の引数です。有効なファイル番号を含む整数です。

.解説

EOF を使用して、ファイルの末尾を越える入力によるエラーが発生しないようにします。

ファイルの末尾に達するまで、EOF 関数は False を返します。 Random または Binary
アクセスで開かれたファイルの場合、最後に実行した Get ステートメントでレコード
全体を読み取れなくなるまで、EOF は False を返します。

Binary アクセス用に開かれたファイルでは、Input 関数を使って、EOF が True を返
すまでファイルを読み取ろうとすると、エラーが発生します。 Input でバイナリ ファ
イルを読み取るときは、EOF の代わりに LOF 関数と Loc 関数を使用します。または、
EOF 関数を使用しているときは Get を使用します。 Output で開かれたファイルの場
合、EOF は常に True を返します。

.例

この例では、EOF 関数を使用してファイルの末尾を検出します。 この例では、MYFILE
は数行のテキストを含むテキスト ファイルであると仮定しています。


[source,vbscript]
----
Dim InputData
Open "MYFILE" For Input As #1    ' Open file for input.
Do While Not EOF(1)    ' Check for end of file.
    Line Input #1, InputData    ' Read line of data.
    Debug.Print InputData    ' Print to the Immediate window.
Loop
Close #1    ' Close file.
----


==== Error 関数[[Error]]


指定したエラー番号に対応するエラー メッセージを返します。

.構文

[source,vbscript]
----
Error [ (errornumber) ]
----

errornumber 引数は省略可能です。任意の有効なエラー番号を指定できます。
errornumber が有効なエラー番号でも、定義されていなければ、Error から "アプリケ
ーション定義またはオブジェクト定義のエラーです。" という文字列が返されます。

errornumber が有効でない場合はエラーが発生します。 errornumber を省略した場合
は、最後に発生した実行時エラーに対応するメッセージが返されます。 実行時エラー
が発生していない場合、または errornumber が 0 の場合は、Error から長さ 0 の文
字列 ("") が返されます。

.解説

最後に発生した実行時エラーを特定するには、Err オブジェクトのプロパティ設定を調
べます。 Error 関数の戻り値は、Err オブジェクトの Description プロパティに対応
しています。

.例

この例では、Error 関数を使用して、指定したエラー番号に対応するエラー メッセー
ジを出力します。


[source,vbscript]
----
Private Sub PrintError()
    Dim ErrorNumber As Long, count As Long
    count = 1: ErrorNumber = 1
    On Error GoTo EOSb
    Do While count < 100
        Do While Error(ErrorNumber) = "Application-defined or object-defined error": ErrorNumber = ErrorNumber + 1: Loop
        Debug.Print count & "-Error(" & ErrorNumber & "): " & Error(ErrorNumber)
        ErrorNumber = ErrorNumber + 1
        count = count + 1
    Loop
EOSb: Debug.Print ErrorNumber
End Sub
----

==== FileAttr 関数[[FileAttr]]


<<Open,Open>> ステートメントを使用して開かれたファイルのファイル モードを表す
Long を返します。

.構文

[source,vbscript]
----
FileAttr(filenumber, returntype)
----

FileAttr 関数の構文に使用される名前付き引数は次のとおりです。


[cols="1,4",options="header"]
|===
|パーツ |説明
|filenumber |必須。Integer。 任意の有効なファイル番号です。
|returntype |必須。Integer。 返す情報の種類を示す数値。 ファイル モードを示す値を返す場合は 1 を指定します。 16 ビット システムの場合のみ、オペレーティング システムのファイル ハンドルを取得する場合に 2 を指定します。 Returntype 2 は 32 ビット システムではサポートされていないため、エラーが発生します。
|===

.戻り値

returntype 引数が 1 の場合、ファイル アクセス モードを示す次の値が返されます。


[cols="1,4",options="header"]
|===
|モード |値
|Input |1
|出力 |2
|Random |4
|Append |8
|Binary |32
|===

.例

この例では、FileAttr 関数を使用して、開かれているファイルのファイル モードおよ
びファイル ハンドルを返しています。 ファイル ハンドルは 16 ビット システムでの
み返されます。32 ビット システムで 2 つ目の引数に 2 を渡すと、エラーが発生しま
す。


[source,vbscript]
----
Dim FileNum, Mode, Handle
FileNum = 1    ' Assign file number.
Open "TESTFILE" For Append As FileNum    ' Open file.
Mode = FileAttr(FileNum, 1)    ' Returns 8 (Append file mode).
Handle = FileAttr(FileNum, 2)    ' Returns file handle.
Close FileNum    ' Close file.
----

==== FileDateTime 関数[[FileDateTime]]


ファイルの作成日時または最終更新日時を示す Variant (Date) を返します。

.構文

[source,vbscript]
----
FileDateTime(pathname)
----

必須の pathname 引数は、ファイル名を指定する文字列式です。 pathname には、ディ
レクトリまたはフォルダー、およびドライブを含めることができます。

.例

この例では、FileDateTime 関数を使用して、ファイルの作成日時または最終更新日時
を特定します。 表示される日時の形式は、システムのロケール設定に基づいています。


[source,vbscript]
----
Dim MyStamp
' Assume TESTFILE was last modified on February 12, 1993 at 4:35:47 PM.
' Assume English/U.S. locale settings.
MyStamp = FileDateTime("TESTFILE")    ' Returns "2/12/93 4:35:47 PM".
----

==== FileLen 関数[[FileLen]]

バイト単位でファイルの長さを指定する Long を返します。

.構文

[source,vbscript]
----
FileLen (pathname)
----

必須の pathname 引数は、ファイルを指定する文字列式です。 pathname には、ディレ
クトリまたはフォルダー、およびドライブを含めることができます。

.解説

FileLen 関数が呼び出されたときに指定したファイルが開いている場合、返された値は、
そのファイルを開く直前のファイル サイズを表します。

CAUTION:	開いているファイルの長さを取得するには、LOF 関数を使用します。


.例

この例では、FileLen 関数を使用して、ファイルの長さをバイト単位で返します。 こ
の例の目的のため、TESTFILE はデータを含んでいるファイルとします。


[source,vbscript]
----
Dim MySize
MySize = FileLen("TESTFILE")    ' Returns file length (bytes).
----

==== Filter 関数[[Filter]]

指定されたフィルター条件に基づいて、文字列配列のサブセットが含まれるゼロベース
配列を返します。

.構文

[source,vbscript]
----
Filter(sourcearray, match, [ include, [ compare ]])
----

Filter 関数の構文に使用される名前付き引数は次のとおりです。

[cols="1,4",options="header"]
|===
|パーツ |説明
|sourcearray |必須です。 検索する文字列の 1 次元配列。
|match |必須。 検索する文字列。
|include |省略可能。 返すサブ文字列に match を含めるか、除外するかを示す Boolean 値。 include が True の場合、Filter は、match が含まれる配列のサブセットをサブ文字列として返します。 include が False の場合、Filter は、match が含まれない配列のサブセットをサブ文字列として返します。
|compare |省略可能。 使用する文字列比較の種類を示す数値。 値については、「設定」セクションを参照してください。
|===

.設定

compare 引数には、次の値を指定できます。

[cols="2,1,4",options="header"]
|===
|定数 |値 |説明
|vbUseCompareOption |-1 |Option Compare ステートメントの設定を使用して比較を実行します。
|vbBinaryCompare |.0 |バイナリ比較を実行します。
|vbTextCompare |1-d |テキスト比較を実行します。
|vbDatabaseCompare |pbm-2 |Microsoft Access のみ。 データベース内の情報に基づいて比較を実行します。
|===

Filter 関数によって返される配列には、一致したアイテムを格納するのに十分な数の
要素のみが含まれます。

==== FormatCurrency 関数[[FormatCurrency]]

システムのコントロール パネルで定義された通貨記号を使用して、通貨値として書式
設定された式を返します。

.構文

[source,vbscript]
----
FormatCurrency(Expression, [ NumDigitsAfterDecimal, [ IncludeLeadingDigit, [ UseParensForNegativeNumbers, [ GroupDigits ]]]])
----

FormatCurrency 関数の構文には、次の指定項目があります。

[cols="1,4",options="header"]
|===
|パーツ |説明
|Expression |必須。 書式設定する式です。
|NumDigitsAfterDecimal |省略可能。 表示する小数点以下の桁数を示す数値です。 既定値は -1 です。これは、コンピューターの地域の設定が使用されることを示します。
|IncludeLeadingDigit |省略可能。 小数値に先頭のゼロを表示するかどうかを示す Tristate 定数です。 値については、「設定」セクションを参照してください。
|UseParensForNegativeNumbers |オプション。 負の値をかっこで囲むかどうかを示す Tristate 定数です。 値については「設定値」を参照してください。
|GroupDigits |省略可能。 コンピューターの地域の設定で指定されている桁区切り記号を使用して数値を区切るかどうかを示す Tristate 定数です。 値については、「設定」セクションを参照してください。
|===

.設定

IncludeLeadingDigit、UseParensForNegativeNumbers、および GroupDigits 引数の設
定は次のとおりです。

[cols="2,1,4",options="header"]
|===
|定数 |値 |説明
|vbTrue |-1 |True
|vbFalse |.0 |False
|vbUseDefault |-2 |コンピューターの地域の設定を使用します。
|===

.解説

省略可能な引数を省略した場合は、コンピューターの地域の設定の値が使用されます。
通貨値に対する通貨記号の位置は、システムの地域の設定によって決まります。

CAUTION:	先頭のゼロを除き、設定情報はすべて、[地域の設定] の [通貨] タ
ブの情報に基づいています。先頭のゼロは、[数値] タブの情報に基づきます。


==== FormatDateTime 関数[[FormatDateTime]]

日付または時刻として書式設定された式を返します。

.構文

[source,vbscript]
----
FormatDateTime(Date, [ NamedFormat ])
----

FormatDateTime 関数の構文には、次の指定項目があります。

[cols="1,4",options="header"]
|===
|パーツ |説明
|Date |必須。 書式設定する日付式。
|NamedFormat |省略可能。 使用する日付/時刻の形式を示す数値。 省略すると、vbGeneralDate が使用されます。
|===

.設定

NamedFormat 引数の設定は次のとおりです。

[cols="1,4",options="header"]
|===
|定数 |値 |説明
|vbGeneralDate |.0 |日付と時刻のどちらか、または両方を表示します。 日付部分がある場合は、短い日付として表示します。 時刻部分がある場合は、長い時刻として表示します。 両方ある場合は両方の部分を表示します。
|vbLongDate |1-d |コンピューターの地域の設定で指定されている長い日付形式を使用して日付を表示します。
|vbShortDate |pbm-2 |コンピューターの地域の設定で指定されている短い日付形式を使用して日付を表示します。
|vbLongTime |1/3 |コンピューターの地域の設定で指定されている時刻形式を使用して時刻を表示します。
|vbShortTime |2/4 |24 時間形式 (hh:mm) を使用して時刻を表示します。
|===

==== FormatNumber 関数[[FormatNumber]]

数値として書式設定された式を返します。

.構文

[source,vbscript]
----
FormatNumber(Expression, [ NumDigitsAfterDecimal, [ IncludeLeadingDigit, [ UseParensForNegativeNumbers, [ GroupDigits ]]]])
----

FormatNumber 関数の構文には、次の指定項目があります。

[cols="1,4",options="header"]
|===
|パーツ |説明
|Expression |必須。 書式設定する式です。
|NumDigitsAfterDecimal |省略可能。 表示する小数点以下の桁数を示す数値です。 既定値は -1 です。これは、コンピューターの地域の設定が使用されることを示します。
|IncludeLeadingDigit |省略可能。 小数値に先頭のゼロを表示するかどうかを示す Tristate 定数です。 値については、「設定」セクションを参照してください。
|UseParensForNegativeNumbers |オプション。 負の値をかっこで囲むかどうかを示す Tristate 定数です。 値については「設定値」を参照してください。
|GroupDigits |省略可能。 コンピューターの地域の設定で指定されている桁区切り記号を使用して数値を区切るかどうかを示す Tristate 定数です。 値については、「設定」セクションを参照してください。
|===

.設定

IncludeLeadingDigit、UseParensForNegativeNumbers、および GroupDigits 引数の設
定は次のとおりです。

[cols="1,4",options="header"]
|===
|定数 |値 |説明
|vbTrue |-1 |True
|vbFalse |.0 |False
|vbUseDefault |-2 |コンピューターの地域の設定を使用します。
|===

.解説

省略可能な引数を省略した場合は、コンピューターの地域の設定の値が使用されます。

CAUTION:	すべての設定情報について、[地域] の設定の [数値] タブの情報が
使用されます。

==== FormatPercent 関数[[FormatPercent]]

パーセンテージとして (100 倍して) 書式設定された式を、末尾に % 記号を追加して
返します。

.構文

[source,vbscript]
----
FormatPercent(Expression, [ NumDigitsAfterDecimal, [ IncludeLeadingDigit, [ UseParensForNegativeNumbers, [ GroupDigits ]]]])
----

FormatPercent 関数の構文には、次の指定項目があります。

[cols="1,4",options="header"]
|===
|パーツ |説明
|Expression |必須。 書式設定する式です。
|NumDigitsAfterDecimal |省略可能。 表示する小数点以下の桁数を示す数値です。 既定値は -1 です。これは、コンピューターの地域の設定が使用されることを示します。
|IncludeLeadingDigit |省略可能。 小数値に先頭のゼロを表示するかどうかを示す Tristate 定数です。 値については、「設定」セクションを参照してください。
|UseParensForNegativeNumbers |オプション。 負の値をかっこで囲むかどうかを示す Tristate 定数です。 値については「設定値」を参照してください。
|GroupDigits |省略可能。 コンピューターの地域の設定で指定されている桁区切り記号を使用して数値を区切るかどうかを示す Tristate 定数です。 値については、「設定」セクションを参照してください。
|===

.設定

IncludeLeadingDigit、UseParensForNegativeNumbers、および GroupDigits 引数の設
定は次のとおりです。

[cols="2,1,4",options="header"]
|===
|定数 |値 |説明
|vbTrue |-1 |True
|vbFalse |.0 |False
|vbUseDefault |-2 |コンピューターの地域の設定を使用します。
|===

.解説

省略可能な引数を省略した場合は、コンピューターの地域の設定の値が使用されます。

CAUTION:	すべての設定情報について、[地域] の設定の [数値] タブの情報が
使用されます。


==== FreeFile 関数[[FreeFile]]

<<Open,Open>> ステートメントで使用できる次のファイル番号を表す Integer を返します。

.構文

[source,vbscript]
----
FreeFile [ (rangenumber) ]
----

オプションの rangenumber 引数は、どの範囲から次の空きファイル番号を返すかを指
定する Variant です。 0 (既定値) を指定すると 1 以上 255 以下の範囲のファイル
番号を返します。 1 を指定すると 256 以上 511 以下の範囲のファイル番号を返しま
す。

.解説

まだ使用されていないファイル番号を提供するには、FreeFile を使用します。

.例

この例では、FreeFile 関数を使用して、次に使用可能なファイル番号を返します。 ル
ープ内では 5 個のファイルが出力用に開かれ、サンプル データが各ファイルに書き込
まれています。

[source,vbscript]
----
Dim MyIndex, FileNumber
For MyIndex = 1 To 5    ' Loop 5 times.
    FileNumber = FreeFile    ' Get unused file
        ' number.
    Open "TEST" & MyIndex For Output As #FileNumber    ' Create file name.
    Write #FileNumber, "This is a sample."    ' Output text.
    Close #FileNumber    ' Close file.
Next MyIndex
----

==== FV 関数[[FV]]

定額の支払いを定期的に行い、利率が一定であると仮定して投資の将来価値を指定する
Double を返します。

.構文

[source,vbscript]
----
FV(rate, nper, pmt, [ pv, [ type ]])
----

FV 関数には、次の名前付き引数があります。

[cols="1,4",options="header"]
|===
|パーツ |説明
|rate |必須です。 投資の利率を示す倍精度浮動小数点型 ( Double ) の値を指定します。 たとえば、年利 (APR) 10% の自動車ローンを利用して月払いで返済を行う場合、利率は 0.1/12 = 0.0083 になります。
|nper |必須。 投資期間全体での支払回数の合計を示す整数型 ( Integer) の値を指定します。 たとえば、4 年間の自動車ローンを利用して月払いで返済を行う場合、このローンの支払回数の合計は 4 * 12 = 48 となります。
|pmt |必須。 毎回の支払額を指定する Double。 通常、支払額には元金と利息が含まれます。投資期間内に支払額が変更されることはありません。
|pv |省略可能。 現在価値、つまり将来行われる一連の支払を現時点で一括払いした場合の合計金額を示すバリアント型 ( Variant) の値を指定します。 たとえば、車を購入するために資金を借りる場合、ローンの総額が、貸方に対する現在価値となります。 省略すると、0 を指定したものと見なされます。
|type |省略可能。 支払期日を示すバリアント型 ( Variant ) の値を指定します。 各期の期末に支払う場合は 0、各期の期首に支払う場合は 1 を指定します。 省略すると、0 と見なされます。
|===

.解説

投資とは、一連の定額の支払いを一定期間にわたって行うことです。 投資には、住宅
ローンなどのローンや、毎月の貯蓄プランなどの出資があります。

引数rate と nper は、同じ単位で表した支払期間を使用して計算する必要があります。
たとえば、rate を月単位で計算する場合は、nper も月単位で計算する必要があります。

すべての引数に関して、定額預金の支払いのような出金は負の数で表し、配当金のよう
な入金は正の数で表します。

.例

次の例では、FV 関数を使用して投資の将来価値を返します。利率 (APR / 12)、支払回
数の合計 (TotPmts)、支払額 (Payment)、投資の現在価値 (PVal)、および支払が期首
に行われるか期末に行われるかを示す数値 (PayType) を指定します。 Paymentは出金
を表すので、負の値です。


[source,vbscript]
----
Dim Fmt, Payment, APR, TotPmts, PayType, PVal, FVal
Const ENDPERIOD = 0, BEGINPERIOD = 1    ' When payments are made.
Fmt = "###,###,##0.00"    ' Define money format.
Payment = InputBox("How much do you plan to save each month?")
APR = InputBox("Enter the expected interest annual percentage rate.")
If APR > 1 Then APR = APR / 100    ' Ensure proper form.
TotPmts = InputBox("For how many months do you expect to save?")
PayType = MsgBox("Do you make payments at the end of month?", vbYesNo)
If PayType = vbNo Then PayType = BEGINPERIOD Else PayType = ENDPERIOD
PVal = InputBox("How much is in this savings account now?")
FVal = FV(APR / 12, TotPmts, -Payment, -PVal, PayType)
MsgBox "Your savings will be worth " & Format(FVal, Fmt) & "."
----

==== GetAllSettings 関数[[GetAllSettings]]


Windows レジストリのアプリケーションのエントリまたはアプリケーションの初期化フ
ァイルの情報 (Macintosh の場合) から、キー設定のリストと各キー設定の値
(SaveSetting を使用して作成されたもの) を返します。

.構文

[source,vbscript]
----
GetAllSettings(appname, section)
----

GetAllSettings 関数の構文には、次の名前付き引数があります。

[source,vbscript]
----
パーツ 	説明
appname 	必須です。 キー設定が要求されているアプリケーションまたはプロジェクトの名前を含む文字列式です。 これは、Macintosh では System フォルダー内の Preferences フォルダーにある初期化ファイルのファイル名です。
section 	必須。 キー設定が要求されているセクションの名前を含む文字列式です。 GetAllSettings からは、指定したセクションのすべてのキー設定とそれに対応する値を含む文字列の 2 次元配列のコンテンツを持つ Variant が返されます。
----

.解説

GetAllSettings では、appname または section のいずれかが存在しない場合、初期化
されていない Variant を返します。

.例

この例では、最初に SaveSetting ステートメントを使用して、appname として指定さ
れたアプリケーションの Windows レジストリにエントリを作成し、GetAllSettings 関
数を使用して、設定を表示します。 アプリケーション名と section の名前は、
GetAllSettings で取得することはできないので、ご注意ください。 最後に、
DeleteSetting ステートメントは、アプリケーションのエントリを削除します。


[source,vbscript]
----
' Variant to hold 2-dimensional array returned by GetAllSettings
' Integer to hold counter.
Dim MySettings As Variant, intSettings As Integer
' Place some settings in the registry.
SaveSetting appname := "MyApp", section := "Startup", _
key := "Top", setting := 75
SaveSetting "MyApp","Startup", "Left", 50
' Retrieve the settings.
MySettings = GetAllSettings(appname := "MyApp", section := "Startup")
    For intSettings = LBound(MySettings, 1) To UBound(MySettings, 1)
        Debug.Print MySettings(intSettings, 0), MySettings(intSettings, 1)
    Next intSettings
DeleteSetting "MyApp", "Startup"
----

==== GetAttr 関数[[GetAttr]]

ファイル、ディレクトリ、またはフォルダーの属性を表す Integer を返します。

.構文

[source,vbscript]
----
GetAttr(pathname)
----

必須の pathname 引数は、ファイル名を指定する文字列式です。 pathname には、ディ
レクトリまたはフォルダー、およびドライブを含めることができます。

.戻り値

GetAttr では、次の属性の値の合計が返されます。

[cols="2,1,4",options="header"]
|===
|定数 |値 |説明
|vbNormal |.0 |標準
|vbReadOnly |1-d |読み取り専用。
|vbHidden |pbm-2 |非表示。
|vbSystem |2/4 |システム ファイル。 Macintosh では使用できません。
|vbDirectory |16 |ディレクトリまたはフォルダー
|vbArchive |32 |前回のバックアップ以降にファイルが変更されています。 Macintosh では使用できません。
|vbAlias |64 |指定されたファイル名はエイリアスです。 Macintosh でのみ使用できます。
|===

CAUTION:	これらの定数は Visual Basic for Applications により指定されま
す。 これらの名前は、実際の値の代わりにコードのどの部分でも使用できます。



.解説

設定されている属性を確認するには、And 演算子を使用して ビット単位の比較を行い、
GetAttr 関数から返される値と目的の個々のファイル属性の値を比較します。 結果が
0 以外の場合は、指定したファイルに対してその属性が設定されています。 たとえば、
Archive 属性が設定されていない場合、次の And 式の戻り値は 0 です。


[source,vbscript]
----
Result = GetAttr(FName) And vbArchive
----

Archive 属性が設定されている場合は、0 以外の値が返されます。

.例

この例では、GetAttr 関数を使用して、ファイルとディレクトリまたはフォルダーの属
性を確認します。 Macintosh では、定数 vbNormal、vbReadOnly、vbHidden、および
vbAlias のみが使用できます。


[source,vbscript]
----
Dim MyAttr
' Assume file TESTFILE has hidden attribute set.
MyAttr = GetAttr("TESTFILE")    ' Returns 2.

' Returns nonzero if hidden attribute is set on TESTFILE.
Debug.Print MyAttr And vbHidden    

' Assume file TESTFILE has hidden and read-only attributes set.
MyAttr = GetAttr("TESTFILE")    ' Returns 3.

' Returns nonzero if hidden attribute is set on TESTFILE.
Debug.Print MyAttr And (vbHidden + vbReadOnly)    

' Assume MYDIR is a directory or folder.
MyAttr = GetAttr("MYDIR")    ' Returns 16.
----

==== GetObject 関数[[GetObject]]


ActiveX コンポーネントから提供されたオブジェクトの参照を返します。

.構文

[source,vbscript]
----
GetObject([ pathname ], [ class ])
----

GetObject 関数の構文に使用される名前付き引数は次のとおりです。

[cols="1,4",options="header"]
|===
|パーツ |説明
|pathname |省略可能。Variant (String)。 取得するオブジェクトを含むファイルの完全パスと名前。 pathname を省略する場合は、class を指定する必要があります。
|class |省略可能。Variant (String)。 オブジェクトの クラスを表す文字列。
|===

class 引数の構文は appname.objecttype で、指定項目は次のとおりです。

[cols="1,4",options="header"]
|===
|指定項目 |説明
|appname |必須。Variant (String)。 オブジェクトを提供するアプリケーションの名前。
|objecttype |必須。Variant (String)。 作成するオブジェクトの型またはクラス。
|===

.解説

GetObject 関数は、ファイルから ActiveX オブジェクトにアクセスして、そのオブジ
ェクトをオブジェクト変数に割り当てるために使用されます。 GetObject で返された
オブジェクトをオブジェクト変数に割り当てるには、<<Set,Set>> ステートメントを使
用します。

.例:


[source,vbscript]
----
Dim CADObject As Object
Set CADObject = GetObject("C:\CAD\SCHEMA.CAD")
----

このコードを実行すると、指定した pathname に関連付けられたアプリケーションが起
動され、指定したファイル内のオブジェクトがアクティブ化されます。

pathname が長さ 0 の文字列 ("") である場合、GetObject は、指定した型の新しいオ
ブジェクト インスタンスを戻します。 pathname 引数を省略した場合、GetObject は、
指定した型の現在アクティブなオブジェクトを返します。 指定した型のオブジェクト
が存在しない場合は、エラーが発生します。

一部のアプリケーションでは、ファイルの一部をアクティブ化することができます。
ファイル名の末尾に感嘆符 (!) を付け、アクティブ化するファイルの部分を識別する
文字列を続けます。 この文字列の作成方法については、オブジェクトを作成したアプ
リケーションのドキュメントを参照してください。

たとえば、描画アプリケーションでは、図面の複数のレイヤーがファイルに保存されて
いる場合があります。 次のコードを使用して、SCHEMA.CAD という図面内のレイヤーを
アクティブ化することができます。


[source,vbscript]
----
Set LayerObject = GetObject("C:\CAD\SCHEMA.CAD!Layer3")
----

オブジェクトの class を指定しない場合、起動するアプリケーションとアクティブ化
するオブジェクトは、指定したファイル名に基づいて自動的に決定されます。 ただし、
一部のファイルは複数のクラスのオブジェクトをサポートしている場合があります。
たとえば、1 つの図面が 3 つの異なる型のオブジェクト (Application オブジェクト、
Drawing オブジェクト、Toolbar オブジェクト) をサポートし、すべてが同じファイル
に含まれている場合があります。 ファイル内のアクティブ化するオブジェクトを指定
するには、省略可能な class 引数を使用します。 次に例を示します。


[source,vbscript]
----
Dim MyObject As Object
Set MyObject = GetObject("C:\DRAWINGS\SAMPLE.DRW", "FIGMENT.DRAWING")
----

この例で、FIGMENT は描画アプリケーションの名前で、DRAWING は、サポートされるオ
ブジェクトの型のいずれかです。 オブジェクトがアクティブ化されたら、定義したオ
ブジェクト変数を使用して、コード内でオブジェクトを参照します。 前の例では、オ
ブジェクト変数_MyObject_を使用して、新しいオブジェクトのプロパティとメソッドに
アクセスします。 次に例を示します。


[source,vbscript]
----
MyObject.Line 9, 90
MyObject.InsertText 9, 100, "Hello, world."
MyObject.SaveAs "C:\DRAWINGS\SAMPLE.DRW"
----

CAUTION:	GetObject 関数は、オブジェクトの現在のインスタンスがある場合、
または既にファイルが読み込まれた状態でオブジェクトを作成する場合に使用します。
現在のインスタンスがなく、ファイルが読み込まれた状態でオブジェクトを起動しない
場合は、<<CreateObject,CreateObject>> 関数を使用します。



オブジェクトが単一インスタンスのオブジェクトとして登録されている場合は、
CreateObject を何回実行しても、そのオブジェクトのインスタンスは 1 つしか作成さ
れません。 単一インスタンスのオブジェクトの場合、長さ 0 の文字列 ("") 構文で呼
び出されると、GetObject は常に同じインスタンスを返します。また、pathname 引数
が省略された場合、エラーが発生します。 GetObject を使用して、Visual Basic で作
成されたクラスに対する参照を取得することはできません。

.例

次の例では、GetObject 関数を使用して特定の Microsoft Excel ワークシート (MyXL)
に対する参照を取得します。 ワークシートの Application プロパティを使用して、
Excel の表示や終了などの操作を行います。

DetectExcel Sub プロシージャは 2 つの API 呼び出しを使用して Microsoft Excel
を検索し、実行中の場合は、Running Object テーブルに入力します。

Microsoft Excel がまだ実行されていない場合、GetObject の 1 回目の呼び出しによ
ってエラーが発生します。 この例では、このエラーによって ExcelWasNotRunning フ
ラグが True に設定されます。

GetObject の 2 回目の呼び出しでは、開くファイルを指定します。 Microsoft Excel
がまだ実行されていない場合は、2 回目の呼び出しで起動され、指定したファイル
(mytest.xls) が示すワークシートに対する参照を返します。 ファイルは指定した場所
に存在する必要があります。存在しない場合、Visual Basic エラーの Automation
error が生成されます。

このコード例では、次に、指定したワークシートを含む Microsoft Excel とウィンド
ウの両方が表示されるようになります。 最後に、以前のバージョンの Microsoft
Excel が実行中ではない場合、このコードでは Application オブジェクトの Quit メ
ソッドを使用して Microsoft Excel を終了します。 アプリケーションが既に実行中の
場合、アプリケーションを閉じる処理は試行されません。 参照自体は、Nothing に設
定することで解放されます。


[source,vbscript]
----
' Declare necessary API routines:
Declare Function FindWindow Lib "user32" Alias _
"FindWindowA" (ByVal lpClassName as String, _
                    ByVal lpWindowName As Long) As Long

Declare Function SendMessage Lib "user32" Alias _
"SendMessageA" (ByVal hWnd as Long,ByVal wMsg as Long, _
                    ByVal wParam as Long, _
                    ByVal lParam As Long) As Long

Sub GetExcel()
    Dim MyXL As Object    ' Variable to hold reference
                                ' to Microsoft Excel.
    Dim ExcelWasNotRunning As Boolean    ' Flag for final release.

' Test to see if there is a copy of Microsoft Excel already running.
    On Error Resume Next    ' Defer error trapping.
' Getobject function called without the first argument returns a 
' reference to an instance of the application. If the application isn't
' running, an error occurs.
    Set MyXL = Getobject(, "Excel.Application")
    If Err.Number <> 0 Then ExcelWasNotRunning = True
    Err.Clear    ' Clear Err object in case error occurred.

' Check for Microsoft Excel. If Microsoft Excel is running,
' enter it into the Running Object table.
    DetectExcel

' Set the object variable to reference the file you want to see.
    Set MyXL = Getobject("c:\vb4\MYTEST.XLS")

' Show Microsoft Excel through its Application property. Then
' show the actual window containing the file using the Windows
' collection of the MyXL object reference.
    MyXL.Application.Visible = True
    MyXL.Parent.Windows(1).Visible = True
     Do manipulations of your  file here.
    ' ...
' If this copy of Microsoft Excel was not running when you
' started, close it using the Application property's Quit method.
' Note that when you try to quit Microsoft Excel, the
' title bar blinks and a message is displayed asking if you
' want to save any loaded files.
    If ExcelWasNotRunning = True Then 
        MyXL.Application.Quit
    End IF

    Set MyXL = Nothing    ' Release reference to the
                                ' application and spreadsheet.
End Sub

Sub DetectExcel()
' Procedure dectects a running Excel and registers it.
    Const WM_USER = 1024
    Dim hWnd As Long
' If Excel is running this API call returns its handle.
    hWnd = FindWindow("XLMAIN", 0)
    If hWnd = 0 Then    ' 0 means Excel not running.
        Exit Sub
    Else                
    ' Excel is running so use the SendMessage API 
    ' function to enter it in the Running Object Table.
        SendMessage hWnd, WM_USER + 18, 0, 0
    End If
End Sub
----

==== GetSetting 関数[[GetSetting]]


Windows レジストリ内のアプリケーションのエントリ、または (Macintosh 上の) アプ
リケーションの初期化ファイル内の情報から、キー設定値を返します。

.構文

[source,vbscript]
----
GetSetting(appname, section, key, [ default ])
----

GetSetting 関数の構文には、次の名前付き引数があります。

[cols="1,4",options="header"]
|===
|パーツ |説明
|appname |必須です。 キー設定が要求されているアプリケーションまたはプロジェクトの名前を含む文字列式です。 これは、Macintosh では System フォルダー内の Preferences フォルダーにある初期化ファイルのファイル名です。
|section |必須です。 キー設定を検索するセクションの名前を含む文字列式です。
|key |必須。 返すキー設定の名前を含む文字列式です。
|default |省略可能。 キー設定に値が設定されていない場合、返す値を含む式です。 省略すると、default で、長さ 0 の文字列 ("") があると見なされます。
|===

.解説

GetSetting 引数で名付けられたアイテムが存在しない場合、GetSetting は、default
の値を返します。

.例

この例では、最初に <<SaveSetting,SaveSetting>> ステートメントを使用して、
appname として指定されたアプリケーションの Windows レジストリ (または 16 ビッ
ト版 Windows プラットフォームの .ini ファイル) にエントリを作成し、GetSetting
関数を使用して、設定のうちの 1 つを表示します。 default 引数が指定されているた
め、何らかの値が返されることが保証されています。 section 名は、GetSetting で取
得することはできないので、ご注意ください。 最後に、<<DeleteSetting,
DeleteSetting>> ステートメントは、アプリケーションのエントリをすべて削除します。


[source,vbscript]
----
' Variant to hold 2-dimensional array returned by GetSetting.
Dim MySettings As Variant
' Place some settings in the registry.
SaveSetting "MyApp","Startup", "Top", 75
SaveSetting "MyApp","Startup", "Left", 50

Debug.Print GetSetting(appname := "MyApp", section := "Startup", _
                       key := "Left", default := "25")

DeleteSetting "MyApp", "Startup"
----

==== Hour 関数[[Hour]]


1 日の時間を表す 0 以上 23 以下の整数を指定する Variant (Integer) を返します。

.構文

[source,vbscript]
----
Hour(time)
----

必須の time 引数は、時間を表すことができる、任意の Variant、数式、文字列式、ま
たは任意の組み合わせです。 time に Null が含まれている場合は Null が返されます。

.例

この例では、Hour 関数を使用して、指定した時刻の時間を取得します。 開発環境では、
コードのロケール設定を使用して短い時刻形式で時刻リテラルが表示されます。


[source,vbscript]
----
Dim MyTime, MyHour
MyTime = #4:35:17 PM#    ' Assign a time.
MyHour = Hour(MyTime)    ' MyHour contains 16.
----





















★


















































=== タスク別のキーワード

[cols="1,4",options="header"]
|===
|カテゴリ |説明
|配列 |配列を作成、定義、使用します。
|コンパイラディレクティブ |コンパイラの動作を制御します。
|制御フロー |プロシージャのフローをループおよび制御します。
|変換 |数値とデータ型を変換します。
|データ型 |データ型およびバリアント サブタイプ。
|日付と時刻 |日付と時刻の式を変換および使用します。
|ディレクトリとファイル |ファイル システムを制御し、ファイルを処理します。
|エラー |エラー値をトラッピングして返します。
|財務 |財務計算を実行します。
|入力と出力 |入力を受け取って、出力を表示または印刷します。
|算術 |三角関数およびその他の算術計算を実行します。
|その他 |他のアプリケーションを開始し、イベントを処理します。
|演算子 |式の比較および他の操作を行います。
|レジストリ |プログラムの設定を管理する。
|文字列の操作 |文字列および文字列型データを操作します。
|変数と定数 |変数および定数を宣言および定義します。
|===

==== キーワード (Visual Basic for Applications)

[cols="1,4",options="header"]
|===
|キーワード |使用されるコンテキスト
|As |Const ステートメント +
Declare ステートメント +
Dim ステートメント +
Function ステートメント +
Name ステートメント +
Open ステートメント +
Private ステートメント +
Property Get ステートメント +
Property Let ステートメント +
Property Set ステートメント +
Public ステートメント +
ReDim ステートメント +
Static ステートメント +
Sub ステートメント +
Type ステートメント
|Binary |Open ステートメント +
Option Compare ステートメント
|ByRef |Call ステートメント +
Declare ステートメント +
Function ステートメント +
Property Get ステートメント +
Property Let ステートメント +
Property Set ステートメント +
Sub ステートメント
|ByVal |Call ステートメント +
Declare ステートメント +
Function ステートメント +
Property Get ステートメント +
Property Let ステートメント +
Property Set ステートメント +
Sub ステートメント
|Date |Date データ型 +
Date 関数 +
Date ステートメント
|Else |If...Then...Else ステートメント +
Select Case ステートメント
|Empty |初期化されていない変数値を示す Variant サブタイプとして使用されます。
|Error |Error 関数 +
Error ステートメント +
On Error ステートメント
|False |値は 0 です。
|For |For...Next ステートメント +
For Each...Next ステートメント +
Open ステートメント
|Friend |「Friend」をご覧ください。
|Get |Get ステートメント +
Property Get ステートメント
|Input |Input 関数 +
Input # ステートメント +
Line Input # ステートメント +
Open ステートメント
|Is |If...Then...Else ステートメント +
Is 演算子 +
Select Case ステートメント
|Len |Len 関数 +
Open ステートメント
|Let |Let ステートメント +
Property Let ステートメント
|Lock |Lock、Unlock ステートメント +
Open ステートメント
|Me |「Me」をご覧ください。
|Mid |Mid 関数 +
Mid ステートメント
|New |Dim ステートメント +
Private ステートメント +
Public ステートメント +
Set ステートメント +
Static ステートメント
|Next |For...Next ステートメント +
For Each...Next ステートメント +
On Error ステートメント +
Resume ステートメント
|Nothing |「Nothing」をご覧ください。
|Null |変数に有効な値が含まれないことを示す Variant サブタイプとして使用されます。
|On |On Error ステートメント +
On...GoSub ステートメント +
On...GoTo ステートメント
|Option |Option Base ステートメント +
Option Compare ステートメント +
Option Explicit ステートメント +
Option Private ステートメント
|Optional |Declare ステートメント +
Function ステートメント +
Property Get ステートメント +
Property Let ステートメント +
Property Set ステートメント +
Sub ステートメント
|ParamArray |Declare ステートメント +
Function ステートメント +
Property Get ステートメント +
Property Let ステートメント +
Property Set ステートメント +
Sub ステートメント
|Print |Print メソッド +
Print # ステートメント
|Private |Const ステートメント +
Declare ステートメント +
Enum ステートメント +
Function ステートメント +
Option Private ステートメント +
Private ステートメント +
Property Get ステートメント +
Property Let ステートメント +
Property Set ステートメント +
Sub ステートメント +
Type ステートメント
|Property |Property Get ステートメント +
Property Let ステートメント +
Property Set ステートメント
|PtrSafe |「PtrSafe」をご覧ください。
|Public |Const ステートメント +
Declare ステートメント +
Enum ステートメント +
Event ステートメント +
Function ステートメント +
Property Get ステートメント +
Property Let ステートメント +
Property Set ステートメント +
Public ステートメント +
Sub ステートメント +
Type ステートメント
|Resume |On Error ステートメント +
Resume ステートメント
|Seek |Seek 関数 +
Seek ステートメント
|Set |Set ステートメント +
Property Set ステートメント
|Static |Function ステートメント +
Property Get ステートメント +
Property Let ステートメント +
Property Set ステートメント +
Static ステートメント +
Sub ステートメント
|Step |For...Next ステートメント +
For Each...Next ステートメント
|String |String データ型 +
String 関数
|Then |If...Then...Else ディレクティブ +
If...Then...Else ステートメント
|Time |Time 関数 +
Time ステートメント
|To |Dim ステートメント +
For...Next ステートメント +
Lock、Unlock ステートメント +
Private ステートメント +
Public ステートメント +
ReDim ステートメント +
Select Case ステートメント +
Static ステートメント +
Type ステートメント
|True |値は -1 です。
|WithEvents |Dim ステートメント +
Private ステートメント +
||Public ステートメント
|===

===== Friend キーワード

フォームモジュールまたはクラスモジュールのプロシージャの定義を変更して、プロシ
ージャをクラスの外部のモジュールから呼び出し可能にします。ただし、クラスが定義
されているプロジェクトの一部である必要があります。 Friendプロシージャは標準モ
ジュールでは使用できません。

.構文

[source,vbscript]
----
[ Private | Friend | Public ] [ Static ] [ Sub | Function | Property ] procedurename
----

必須の __ procedurename は、プロジェクト全体で可視にされるプロシージャの名前で
すが、クラスのコントローラーには不可視となります。

.注釈

クラスのパブリックプロシージャは、クラスのインスタンスのコントローラーであって
も、どこからでも呼び出すことができます。 プロシージャをプライベートに宣言する
と、オブジェクトのコントローラーがプロシージャを呼び出せるようになります。また、
クラス自体が定義されているプロジェクト内からプロシージャを呼び出すこともできな
くなります。

Friendは、プロジェクト全体でプロシージャを参照できるようにしますが、オブジェク
トのインスタンスのコントローラーに対しては使用できません。 フレンドは、フォー
ムモジュールおよびクラスモジュールにのみ表示され、変数や型ではなく、プロシージ
ャ名のみを変更できます。 クラスのプロシージャは、プロジェクト内の他のすべての
クラスのFriendプロシージャにアクセスできます。 フレンドプロシージャは、そのク
ラスのタイプライブラリには表示されません。 Friendプロシージャは、遅延バインデ
ィングすることはできません。


.例

クラスモジュールに配置されると、次のコードによって、プロジェクト内のクラスのす
べてのユーザーがメンバー変数 dblBalance にアクセスできるようになります。 クラ
スのすべてのユーザーが値を取得できます。プロジェクト内のコードのみが、その変数
に値を割り当てることができます。

[source,vbscript]
----
Private dblBalance As Double 
 
Public Property Get Balance() As Double 
 Balance = dblBalance 
End Property 
 
Friend Property Let Balance(dblNewBalance As Double) 
 dblBalance = dblNewBalance 
End Property 
----

===== Me キーワード[[Me]]

Me キーワードは暗黙的に宣言された変数と同様に動作します。 クラス モジュール内
のすべてのプロシージャは、これを自動的に利用できます。

クラスに複数のインスタンスが含まれる可能性がある場合、Me を使用して、コードが
実行されているクラスの特定のインスタンスを参照できます。 現在実行されているク
ラスのインスタンスに関する情報を別のモジュール内のプロシージャに渡す場合、Me
を使用すると特に便利です。

たとえば、モジュールに以下のプロシージャが含まれているとします。


[source,vbscript]
----
Sub ChangeFormColor(FormName As Form) 
 FormName.BackColor = RGB(Rnd * 256, Rnd * 256, Rnd * 256) 
End Sub
----

以下のステートメントを使用し、このプロシージャを呼び出して Form クラスの現在の
インスタンスを引数として渡すことができます。

[source,vbscript]
----
ChangeFormColor Me 
----

===== Nothing キーワード[[Nothing]]

Nothing キーワードは、オブジェクト変数と実際のオブジェクトの関連付けを解除する
ために使用されます。 Nothingをオブジェクト変数に代入するには、 <<Set,Set>> ス
テートメントを使用します。 次に例を示します。


[source,vbscript]
----
Set MyObject = Nothing 
----

複数のオブジェクト変数が同じ実際のオブジェクトを参照していることがあります。
オブジェクト変数に Nothing を代入すると、その変数は実際のオブジェクトを参照し
なくなります。

複数のオブジェクト変数が同じオブジェクトを参照する場合、変数が参照するオブジェ
クトに関連付けられているメモリおよびシステムリソースは、 setを使用して明
示的に設定されているか、または暗黙的に設定されている場合にのみ解放されます。実
際のオブジェクトを参照している最後のオブジェクト変数がスコープ外になった後。

===== PtrSafe キーワード[[PtrSafe]]

PtrSafeキーワードは、次のコンテキストで使用されます。 Declare ステートメントで
す。

PtrSafe キーワードを含む Declare ステートメントが推奨される構文です。 PtrSafe
が含まれる Declare ステートメントが 32 ビットおよび 64 ビット プラットフォーム
の VBA7 開発環境で正常に機能するのは、64 ビット数を格納する必要がある Declare
ステートメント内のすべてのデータ型 (パラメーターおよび戻り値) が 64 ビット整数
用の LongLong またはポインターおよびハンドル用の LongPtr を使用するように更新
されている場合のみです。

VBA バージョン6以前との下位互換性を確保するには、次の構文を使用します。


[source,vbscript]
----
#If VBA7 Then 
Declare PtrSafe Sub... 
#Else 
Declare Sub... 
#EndIf
----

64ビットバージョンの Office で実行する場合、 DeclareステートメントにはPtrSafe
キーワードを含める必要があります。 PtrSafe キーワードは、Declare ステートメン
トを 64 ビットの開発環境で安全に実行できることを示すキーワードです。

DeclareステートメントにPtrSafeキーワードを追加した場合のみ、 declareステートメ
ントが明示的に64ビットを対象としていることを意味します。 64ビットを格納する必
要があるステートメント内のすべてのデータ型 (戻り値とパラメーターを含む) は、64
ビット積分またはLongPtrのポインターとハンドルに対してlonglongを使用して、64ビ
ットの数を保持するように変更する必要があります。







==== 配列キーワードの概要

[cols="4,4",options="header"]
|===
|Action |キーワード
|配列かどうかを確認します。 |<<IsArray,IsArray>>
|配列を作成します。 |<<Array,Array>>
|既定の下限を変更します。 |<<Option Base,Option Base>>
|配列を宣言および初期化します。 |<<Dim,Dim>>、<<Private,Private>>、<<Public,
Public>>、<<ReDim,ReDim>>、<<Static,Static>>
|配列の限界を調べます。 |<<LBound,LBound>>、<<UBound,UBound>>
|配列を再初期化します。 |<<Erase,Erase>>、<<ReDim,ReDim>>
|===

==== 制御フローキーワードの概要


[cols="4,4",options="header"]
|===
|Action |キーワード
|構内 |<<GoSub...Return,GoSub...Return>>、<<GoTo,GoTo>>、<<On Error,On Error>>、
<<On...GoSub,On...GoSub>>、<<On...GoTo,On...GoTo>>
|プログラムを終了または一時停止する |<<DoEvents,DoEvents>>、<<End,End>>、
<<Exit,Exit>>、<<Stop,Stop>>
|Loop |<<Do...Loop,Do...Loop>>、<<For...Next,For...Next>>、<<For Each...Next,
For Each...Next>>、<<While...Wend,While...Wend>>、<<With,With>>
|決定を行う |<<Choose,Choose>>、<<If...Then...Else,If...Then...Else>>、
<<Select Case,Select Case>>、<<Switch, Switch>>
|プロシージャを使用する |<<Call,Call>>、<<Function,Function>>、<<Property Get,
Property Get>>、
<<Property Let,Property Let>>、<<Property Set,Property Set>>、<<Sub,Sub>>
|===

==== 変換キーワードの概要


[cols="4,4",options="header"]
|===
|Action |キーワード
|ANSI 値を文字列に。 |<<Chr,Chr>>
|文字列を小文字または大文字に。 |<<Format,Format>>、<<LCase,LCase>>、<<Ucase,
Ucase>>
|日付をシリアル値に。 |<<DateSerial,DateSerial>>、<<DateValue,DateValue>>
|10 進数を他の基数に。 |<<Hex,Hex>>、<<Oct,Oct>>
|数値を文字列に。 |<<Format,Format>>、<<Str,Str>>
|あるデータ型を別のデータ型に。 |<<データ型の概要,データ型の概要>>を参照してください。
|日付を日、月、週、または年に。 |<<Day,Day>>、<<Month,Month>>、<<Weekday,
Weekday>>、<<Year,Year>>
|時刻を時、分、または秒に。 |<<Hour,Hour>>、<<Minute,Minute>>、<<Second,
Second>>
|文字列を ASCII 値に。 |<<Asc,Asc>>
|文字列を数値に。 |<<Val,Val>>
|時刻をシリアル値に。 |<<TimeSerial,TimeSerial>>、<<TimeValue,TimeValue>>
|===


==== 日付と時刻のキーワード サマリー


[cols="4,4",options="header"]
|===
|アクション |キーワード
|現在の日付または時刻を取得します。 |<<Date,Date>>、<<Now,Now>>、<<Time,Time>>
|日付の計算を実行します。 |<<DateAdd,DateAdd>>、<<DateDiff,DateDiff>>、
<<DatePart,DatePart>>
|日付を返します。 |<<DateSerial,DateSerial>>、<<DateValue,DateValue>>
|時刻を返します。 |<<TimeSerial,TimeSerial>>、<<TimeValue,TimeValue>>
|日付または時刻を設定します。 |<<Date,Date>>、<<Time,Time>>
|処理時間を計測します。 |<<Timer,Timer>>
|===


==== ディレクトリとファイルのキーワード サマリー

[cols="4,4",options="header"]
|===
|Action |キーワード
|ディレクトリまたはフォルダーを変更します。 |<<ChDir,ChDir>>
|ドライブを変更します。 |<<ChDrive,ChDrive>>
|ファイルをコピーします。 |<<FileCopy,FileCopy>>
|ディレクトリまたはフォルダーを作成します。 |<<MkDir,MkDir>>
|ディレクトリまたはフォルダーを削除します。 |<<RmDir,RmDir>>
|ファイル、ディレクトリ、またはフォルダーの名前を変更します。 |<<Name,Name>>
|現在のパスを取得します。 |<<CurDir,CurDir>>
|ファイルの日付/時刻スタンプを取得します。 |<<FileDateTime,FileDateTime>>
|ファイル、ディレクトリ、ラベルの属性を取得します。 |<<GetAttr,GetAttr>>
|ファイルの長さを取得します。 |<<FileLen,FileLen>>
|ファイル名またはボリューム ラベルを取得します。 |<<Dir,Dir>>
|ファイルの属性情報を設定します。 |<<SetAttr,SetAttr>>
|===



==== エラー キーワード サマリー



[cols="4,4",options="header"]
|===
|Action |キーワード
|実行時エラーを生成する。 |<<Clear,Clear>>、<<Error,Error>>、<<Raise,Raise>>
|エラー メッセージを取得する。 |<<Error,Error>>
|エラー情報を提供する。 |<<Err,Err>>
|Error バリアントを返す。 |<<CVErr,CVErr>>
|実行時にエラーをトラップする。 |<<On Error,On Error>>、<<Resume,Resume>>
|検証を入力する。 |<<IsError,IsError>>
|===

==== 財務キーワードの概要


[cols="4,4",options="header"]
|===
|Action |キーワード
|減価償却費の計算 |<<DDB,DDB>>、<<SLN,SLN>>、<<SYD,SYD>>
|将来価値の計算 |<<FV,FV>>
|利率の計算 |<<Rate,Rate>>
|内部利益率の計算 |<<IRR,IRR>>、<<MIRR,MIRR>>
|期間数の計算 |<<NPer,NPer>>
|支払い額の計算 |<<IPmt,IPmt>>、<<Pmt,Pmt>>、<<PPmt,PPmt>>
|現在価値の計算 |<<NPV,NPV>>、<<PV,PV>>
|===


==== 入力と出力のキーワードの概要



[cols="4,4",options="header"]
|===
|Action |キーワード
|ファイルにアクセスするかファイルを作成します。 |<<Open,Open>>
|ファイルを閉じます。 |<<Close,Close>>、<<Reset,Reset>>
|出力の表示を管理します。 |<<Format,Format>>、<<Print,Print>>、
<<Print #,Print #>>、<<Spc,Spc>>、<<Tab,Tab>>、<<Width #,Width #>>
|ファイルをコピーします。 |<<FileCopy,FileCopy>>
|ファイルに関する情報を取得します。 |<<EOF,EOF>>、<<FileAttr,FileAttr>>、
<<FileDateTime,FileDateTime>>、<<FileLen,FileLen>>、<<FreeFile,FreeFile>>、
<<GetAttr,GetAttr>>、<<Loc,Loc>>、<<LOF,LOF>>、<<Seek,Seek>>
|ファイルを管理します。 |<<Dir,Dir>>、<<Kill,Kill>>、<<Lock,Lock>>、<<Unlock,
Unlock>>、<<Name,Name>>
|ファイルを読み取ります。 |<<Get,Get>>、<<Input,Input>>、<<Input #,Input #>>、
<<Line Input #,Line Input #>>
|ファイルの長さを返します。 |<<FileLen,FileLen>>
|ファイル属性を設定または取得します。 |<<FileAttr,FileAttr>>、 <<GetAttr,
GetAttr>>、 <<SetAttr,SetAttr>>
|ファイル内の読み取り/書き込み位置を設定します。 |<<Seek,Seek>>
|ファイルに書き込みます。 |<<Print #,Print #>>、<<Put,Put>>、
<<Write #,Write #>>
|===



==== 数学キーワード サマリー


[cols="4,4",options="header"]
|===
|アクション |キーワード
|三角関数を派生させる。 |<<Atn,Atn>>、<<Cos,Cos>>、<<Sin,Sin>>、<<Tan,Tan>>
|一般的な計算。 |<<Exp,Exp>>、<<Log,Log>>、<<Sqr,Sqr>>
|乱数を生成する。 |<<Randomize,Randomize>>、<<Rnd,Rnd>>
|絶対値を取得する。 |<<Abs,Abs>>
|式の符号を取得する。 |<<Sgn,Sgn>>
|数値変換を実行する。 |<<Fix,Fix>>、<<Int,Int>>
|===



==== その他のキーワード サマリー


[cols="4,4",options="header"]
|===
|アクション |キーワード
|保留中のイベントを処理する。 |<<DoEvents,DoEvents>>
|他のプログラムを実行する。 |<<AppActivate,AppActivate>>、<<Shell,Shell>>
|キー操作をアプリケーションへ送信する。 |<<SendKeys,SendKeys>>
|コンピューターから警告音を鳴らす。 |<<Beep,Beep>>
|システム |<<Environ,Environ>>
|コマンド ライン文字列を提供する。 |<<Command,Command>>
|オートメーション |<<CreateObject,CreateObject>>、<<GetObject,GetObject>>
|色 |<<QBColor,QBColor>>、<<RGB,RGB>>
|===


==== レジストリ キーワードの概要


[cols="4,4",options="header"]
|===
|Action |キーワード
|プログラムの設定を削除します。 |<<DeleteSetting,DeleteSetting>>
|プログラムの設定を読み込みます。 |<<GetSetting,GetSetting>>、<<GetAllSettings,
GetAllSettings>>
|プログラムの設定を保存します。 |<<SaveSetting,SaveSetting>>
|===



==== 文字列操作キーワードの概要


[cols="4,4",options="header"]
|===
|Action |キーワード
|2 個の文字列を比較します。 |<<StrComp,StrComp>>
|文字列を変換します。 |<<StrConv,StrConv>>
|小文字または大文字に変換します。 |<<Format,Format>>、<<Lcase,Lcase>>、<<Ucase,
Ucase>>
|文字を繰り返し並べた文字列を作成します。 |<<Space,Space>>、<<String,String>>
|文字列の長さを検索します。 |<<Len,Len>>
|文字列の書式設定を行います。 |<<Format,Format>>
|文字列を中央に配置します。 |<<LSet,LSet>>、<<Rset,Rset>>
|文字列を操作します。 |<<InStr,InStr>>、<<Left,Left>>、<<LTrim,LTrim>>、
<<Mid,Mid>>、<<Right,Right>>、<<RTrim,RTrim>>、<<Trim,Trim>>
|文字列の比較規則を設定します。 |<<Option Compare,Option Compare>>
|ASCII 値および ANSI 値を使用します。 |<<Asc,Asc>>、<<Chr,Chr>>
|===


==== 変数と定数のキーワード サマリー


[cols="1,4",options="header"]
|===
|Action |キーワード
|値の代入 |<<Let,Let>>
|変数または定数の宣言 |<<Const,Const>>、<<Dim,Dim>>、<<Private,Private>>、
<<Public,Public>>、<<New,New>>、<<Static,Static>>
|モジュールをプライベートとして宣言 |
<<Option Private Module,Option Private Module>>
|変数に関する情報の取得 |<<IsArray,IsArray>>、 <<IsDate,IsDate>>、 <<IsEmpty,
IsEmpty>>、 <<IsError,IsError>>、 <<IsMissing,IsMissing>>、 <<IsNull,IsNull>>、
<<IsNumeric,IsNumeric>>、 <<isobject,isobject>>、 <<TypeName,TypeName>>、
<<VarType,VarType>>
|現在のオブジェクトの参照 |<<Me,Me>>
|変数の明示的宣言を要求 |<<Option Explicit,Option Explicit>>
|既定のデータ型の設定 |<<Deftype,Deftype>>
|===

=== Microsoft Forms リファレンス

=== オブジェクト (Visual Basic for Applications)

==== Err オブジェクト

実行時エラーに関する情報が含まれます。

.解説

Err オブジェクトのプロパティは、エラーの生成元 (Visual Basic、オブジェクト、ま
たはプログラマー) によって設定されます。

Err オブジェクトの既定のプロパティは、Number です。 既定のプロパティはオブジェ
クト名 Err で表すことができるので、Err 関数または Err ステートメントを使用して
作成された以前のコードを変更する必要はありません。

実行時エラーが発生すると、Err オブジェクトのプロパティには、エラーを一意に示す
情報およびエラーの処理に使用できる情報が設定されます。 コードで実行時エラーを
生成するには、Raise メソッドを使用します。

Err オブジェクトのプロパティは、エラー処理ルーチン内の Exit Sub、Exit Function、
Exit Property、または Resume Next ステートメントの後で 0 または長さ 0 の文字列
("") にリセットされます。 エラー処理ルーチン外で Resume ステートメントのいずれ
かの形式を使用した場合、Err オブジェクトのプロパティはリセットされません。 Err
を明示的にリセットするには、Clear メソッドを使用できます。

システム エラーおよびクラス モジュールに実行時エラーを生成するには、Error ステ
ートメントではなく Raise メソッドを使用します。 他のコードでの Raise メソッド
の使用は、返す必要のある情報量によって異なります。

Err オブジェクトは、グローバルなスコープの組み込みオブジェクトです。 コード内
にそのインスタンスを作成する必要はありません。

.例

この例では、Err オブジェクトのプロパティ (Number、Description、 HelpContext、
HelpFile、 Source) を使用して、エラー メッセージ ダイアログ ボックスを作成しま
す。

Clear メソッドを最初に使用すると、Visual Basic エラーを Raise メソッドで生成す
るときに、Visual Basic の既定値が Err オブジェクトのプロパティになることに注意
してください。


[source,vbscript]
----
Dim Msg
' If an error occurs, construct an error message
On Error Resume Next    ' Defer error handling.
Err.Clear
Err.Raise 6    ' Generate an "Overflow" error.
' Check for error, then show message.
If Err.Number <> 0 Then
    Msg = "Error # " & Str(Err.Number) & " was generated by " _
            & Err.Source & Chr(13) & Err.Description
    MsgBox Msg, , "Error", Err.Helpfile, Err.HelpContext
End If
----


==== メソッド
===== Clear メソッド

Err オブジェクトのプロパティ設定をすべて解除します。

.構文

[source,vbscript]
----
object.Clear
----

object は、常に Err オブジェクトです。

.解説

たとえば On Error Resume Next を使用してエラー処理の延期を使用する場合など、エ
ラーが処理された後に Err オブジェクトを明示的に解除するには Clear を使用します。
次のいずれかのステートメントが実行される場合は必ず、Clear メソッドが自動的に呼
び出されます。

* すべての種類の Resume ステートメント
* Exit Sub、Exit Function、Exit Property
* あらゆる On Error ステートメント


CAUTION:	他のオブジェクトへのアクセス時に発生したエラーを処理する場合、
On Error Goto より On Error Resume Next ステートメントの使用をお勧めします。
オブジェクトの操作後に Err を確認すると、エラーの発生時にコードがアクセスして
いたオブジェクトを明確にできます。 Err.Number にエラー コードを設定したオブジ
ェクトと、最初にエラーを生成したオブジェクト (Err.Source で指定されるオブジェ
クト) についても確認できます。



.例

この例では、Err オブジェクトの Clear メソッドを使用して Err オブジェクトの数値
プロパティーを 0 に、文字列プロパティーを長さ 0 の文字列にリセットします。 次
のコードから Clear を省略した場合は、(エラーの発生後に) ループが繰り返されるた
びに、2 回目以降の計算でエラーが生成されたかどうかには関係なく、エラー メッセ
ージのダイアログ ボックスが表示されます。 コードをシングル ステップで実行する
と効果を表示できます。


[source,vbscript]
----
Dim Result(10) As Integer    ' Declare array whose elements 
            ' will overflow easily.
Dim indx
On Error Resume Next    ' Defer error trapping.
Do Until indx = 10
    ' Generate an occasional error or store result if no error.
    Result(indx) = Rnd * indx * 20000
    If Err.Number <> 0 Then
        MsgBox Err, , "Error Generated: ", Err.HelpFile, Err.HelpContext
        Err.Clear    ' Clear Err object properties.
    End If
    indx = indx + 1
Loop
----

===== Raise メソッド


実行時エラーを生成します。

.構文

[source,vbscript]
----
object.Raise number, source, description, helpfile, helpcontext
----

Raise メソッドには、以下のオブジェクト修飾子および名前付き引数があります。

[cols="1,4",options="header"]
|===
|引数 |説明
|object |必須です。 常に、Err オブジェクトです。
|number |必須。 エラーの性質を識別する長整数型 (Long) です。 Visual Basic のエラー (Visual Basic で定義されたエラーおよびユーザーで定義されたエラー) は 0–65535 の値を使用します。 0–512 の値はシステム エラー用に予約されています。513–65535 の値は、ユーザー定義エラー用に使用できます。
|
|Number プロパティをクラス モジュール内で独自のエラー コードに設定する場合、エラー コード番号を vbObjectError 定数に加えます。 たとえば、 エラー番号 513 を生成するには、vbObjectError + 513 を **Number **プロパティに割り当てます。
|source |省略可能。 エラーを生成したオブジェクトまたはアプリケーションの名前を示す文字列式です。 Source プロパティをオブジェクトに対して設定する場合、project.class の形式を使用します。 source を指定しない場合、現在の Visual Basic プロジェクトのプログラム ID が使用されます。
|description |Optional. エラーを説明する文字列式です。 指定しない場合、Number の値が調べられます。 Visual Basic の実行時エラー コードにマップできる場合、Error 関数によって返される文字列が Description として使用されます。 Number に対応する Visual Basic エラーがない場合、"アプリケーション定義またはオブジェクト定義のエラーです。" というメッセージが使用されます。
|helpfile |省略可能。 このエラーに関するヘルプを確認できるヘルプ ファイルへの完全修飾パスです。 指定しない場合、Visual Basic では、完全修飾された、Visual Basic ヘルプ ファイルのドライブ、パス、およびファイル名が使用されます。 HelpFile を参照してください。
|helpcontext |省略可能。 エラーに関するヘルプを提供する helpfile 内のトピックを識別するコンテキスト ID です。 省略した場合、Number プロパティに対応するエラーに応じた、Visual Basic ヘルプ ファイルのコンテキスト ID が使用されます (存在する場合)。 HelpContext を参照してください。
|===

.解説

number 以外のすべての引数はオプションです。 一部の引数を指定しないで Raise を
使用し、Err オブジェクトのプロパティ設定にクリアされていない値が含まれる場合、
その値はエラーの値としての役割を果たします。

実行時エラーを生成するのに Raise を使用しますが、これを Error ステートメントの
代わりに使用することもできます。

クラス モジュールを記述する場合、エラーを生成するのに Raise が役立ちます。Err
オブジェクトでは、Error ステートメントでエラーを生成する場合に提供できる情報よ
りも豊富な情報が提供されるためです。 たとえば、Raise メソッドを使用すると、エ
ラーの生成元を Source プロパティに指定したり、エラーに関するオンライン ヘルプ
を参照したりできます。

.例

この例では、Err オブジェクトの Raise メソッドを使用し、Visual Basic で記述され
たオートメーション オブジェクト内でエラーを生成します。 このエラーには、
MyProj.MyObject というプログラム ID があります。 MacIntosh では、既定のドライ
ブ名は "HD" であり、パス名の部分はバックスラッシュではなくコロンで区切られます。


[source,vbscript]
----
Const MyContextID = 1010407    ' Define a constant for contextID.
Function TestName(CurrentName, NewName)
    If Instr(NewName, "bob") Then    ' Test the validity of NewName.
        ' Raise the exception
        Err.Raise vbObjectError + 513, "MyProj.MyObject", _
        "No ""bob"" allowed in your name", "c:\MyProj\MyHelp.Hlp", _
        MyContextID
    End If
End Function
----




=== 演算子の概要

=== Statements

<<AppActivate,AppActivate>>

<<Beep,Beep>>
<<Call,Call>>
<<ChDir,ChDir>>
<<ChDrive,ChDrive>>
<<Close,Close>>
<<Const,Const>>
<<Date,Date>>
<<Declare,Declare>>
<<Deftype,Deftype>>
<<DeleteSetting,DeleteSetting>>
<<Dim,Dim>>
<<Do...Loop,Do...Loop>>
<<End,End>>
<<Enum,Enum>>
<<Erase,Erase>>
<<Error,Error>>
<<Event,Event>>
<<Exit,Exit>>
<<FileCopy,FileCopy>>
<<For Each...Next,For Each...Next>>
<<For...Next,For...Next>>
<<Function,Function>>
<<Get,Get>>
<<GoSub...Return,GoSub...Return>>
<<GoTo,GoTo>>
<<If...Then...Else,If...Then...Else>>
<<Implements,Implements>>
<<Input #,Input #>>
<<Kill,Kill>>
<<Let,Let>>
<<Line Input #,Line Input #>>
<<Load,Load>>
<<Lock、Unlock,Lock、Unlock>>
<<LSet,LSet>>
<<Mid,Mid>>
<<MkDir,MkDir>>
<<Name,Name>>
<<On Error,On Error>>
<<On...GoSub、On...GoTo,On...GoSub、On...GoTo>>
<<Open,Open>>
<<Option Base,Option Base>>
<<Option Compare,Option Compare>>
<<Option Explicit,Option Explicit>>
<<Option Private,Option Private>>
<<Print #,Print #>>
<<Private,Private>>
<<Property Get,Property Get>>
<<Property Let,Property Let>>
<<Property Set,Property Set>>
<<Public,Public>>
<<Put,Put>>
<<RaiseEvent,RaiseEvent>>
<<Randomize,Randomize>>
<<ReDim,ReDim>>
<<Rem,Rem>>
<<Reset,Reset>>
<<Resume,Resume>>
<<RmDir,RmDir>>
<<RSet,RSet>>
<<SaveSetting,SaveSetting>>
<<Seek,Seek>>
<<Select Case,Select Case>>
<<SendKeys,SendKeys>>
<<Set,Set>>
<<SetAttr,SetAttr>>
<<Static,Static>>
<<Stop,Stop>>
<<Sub,Sub>>
<<Time,Time>>
<<Type,Type>>
<<Unload,Unload>>
<<While...Wend,While...Wend>>
<<Width #,Width #>>
<<With,With>>
<<Write #,Write #>>



==== On Error ステートメント[[On Error]]

エラー処理ルーチンを有効にして、プロシージャ内のルーチンの場所を指定します。エ
ラー処理ルーチンを無効にする目的でも使用できます。

.構文

[source,vbscript]
----
On Error GoTo line
On Error Resume Next
**On Error GoTo 0**
----

On Error ステートメントの構文では、次の形式を使用できます。

[cols="1,4",options="header"]
|===
|Statement |説明
|On Error GoTo line |必須の_line_ 引数で指定された_行_から始まるエラー処理ルー
チンを有効にします。 +
_Line_引数には、任意の行ラベルまたは行番号を指定します。 +
実行時エラーが発生した場合は、を_line_に分岐し、エラー処理ルーチンをアクティブ
にします。 +
指定した_行_は、 On Errorステートメントと同じプロシージャ内にある必要がありま
す。それ以外の場合は、コンパイル時エラーが発生します。 
|On Error Resume Next |実行時エラーが発生したときに、エラーが発生して実行が続行されるステートメントの直後のステートメントに制御が移動することを指定します。 オブジェクトにアクセスするときは、 On Error GoTo の代わりにこの形式を使用してください。
|On Error GoTo 0 |現在のプロシージャですべての有効なエラー ハンドラーを無効にします。
|===

.注釈

On Error ステートメントを使用しない場合は、発生するすべての実行時エラーが致命
的となります。つまり、エラー メッセージが表示され、実行が停止します。

"Enabled" エラーハンドラーは、 On errorステートメントによって有効にされたもの
です。"アクティブな" エラーハンドラーは、エラー処理のプロセスに含まれる有効な
ハンドラーです。 エラー処理ルーチンがアクティブな間 (error の発生とResume、
<<exit,exit Sub、 Exit Function、またはexit Property>>ステートメントの間) にエラーが
発生すると、現在のプロシージャのエラーハンドラーはエラーを処理できません。 制
御は、呼び出し元のプロシージャに戻ります。

呼び出し元のプロシージャに有効なエラー処理ルーチンがある場合は、エラーを処理す
るためにアクティブ化されます。 呼び出し元のプロシージャのエラーハンドラーがア
クティブである場合は、有効になっているが非アクティブなエラーハンドラが見つかる
まで、制御は前の呼び出しプロシージャを戻します。 非アクティブなエラー処理ルー
チンが存在しない場合、エラーは実際に発生した時点で致命的です。

エラーハンドラーが呼び出し元のプロシージャに制御を戻すたびに、そのプロシージャ
が現在のプロシージャになります。 任意のプロシージャでエラーハンドラーによって
エラーが処理された後、 Resumeステートメントで指定された位置にある現在のプロシ
ージャから実行が再開されます。


CAUTION:	エラー処理ルーチンは、 Sub プロシージャまたは**Function** プロ
シージャではありません。 行ラベルまたは行番号でマークが付けられた、コードのセ
クションのことです。

エラー処理ルーチンは、 <<Err,Err>> オブジェクトの**Number** プロパティの値に依
存して、エラーの原因を特定します。 エラー処理ルーチンは、その他のエラーが発生
する前、またはエラーを発生させる可能性があるプロシージャを呼び出す前に、 Err
オブジェクト内の関連するプロパティ値をテストあるいは保存する必要があります。
Err オブジェクト内のプロパティ値は、最新のエラーのみを反映します。 Err.Number
に対応するエラー メッセージは Err.Description に含まれます。

On Error Resume Nextを実行すると、実行時エラーの原因となったステートメントの直
後のステートメント、または on エラーを含むプロシージャからの直前のステートメン
トに従って、ステートメントが続行されます。 次のステートメントを再開します。 こ
のステートメントを使用すると、実行時エラーが発生しても実行を続行できます。 エ
ラー処理ルーチンは、コントロールをプロシージャ内の別の場所に転送するのではなく、
エラーが発生する場所に配置できます。 On Error Resume nextステートメントは、別
のプロシージャが呼び出されたときに非アクティブになります。そのため、そのルーチ
ン内でインラインエラー処理が必要な場合は、呼び出された各ルーチンでOn error
resume nextステートメントを実行する必要があります。

CAUTION:	他のオブジェクトへのアクセス中に生成されたエラーを処理するとき
に、On Error GoTo よりも On Error Resume Next 構成要素が適している場合がありま
す。 オブジェクトの操作後に Err を確認すると、エラーの発生時にコードがアクセス
していたオブジェクトを明確にできます。 Err.Number にエラー コードを設定したオ
ブジェクトと、最初にエラーを生成したオブジェクト (Err.Source で指定されるオブ
ジェクト) についても確認できます。


On Error GoTo 0 は、現在のプロシージャでエラー処理を無効にします。 このステー
トメントは、プロシージャに 0 という番号の行が含まれている場合でも、エラー処理
コードの開始行として行 0 を指定しません。 On Error GoTo 0 ステートメントがない
場合、プロシージャが終了するときに、エラー ハンドラーは自動的に無効にされます。

エラーが発生しなかったときに、エラー処理コードが実行されないようにするには、以
下のように、エラー処理ルーチンの直前に、Exit Sub、Exit Function、または Exit
Property ステートメントを挿入します。


[source,vbscript]
----
Sub InitializeMatrix(Var1, Var2, Var3, Var4) 
 On Error GoTo ErrorHandler 
 . . . 
 Exit Sub 
ErrorHandler: 
 . . . 
 Resume Next 
End Sub
----

ここでは、エラー処理コードがExit subステートメントの後に続き、 End sub ステー
トメントの前に、プロシージャフローから分離しています。 エラー処理コードは、プ
ロシージャ内の任意の場所に配置できます。

オブジェクトが実行可能ファイルとして実行中の場合、オブジェクト内の未トラップの
エラーは、制御アプリケーションに戻されます。 開発環境では、適切なオプションが
設定されている場合のみ、未トラップのエラーは制御アプリケーションに戻されます。
デバッグ中に、どのオプションを設定する必要があるか、設定の方法、そしてホストが
クラスを作成できるかどうかの詳細については、ホスト アプリケーションの文書を参
照してください。

その他のオブジェクトにアクセスするオブジェクトを作成する場合、そこから未処理で
戻されたエラーの処理を試行する必要があります。 このようなエラーを処理できない
場合は、Err.Number 内でエラー コードを自分のエラーの 1 つにマップして、それを
オブジェクトの呼び出し元に戻します。 vbObjectError 定数にエラー コードを追加す
ることにより、エラーを指定する必要があります。 たとえば、エラー コードが 1052
の場合、以下のように割り当てます。


[source,vbscript]
----
Err.Number = vbObjectError + 1052 
----

CAUTION:	Windowsダイナミックリンクライブラリ(DLL) または Macintosh コー
ドリソースへの通話中のシステムエラーは、例外を発生させずに、Visual Basic のエ
ラートラップを使用してトラップすることはできません。 DLL 関数を呼び出すときは、
各戻り値の成功または失敗を確認する必要があります (API 仕様による)。エラーが発
生した場合は、 Errオブジェクトの**LastDLLError** プロパティの値を確認してくだ
さい。 LastDLLErrorは常に Macintosh で0を返します。



.例

この例では、最初に On Error GoTo ステートメントを使用して、プロシージャ内のエ
ラー処理ルーチンの場所を指定します。 この例では、開かれたファイルを削除しよう
としたときに、エラー番号 55 が生成されます。 エラーはエラー処理ルーチンで処理
され、次に、制御がエラーを起こしたステートメントに戻されます。 On Error GoTo 0
ステートメントは、エラー トラッピングをオフにします。

次に、On Error Resume nextステートメントを使用してエラートラップを延期し、次の
ステートメントによって生成されたエラーのコンテキストが特定のものとして認識され
るようにします。 エラーが処理された後で、 Err.Clear が使用され、 Err オブジェ
クトのプロパティを消去していることに注意してください。


[source,vbscript]
----
Sub OnErrorStatementDemo() 
 On Error GoTo ErrorHandler ' Enable error-handling routine. 
 Open "TESTFILE" For Output As #1 ' Open file for output. 
 Kill "TESTFILE" ' Attempt to delete open 
 ' file. 
 On Error Goto 0 ' Turn off error trapping. 
 On Error Resume Next ' Defer error trapping. 
 ObjectRef = GetObject("MyWord.Basic") ' Try to start nonexistent 
 ' object, then test for 
'Check for likely Automation errors. 
 If Err.Number = 440 Or Err.Number = 432 Then 
 ' Tell user what happened. Then clear the Err object. 
 Msg = "There was an error attempting to open the Automation object!" 
 MsgBox Msg, , "Deferred Error Test" 
 Err.Clear ' Clear Err object fields 
 End If 
Exit Sub ' Exit to avoid handler. 
ErrorHandler: ' Error-handling routine. 
 Select Case Err.Number ' Evaluate error number. 
 Case 55 ' "File already open" error. 
 Close #1 ' Close open file. 
 Case Else 
 ' Handle other situations here... 
 End Select 
 Resume ' Resume execution at same line 
 ' that caused the error. 
End Sub
----

==== On...GoSub、On...GoTo ステートメント[[On...GoSub]][[On...GoTo]][[On...GoSub、On...GoTo]]

式の値に応じて、複数の指定した行のいずれかに分岐します。

.構文

[source,vbscript]
----
On expression GoSub destinationlist
On expression GoTo destinationlist
----

On...GoSub ステートメントおよび On...GoTo ステートメントの構文には、次の指定項
目があります。

[cols="1,4",options="header"]
|===
|パーツ |説明
|expression |必ず指定します。 0 以上 255 以下の整数に評価される任意の数値式です。 expression が整数以外の数値の場合は、評価の前に四捨五入されます。
|destinationlist |必須。 コンマで区切られた行番号または行ラベルのリスト。
|===

.解説

expression の値により、destinationlist 内のどの行に分岐するかが決まります。
expression の値が 1 より小さい場合やリスト内の項目数よりも大きい場合、結果は次
のいずれかになります。


[cols="1,4",options="header"]
|===
|expression の値 |その結果
|0 に等しい |On...GoSub または On...GoTo の次のステートメントに制御が移動します。
|リスト内の項目数より大きい |On...GoSub または On...GoTo の次のステートメントに制御が移動します。
|負の値 |エラーが発生します。
|255 より大きい |エラーが発生します。
|===


同じリスト内に行番号と行ラベルが混在していてもかまいません。 On...GoSub および
On...GoTo には、任意の数の行番ラベルと行番号を使用できます。 ただし、1 行に収
まらない数のラベルや番号を使用する場合は、行連結文字を使用して、論理行が次の物
理行につながるようにする必要があります。

TIP:	Select Case を使用すると、より構造化された柔軟な方法で複数の分岐を実行
できます。


.例

この例では、On...GoSub ステートメントと On...GoTo ステートメントを使用して、そ
れぞれサブルーチンと行番号に分岐します。


[source,vbscript]
----
Sub OnGosubGotoDemo() 
Dim Number, MyString 
 Number = 2 ' Initialize variable. 
 ' Branch to Sub2. 
 On Number GoSub Sub1, Sub2 ' Execution resumes here after 
 ' On...GoSub. 
 On Number GoTo Line1, Line2 ' Branch to Line2. 
 ' Execution does not resume here after On...GoTo. 
 Exit Sub 
Sub1: 
 MyString = "In Sub1" : Return 
Sub2: 
 MyString = "In Sub2" : Return 
Line1: 
 MyString = "In Line1" 
Line2: 
 MyString = "In Line2" 
End Sub
----





























































































=== Visual Basic Add-in Model reference

Visual Basic エディターのカスタマイズ方法と、環境を拡張するために使用できるオ
ブジェクト モデルについて説明します。

* コレクション
* イベント
* メソッド
* オブジェクト
* プロパティ














































































//	vim:fileencoding=utf-8:ff=unix:
