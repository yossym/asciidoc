<!DOCTYPE html>
<html style="" lang="ja"><head>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta http-equiv="Content-Language" content="ja">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>perlretut - Perl の正規表現のチュートリアル - perldoc.jp</title>
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="description" content="Perl の正規表現のチュートリアル">
<meta name="keywords" content="Perl,翻訳,モジュール">
<link href="perlretut%20-%20Perl%20%E3%81%AE%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE%E3%81%AE%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%20-%20perldoc.jp_files/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="perlretut%20-%20Perl%20%E3%81%AE%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE%E3%81%AE%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%20-%20perldoc.jp_files/print.css" media="print" rel="stylesheet" type="text/css">
<!--[if IE]>
    <link href="/static/css/ie.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <![endif]-->
<link rel="shortcut icon" href="https://perldoc.jp/favicon.ico">
<script type="text/javascript" async="" src="perlretut%20-%20Perl%20%E3%81%AE%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE%E3%81%AE%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%20-%20perldoc.jp_files/ga.js"></script><script src="perlretut%20-%20Perl%20%E3%81%AE%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE%E3%81%AE%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%20-%20perldoc.jp_files/prettify.js" type="text/javascript"></script>
<script src="perlretut%20-%20Perl%20%E3%81%AE%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE%E3%81%AE%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%20-%20perldoc.jp_files/jquery.js"></script>
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0">
<script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-59935-4']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
</head>
<body onload="prettyPrint();return true;" style="margin-bottom: 59px !important;">
<div class="container">
<div class="header span-24 last">
<a class="SiteLogo" href="https://perldoc.jp/">perldoc.jp</a>
</div>
<div class="nav span-24 last">
<ul>
<li><a href="https://perldoc.jp/">トップ</a></li>
<li><a href="https://perldoc.jp/index/core">本体</a></li>
<li><a href="https://perldoc.jp/index/function">関数</a></li>
<li><a href="https://perldoc.jp/index/variable">変数</a></li>
<li><a href="https://perldoc.jp/index/module">モジュール</a></li>
<li><a href="https://perldoc.jp/category">カテゴリ別</a></li>
<li><a href="https://perldoc.jp/index/article">その他の翻訳</a></li>
<li><a href="https://perldoc.jp/translators">翻訳者</a></li>
<li><a href="https://perldoc.jp/manners">翻訳の作法</a></li>
<li><a href="https://perldoc.jp/about">このサイトについて</a></li>
</ul>

<form method="get" action="https://www.google.co.jp/search" id="GoogleSearch">
<input type="text" name="q" size="31" maxlength="255">
<input type="hidden" name="ie" value="UTF-8">
<input type="hidden" name="oe" value="UTF-8">
<input type="hidden" name="hl" value="ja">
<input type="hidden" name="domains" value="perldoc.jp">
<input type="hidden" name="sitesearch" value="perldoc.jp">
<input type="submit" name="btnG" value="Google 検索">
</form>

</div>
<div id="main" class="span-24 last">
<div id="content">
<div class="content">
<div class="PodPage">
<div class="PodInfo">
<div class="PodVersion">5.26.1</div>
<div class="CheckAtCPAN"><a href="http://search.cpan.org/perldoc?perlretut">CPANで確認する</a></div>
<div class="OtherVersions">
Other versions:<br>
<a href="https://perldoc.jp/docs/perl/5.24.1/perlretut.pod">5.24.1</a><br>
<a href="https://perldoc.jp/docs/perl/5.22.1/perlretut.pod">5.22.1</a><br>
<a href="https://perldoc.jp/docs/perl/5.20.1/perlretut.pod">5.20.1</a><br>
<a href="https://perldoc.jp/docs/perl/5.18.1/perlretut.pod">5.18.1</a><br>
<a href="https://perldoc.jp/docs/perl/5.16.1/perlretut.pod">5.16.1</a><br>
<a href="https://perldoc.jp/docs/perl/5.14.1/perlretut.pod">5.14.1</a><br>
<a href="https://perldoc.jp/docs/perl/5.12.1/perlretut.pod">5.12.1</a><br>
<a href="https://perldoc.jp/docs/perl/5.10.1/perlretut.pod">5.10.1</a><br>
<a href="https://perldoc.jp/docs/perl/5.10.0/perlretut.pod">5.10.0</a><br>
</div><form action="/docs/perl/5.26.1/perlretut.pod/diff">
<select name="target"><option value="perl/5.24.1/perlretut.pod" selected="selected">5.24.1</option><option value="perl/5.22.1/perlretut.pod">5.22.1</option><option value="perl/5.20.1/perlretut.pod">5.20.1</option><option value="perl/5.18.1/perlretut.pod">5.18.1</option><option value="perl/5.16.1/perlretut.pod">5.16.1</option><option value="perl/5.14.1/perlretut.pod">5.14.1</option><option value="perl/5.12.1/perlretut.pod">5.12.1</option><option value="perl/5.10.1/perlretut.pod">5.10.1</option><option value="perl/5.10.0/perlretut.pod">5.10.0</option></select>
<input type="submit" value="diff">
</form>
<div class="Source"><a href="https://perldoc.jp/docs/perl/5.26.1/perlretut.pod.pod">Source</a></div>
<div><a target="_blank" href="https://sourceforge.jp/cvs/view/perldocjp/docs/perl/5.26.1/perlretut.pod?view=log">変更履歴(sf.jp)</a></div>
<div><a target="_blank" href="https://sourceforge.jp/ticket/newticket.php?group_id=136">誤訳の報告</a></div>
<script>
              var display_original = false;
            </script>
<div>
<a href="#" onclick="$('.original').css('display', display_original ? 'none' : 'block'); display_original = display_original ? false : true; return false;">原文を表示/隠す</a>
</div>
</div>
<div class="PodBody">
<ul class="pod_toc">
<li><a href="#NAME">名前</a></li>
<li><a href="#DESCRIPTION">説明</a></li>
<li><a href="#Part321:32The32basics">パート 1: 基本</a>
<ul>
<li><a href="#Simple32word32matching">単純な単語マッチング</a></li>
<li><a href="#Using32character32classes">文字クラスを使う</a></li>
<li><a href="#Matching32this32or32that">あれやこれやにマッチングする</a></li>
<li><a href="#Grouping32things32and32hierarchical32matching">グループ化と階層的マッチング</a></li>
<li><a href="#Extracting32matches">マッチングしたものを取り出す</a></li>
<li><a href="#Backreferences">後方参照</a></li>
<li><a href="#Relative32backreferences">相対後方参照</a></li>
<li><a href="#Named32backreferences">名前付き後方参照</a></li>
<li><a href="#Alternative32capture32group32numbering">選択捕捉グループ番号付け</a></li>
<li><a href="#Position32information">位置情報</a></li>
<li><a href="#Non-capturing32groupings">捕捉しないグループ化</a></li>
<li><a href="#Matching32repetitions">マッチングの繰り返し</a></li>
<li><a href="#Possessive32quantifiers">絶対最大量指定子</a></li>
<li><a href="#Building32a32regexp">正規表現を組み立てる</a></li>
<li><a href="#Using32regular32expressions32in32Perl">Perl で正規表現を使う</a>
<ul>
<li><a href="#Prohibiting32substitution">置換を禁止する</a></li>
<li><a href="#Global32matching">グローバルマッチング</a></li>
<li><a href="#Search32and32replace">検索と置換</a></li>
<li><a href="#The32split32function">split 関数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Part322:32Power32tools">パート 2: 強力なツール</a>
<ul>
<li><a href="#More32on32characters44-32strings44-32and32character32classes">文字、文字列、文字クラスについての追加事項</a></li>
<li><a href="#Compiling32and32saving32regular32expressions">正規表現のコンパイルと保管</a></li>
<li><a href="#Composing32regular32expressions32at32runtime">実行時に正規表現を構成する</a></li>
<li><a href="#Embedding32comments32and32modifiers32in32a32regular32expression">正規表現にコメントや修飾子を埋め込む</a></li>
<li><a href="#Looking32ahead32and32looking32behind">先読みと戻り読み</a></li>
<li><a href="#Using32independent32subexpressions32to32prevent32backtracking">バックトラッキングの抑制のために独立部分式を使う</a></li>
<li><a href="#Conditional32expressions">条件式</a></li>
<li><a href="#Defining32named32patterns">名前付きパターンを定義する</a></li>
<li><a href="#Recursive32patterns">再帰的パターン</a></li>
<li><a href="#A32bit32of32magic:32executing32Perl32code32in32a32regular32expression">ちょっとした魔法: 正規表現の中で Perl のコードを実行する</a></li>
<li><a href="#Backtracking32control32verbs">バックトラッキング制御動詞</a></li>
<li><a href="#Pragmas32and32debugging">プラグマとデバッグ</a></li>
</ul>
</li>
<li><a href="#SEE32ALSO">SEE ALSO</a></li>
<li><a href="#AUTHOR32AND32COPYRIGHT">AUTHOR AND COPYRIGHT</a>
<ul>
<li><a href="#Acknowledgments">Acknowledgments</a></li>
</ul>
</li>
</ul>
<div class="pod_content_body"><h1 id="NAME">名前<a href="#NAME" class="toc_link">¶</a></h1>
<div class="original">
<p>perlretut - Perl regular expressions tutorial</p>
</div>
<p>perlretut - Perl の正規表現のチュートリアル</p>
<h1 id="DESCRIPTION">説明<a href="#DESCRIPTION" class="toc_link">¶</a></h1>
<div class="original">
<p>This page provides a basic tutorial on understanding, creating and 
using regular expressions in Perl. It serves as a complement to the 
reference page on regular expressions <a href="https://perldoc.jp/pod/perlre">perlre</a>. Regular expressions are an integral part of the <code>m//</code>, <code>s///</code>, <code>qr//</code> and <code>split</code> operators and so this tutorial also overlaps with <a href="https://perldoc.jp/pod/perlop#Regexp32Quote-Like32Operators">"Regexp Quote-Like Operators" in perlop</a> and <a href="https://perldoc.jp/pod/perlfunc#split">"split" in perlfunc</a>.</p>
</div>
<p>このページでは Perl の正規表現(regular expressions)を理解し、作成し、 使用するための基本的なチュートリアルを提供します。 詳細は正規表現のリファレンスページである <a href="https://perldoc.jp/pod/perlre">perlre</a> にあります。 正規表現は演算子 <code>m//</code>、<code>s///</code>、<code>qr//</code>、<code>split</code> の一部分であり、 本チュートリアルでは <a href="https://perldoc.jp/pod/perlop#Regexp32Quote-Like32Operators">"Regexp Quote-Like Operators" in perlop</a> や <a href="https://perldoc.jp/pod/perlfunc#split">"split" in perlfunc</a> と重複する部分があります。</p>
<div class="original">
<p>Perl is widely renowned for excellence in text processing, and 
regular expressions are one of the big factors behind this fame. Perl 
regular expressions display an efficiency and flexibility unknown in 
most other computer languages. Mastering even the basics of regular 
expressions will allow you to manipulate text with surprising ease.</p>
</div>
<p>Perl はテキスト処理のための優れた道具であると広く知られていて、 正規表現はこの名声の大きな部分です。 Perl 
の正規表現は他の大部分の言語で知られていない効率性や融通性を 明らかにします。 
正規表現の基本的な部分をマスターすることによってさえ驚くほど簡単に テキストを操作することができるようになるでしょう。</p>
<div class="original">
<p>What is a regular expression? At its most basic, a regular expression
 is a template that is used to determine if a string has certain 
characteristics. The string is most often some text, such as a line, 
sentence, web page, or even a whole book, but less commonly it could be 
some binary data as well. Suppose we want to determine if the text in 
variable, <code>$var</code> contains the sequence of characters <span style="white-space: nowrap;"><code>m u s h r o o m</code></span> (blanks added for legibility). We can write in Perl</p>
</div>
<p>正規表現とは何でしょうか? 最も基本的な意味では、正規表現とは文字列がある特徴を持っているかを 決定するために使われるテンプレートです。 
文字列はほとんどの場合、行、文、web ページ、あるいは本全体のようななんらかの テキストですが、まれに任意のバイナリの場合もあります。 変数 <code>$var</code> に入っているテキストが文字並び <span style="white-space: nowrap;"><code>m u s h r o o m</code></span> (空白は読みやすさのために追加しています)を 含んでいるかどうかを調べたいとします。 Perl では次のように書けます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp;$var </span><span class="pun">=~</span><span class="pln"> m</span><span class="pun">/</span><span class="pln">mushroom</span><span class="pun">/</span></code></pre>
<div class="original">
<p>The value of this expression will be TRUE if <code>$var</code> contains that sequence of characters, and FALSE otherwise. The portion enclosed in <code>'/'</code> characters denotes the characteristic we are looking for. We use the term <i>pattern</i> for it. The process of looking to see if the pattern occurs in the string is called <i>matching</i>, and the <code>"=~"</code> operator along with the <code>m//</code>
 tell Perl to try to match the pattern against the string. Note that the
 pattern is also a string, but a very special kind of one, as we will 
see. Patterns are in common use these days; examples are the patterns 
typed into a search engine to find web pages and the patterns used to 
list files in a directory, <i>e.g.</i>, "<code>ls *.txt</code>" or "<code>dir *.*</code>".
 In Perl, the patterns described by regular expressions are used not 
only to search strings, but to also extract desired parts of strings, 
and to do search and replace operations.</p>
</div>
<p>この式の値は、<code>$var</code> がこの文字並びを含んでいるなら真に、さもなければ 偽になります。 <code>'/'</code> 文字で囲まれた部分は、探している特徴を意味しています。 これを <i>パターン</i> (pattern) と呼びます。 パターンが文字列の中にあるかどうかを探す処理を <i>マッチング</i> (matching) と よび、 <code>m//</code> と共に <code>"=~"</code>
 演算子が使われると、Perl は文字列に対してパターンを マッチングします。 
パターンも文字列ですが、既に見られたとおり、とても特殊な種類であることに 注意してください。 パターンは今日広く使われています; 
たとえば、ウェブページを見つけ出すために 検索エンジンにタイプしたり、ディレクトリの中のファイルを リストアップするために "<code>ls *.txt</code>" とか "<code>dir *.*</code>" としたりします。 Perl では、パターンは正規表現によって記述され、文字列を探しだすだけでなく、 文字列の望みの部分を取り出したり、検索と置換の操作をするためにも使われます。</p>
<div class="original">
<p>Regular expressions have the undeserved reputation of being abstract 
and difficult to understand. This really stems simply because the 
notation used to express them tends to be terse and dense, and not 
because of inherent complexity. We recommend using the <code>/x</code> 
regular expression modifier (described below) along with plenty of white
 space to make them less dense, and easier to read. Regular expressions 
are constructed using simple concepts like conditionals and loops and 
are no more difficult to understand than the corresponding <code>if</code> conditionals and <code>while</code> loops in the Perl language itself.</p>
</div>
<p>正規表現には抽象的で理解するのが難しいという不適切な悪名があります。 これは本当は単に表現に使われている記法が簡潔かつ濃密であるからであって、 本質的な複雑性によるものではありません。 パターンの密度を減らし、より読みやすくするために、 <code>/x</code> 正規表現修飾子 (後述します) と共にたくさんの空白を使うことを 勧めます。 正規表現は条件とループのような単純なコンセプトを使って構成されていて、 Perl 自身の <code>if</code> であるとか <code>while</code> のようなそれと対応するものに比べて 難しいことはありません。</p>
<div class="original">
<p>This tutorial flattens the learning curve by discussing regular 
expression concepts, along with their notation, one at a time and with 
many examples. The first part of the tutorial will progress from the 
simplest word searches to the basic regular expression concepts. If you 
master the first part, you will have all the tools needed to solve about
 98% of your needs. The second part of the tutorial is for those 
comfortable with the basics and hungry for more power tools. It 
discusses the more advanced regular expression operators and introduces 
the latest cutting-edge innovations.</p>
</div>
<p>本チュートリアルでは表記に関して一度に一つずつ、そして例を多く挙げて 正規表現のコンセプトを論じることによって、学習曲線を平坦化します。 
本チュートリアルの最初の部分は基本的な正規表現のコンセプトのための単純な 単語検索から始まります。 最初の部分をマスターすれば、必要とすることの
 98% を解決するのに必要な ツールを得ることになるでしょう。 本チュートリアルの二番目の部分はより強力なツールのために十分なものです。 
そこではより高度な正規表現演算子について論じ、最新の機能を紹介します。</p>
<div class="original">
<p>A note: to save time, "regular expression" is often abbreviated as 
regexp or regex. Regexp is a more natural abbreviation than regex, but 
is harder to pronounce. The Perl pod documentation is evenly split on 
regexp vs regex; in Perl, there is more than one way to abbreviate it. 
We'll use regexp in this tutorial.</p>
</div>
<p>注意: "regular expression" はしばしば regexp とか regex と略されます。 regexp は regex
 よりも自然な略称ですが発音するのが難しいです。 Perl の pod ドキュメントでは regexp と regex が混在しています; 
Perl では、 略するやり方は一つではないのです。 このチュートリアルでは regexp を使うことにします(訳注: 日本語では 
「正規表現」と記します)。</p>
<div class="original">
<p>New in v5.22, <a href="https://perldoc.jp/pod/re#strict32mode"><code>use re 'strict'</code></a>
 applies stricter rules than otherwise when compiling regular expression
 patterns. It can find things that, while legal, may not be what you 
intended.</p>
</div>
<p><a href="https://perldoc.jp/pod/re#strict32mode"><code>use re 'strict'</code></a> は v5.22 からの新機能で、正規表現 パターンをコンパイルするときに他よりもより厳密な規則を適用します。 これにより、有効ではあるけれども、意図しているものと違うかも知れないものを 見つけることができます。</p>
<h1 id="Part321:32The32basics">パート 1: 基本<a href="#Part321:32The32basics" class="toc_link">¶</a></h1>
<p></p>
<h2 id="Simple32word32matching">単純な単語マッチング<a href="#Simple32word32matching" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>The simplest regexp is simply a word, or more generally, a string of 
characters. A regexp consisting of just a word matches any string that 
contains that word:</p>
</div>
<p>最も単純な正規表現は単なる単語、より一般的には文字の並びです。 正規表現は単語を構成する任意の文字列にマッチングする単なる単語からなります:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="typ">World</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches</span></code></pre>
<div class="original">
<p>What is this Perl statement all about? <code>"Hello World"</code> is a simple double-quoted string. <code>World</code> is the regular expression and the <code>//</code> enclosing <code>/World/</code> tells Perl to search a string for a match. The operator <code>=~</code>
 associates the string with the regexp match and produces a true value 
if the regexp matched, or false if the regexp did not match. In our 
case, <code>World</code> matches the second word in <code>"Hello World"</code>, so the expression is true. Expressions like this are useful in conditionals:</p>
</div>
<p>この Perl の文が行っていることは何でしょう? <code>"Hello World"</code> は単純な、ダブルクォートで囲まれた文字列です。 <code>World</code> は正規表現であり、 <code>//</code> で囲まれた <code>/World/</code> は Perl に対してマッチングのために文字列を検索することを指示します。 <code>=~</code> という演算子は正規表現にマッチングする文字列に結び付けられ、 正規表現がマッチングすれば真の値を生成し、マッチングしなければ偽となります。 この例では、<code>World</code> は <code>"Hello World"</code> の二番目の単語にマッチングするので、 式は真となります。 このような式は条件文に使うにも便利です:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="typ">World</span><span class="pun">/)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"It matches\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; else </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"It doesn't match\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>There are useful variations on this theme. The sense of the match can be reversed by using the <code>!~</code> operator:</p>
</div>
<p>便利なバリエーションもあります。 マッチングの成否の意味を反転する演算子 <code>!~</code> があります:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">!~</span><span class="pln"> </span><span class="pun">/</span><span class="typ">World</span><span class="pun">/)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"It doesn't match\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; else </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"It matches\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>The literal string in the regexp can be replaced by a variable:</p>
</div>
<p>正規表現中のリテラル文字列は変数に置き換えることができます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">my</span><span class="pln"> $greeting </span><span class="pun">=</span><span class="pln"> </span><span class="str">"World"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$greeting</span><span class="pun">/)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"It matches\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; else </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"It doesn't match\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>If you're matching against the special default variable <code>$_</code>, the <code>$_ =~</code> part can be omitted:</p>
</div>
<p>特殊デフォルト変数 <code>$_</code> に対してマッチングを行う場合、<code>$_ =~</code> の 部分は省略できます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $_ </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Hello World"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">/World/</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"It matches\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; else </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"It doesn't match\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>And finally, the <code>//</code> default delimiters for a match can be changed to arbitrary delimiters by putting an <code>'m'</code> out front:</p>
</div>
<p>最後に、マッチングのための <code>//</code> のデフォルトデリミタは <code>'m'</code> を 前置することにより任意のものにすることができます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> m</span><span class="pun">!</span><span class="typ">World</span><span class="pun">!;</span><span class="pln"> &nbsp; </span><span class="com"># matches, delimited by '!'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> m</span><span class="pun">{</span><span class="typ">World</span><span class="pun">};</span><span class="pln"> &nbsp; </span><span class="com"># matches, note the matching '{}'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"/usr/bin/perl"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> m</span><span class="str">"/perl"</span><span class="pun">;</span><span class="pln"> </span><span class="com"># matches after '/usr/bin',</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># '/' becomes an ordinary char</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> m</span><span class="pun">!</span><span class="typ">World</span><span class="pun">!;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする; デリミタは '!'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> m</span><span class="pun">{</span><span class="typ">World</span><span class="pun">};</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする; 組になっている '{}' に注意</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"/usr/bin/perl"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> m</span><span class="str">"/perl"</span><span class="pun">;</span><span class="pln"> </span><span class="com"># 'usr/bin' の後にマッチングする</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># '/' は普通の文字になっている</span></code></pre>
<div class="original">
<p><code>/World/</code>, <code>m!World!</code>, and <code>m{World}</code> all represent the same thing. When, <i>e.g.</i>, the quote (<code>'"'</code>) is used as a delimiter, the forward slash <code>'/'</code> becomes an ordinary character and can be used in this regexp without trouble.</p>
</div>
<p><code>/World/</code>, <code>m!World!</code>, <code>m{World}</code> はすべて同じものを表しています。 例えば <code>'"'</code> をデリミタとして使ったとき、スラッシュ <code>'/'</code> は 通常の文字となり、トラブルなしに正規表現中で使うことができます。</p>
<div class="original">
<p>Let's consider how different regexps would match <code>"Hello World"</code>:</p>
</div>
<p>異なる正規表現がどのように <code>"Hello World"</code> にマッチングするか 考えてみましょう:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">world</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># doesn't match</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">o W</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">oW</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># doesn't match</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="typ">World</span><span class="pln"> </span><span class="pun">/;</span><span class="pln"> </span><span class="com"># doesn't match</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">world</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングしない</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">o W</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">oW</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># マッチングしない</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="typ">World</span><span class="pln"> </span><span class="pun">/;</span><span class="pln"> </span><span class="com"># マッチングしない</span></code></pre>
<div class="original">
<p>The first regexp <code>world</code> doesn't match because regexps are case-sensitive. The second regexp matches because the substring <span style="white-space: nowrap;"><code>'o W'</code></span> occurs in the string <span style="white-space: nowrap;"><code>"Hello World"</code></span>. The space character <code>' '</code>
 is treated like any other character in a regexp and is needed to match 
in this case. The lack of a space character is the reason the third 
regexp <code>'oW'</code> doesn't match. The fourth regexp "<code>World </code>"
 doesn't match because there is a space at the end of the regexp, but 
not at the end of the string. The lesson here is that regexps must match
 a part of the string <i>exactly</i> in order for the statement to be true.</p>
</div>
<p>最初の正規表現 <code>world</code> はマッチングしません; なぜなら、正規表現は大文字と 小文字を区別するからです。 二番目の正規表現は <span style="white-space: nowrap;"><code>"Hello World"</code></span> という文字列の中に <span style="white-space: nowrap;"><code>'o W'</code></span> と いう部分があるのでマッチングします。 スペース <code>' '</code> は正規表現の中で他の文字と同じように扱われ、この場合 マッチングするのに必要なものです。 スペースがないことが三番目の正規表現 <code>'oW'</code> がマッチングしない理由です。 四番目の正規表現は "<code>World </code>" 正規表現の末尾にスペースがついているのに、 文字列の末尾にはスペースがないのでマッチングしません。 このレッスンでは正規表現は、文が真となるためには <i>正確に</i> 順序通りに 文字列の一部としてマッチングしなければならないことを示しました。</p>
<div class="original">
<p>If a regexp matches in more than one place in the string, Perl will always match at the earliest possible point in the string:</p>
</div>
<p>正規表現が文字列の二箇所以上にマッチングするならば、Perl は常に文字列の中で 最初に現れるものをマッチングしようとします:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">o</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># matches 'o' in 'Hello'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"That hat is red"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">hat</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches 'hat' in 'That'</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"Hello World"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">o</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># 'Hello' の 'o' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"That hat is red"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">hat</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># 'That' の中の 'hat' にマッチング</span></code></pre>
<div class="original">
<p>With respect to character matching, there are a few more points you 
need to know about. First of all, not all characters can be used "as is"
 in a match. Some characters, called <i>metacharacters</i>, are reserved for use in regexp notation. The metacharacters are</p>
</div>
<p>文字マッチングに対する関心と共に、知っておくべき幾つかのポイントが あります。 まず始めに、すべての文字がマッチングにおいて「あるがまま」に 使われるのではないということです。 <i>メタ文字</i> と呼ばれる幾つかの文字が正規表現の記述に使うために 予約されています。 メタ文字には以下のものがあります</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">{}[]()^</span><span class="pln">$</span><span class="pun">.|*+?-\</span></code></pre>
<div class="original">
<p>The significance of each of these will be explained in the rest of 
the tutorial, but for now, it is important only to know that a 
metacharacter can be matched as-is by putting a backslash before it:</p>
</div>
<p>これらの文字のそれぞれの重要性は本チュートリアルの残りの部分で 説明されますが、今のところは、メタ文字はバックスラッシュを 前置することによってそのままの文字としてマッチングさせることができることを 知っておくことが重要です:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"2+2=4"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="lit">2</span><span class="pun">+</span><span class="lit">2</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># doesn't match, + is a metacharacter</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"2+2=4"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="lit">2</span><span class="pun">\+</span><span class="lit">2</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># matches, \+ is treated like an ordinary +</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"The interval is [0,1)."</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/[</span><span class="lit">0</span><span class="pun">,</span><span class="lit">1</span><span class="pun">)./</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># is a syntax error!</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"The interval is [0,1)."</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\[</span><span class="lit">0</span><span class="pun">,</span><span class="lit">1</span><span class="pun">\)\./</span><span class="pln"> &nbsp;</span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"#!/usr/bin/perl"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="com">#!\/usr\/bin\/perl/; &nbsp;# matches</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"2+2=4"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="lit">2</span><span class="pun">+</span><span class="lit">2</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># マッチングしない; + はメタ文字</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"2+2=4"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="lit">2</span><span class="pun">\+</span><span class="lit">2</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする; \+ は普通の + のように扱われる</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"The interval is [0,1)."</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/[</span><span class="lit">0</span><span class="pun">,</span><span class="lit">1</span><span class="pun">)./</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># これは文法エラー!</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"The interval is [0,1)."</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\[</span><span class="lit">0</span><span class="pun">,</span><span class="lit">1</span><span class="pun">\)\./</span><span class="pln"> &nbsp;</span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"#!/usr/bin/perl"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="com">#!\/usr\/bin\/perl/; &nbsp;# マッチングする</span></code></pre>
<div class="original">
<p>In the last regexp, the forward slash <code>'/'</code> is also 
backslashed, because it is used to delimit the regexp. This can lead to 
LTS (leaning toothpick syndrome), however, and it is often more readable
 to change delimiters.</p>
</div>
<p>最後の正規表現では、スラッシュ <code>'/'</code> もまたバックスラッシュが つけられています; 
なぜなら、それが正規表現のデリミタとして使われているからです。 これは LTS(leaning toothpick syndrome 
つまようじ大好き症候群)を 招きがちですが、読みやすくするためにデリミタを変更することが しばしばあります。</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"#!/usr/bin/perl"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> m</span><span class="pun">!</span><span class="com">#\!/usr/bin/perl!; &nbsp;# easier to read</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"#!/usr/bin/perl"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> m</span><span class="pun">!</span><span class="com">#\!/usr/bin/perl!; &nbsp;# より読みやすい</span></code></pre>
<div class="original">
<p>The backslash character <code>'\'</code> is a metacharacter itself and needs to be backslashed:</p>
</div>
<p>バックスラッシュ文字 <code>'\'</code> はそれ自身がメタ文字であり、 バックスラッシュをつける必要があります:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">'C:\WIN32'</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">C</span><span class="pun">:\\</span><span class="pln">WIN</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># matches</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">'C:\WIN32'</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">C</span><span class="pun">:\\</span><span class="pln">WIN</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする</span></code></pre>
<div class="original">
<p>In situations where it doesn't make sense for a particular 
metacharacter to mean what it normally does, it automatically loses its 
metacharacter-ness and becomes an ordinary character that is to be 
matched literally. For example, the <code>'}'</code> is a metacharacter only when it is the mate of a <code>'{'</code> metacharacter. Otherwise it is treated as a literal RIGHT CURLY BRACKET. This may lead to unexpected results. <a href="https://perldoc.jp/pod/re#strict32mode"><code>use re 'strict'</code></a> can catch some of these.</p>
</div>
<p>特定のメタ文字が通常の意味として意味のない状況では、 自動的にメタ文字性がなくなり、 リテラルにマッチングする通常の文字になります。 例えば、<code>'}'</code> は相手となる <code>'{'</code> メタ文字がいる場合にのみ メタ文字になります。 さもなければこれはリテラルな RIGHT CURLY BRACKET として扱われます。 これは想定外の結果を引き起こすかもしれません。 これらの一部は <a href="https://perldoc.jp/pod/re#strict32mode"><code>use re 'strict'</code></a> で捕捉できます。</p>
<div class="original">
<p>In addition to the metacharacters, there are some ASCII characters 
which don't have printable character equivalents and are instead 
represented by <i>escape sequences</i>. Common examples are <code>\t</code> for a tab, <code>\n</code> for a newline, <code>\r</code> for a carriage return and <code>\a</code> for a bell (or alert). If your string is better thought of as a sequence of arbitrary bytes, the octal escape sequence, <i>e.g.</i>, <code>\033</code>, or hexadecimal escape sequence, <i>e.g.</i>, <code>\x1B</code> may be a more natural representation for your bytes. Here are some examples of escapes:</p>
</div>
<p>メタ文字に加え、印字することのできない文字であって <i>エスケープシーケンス</i> によって表現されるいくつかの ASCII 文字があります。 一般的な例では、タブを表す <code>\t</code>、改行を表す <code>\n</code>、復帰を表す <code>\r</code>、 ベルを表す <code>\a</code> があります。 文字列を任意のバイト列としてみなすのなら、<code>\033</code> のような 8 進エスケープシーケンスや <code>\x1B</code> のような 16 進エスケープシーケンスは バイト列のより自然な表現となります。 以下にあげるのはエスケープの例です:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"1000\t2000"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> m</span><span class="pun">(</span><span class="lit">0</span><span class="pun">\</span><span class="pln">t2</span><span class="pun">)</span><span class="pln"> &nbsp; </span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"1000\n2000"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="lit">0</span><span class="pun">\</span><span class="pln">n20</span><span class="pun">/</span><span class="pln"> &nbsp; </span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"1000\t2000"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="lit">000</span><span class="pun">\</span><span class="pln">t2</span><span class="pun">/</span><span class="pln"> </span><span class="com"># doesn't match, "0" ne "\000"</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"cat"</span><span class="pln"> &nbsp; </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">o</span><span class="pun">{</span><span class="lit">143</span><span class="pun">}\</span><span class="pln">x61</span><span class="pun">\</span><span class="pln">x74</span><span class="pun">/</span><span class="pln"> </span><span class="com"># matches in ASCII, but a weird way</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># to spell cat</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"1000\t2000"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> m</span><span class="pun">(</span><span class="lit">0</span><span class="pun">\</span><span class="pln">t2</span><span class="pun">)</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"1000\n2000"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="lit">0</span><span class="pun">\</span><span class="pln">n20</span><span class="pun">/</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"1000\t2000"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="lit">000</span><span class="pun">\</span><span class="pln">t2</span><span class="pun">/</span><span class="pln"> </span><span class="com"># マッチングしない; "0" は "\000" ではない</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"cat"</span><span class="pln"> &nbsp; </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">o</span><span class="pun">{</span><span class="lit">143</span><span class="pun">}\</span><span class="pln">x61</span><span class="pun">\</span><span class="pln">x74</span><span class="pun">/</span><span class="pln"> </span><span class="com"># ASCII でマッチングするが、cat を綴る</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># 変な方法</span></code></pre>
<div class="original">
<p>If you've been around Perl a while, all this talk of escape sequences
 may seem familiar. Similar escape sequences are used in double-quoted 
strings and in fact the regexps in Perl are mostly treated as 
double-quoted strings. This means that variables can be used in regexps 
as well. Just like double-quoted strings, the values of the variables in
 the regexp will be substituted in before the regexp is evaluated for 
matching purposes. So we have:</p>
</div>
<p>あなたがすでに Perl を少なからず知っているのなら、エスケープシーケンスに 
付いて述べた以上のことはすでになじみ深いものかもしれません。 同じようなエスケープシーケンスはダブルクォートで囲まれた文字列で 
使われていて、事実 Perl における正規表現はほとんどの場合において ダブルクォートで囲まれた文字列のように扱われます。 
このことは正規表現の中で変数を使うことができるということを意味します。 ダブルクォートで囲まれた文字列のように、正規表現中の変数の値は 
マッチングのために正規表現が評価されるより前に置き換えが行われます。 ですから:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $foo </span><span class="pun">=</span><span class="pln"> </span><span class="str">'house'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">'housecat'</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$foo</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">'cathouse'</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cat$foo</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">'housecat'</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$</span><span class="pun">{</span><span class="pln">foo</span><span class="pun">}</span><span class="pln">cat</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $foo </span><span class="pun">=</span><span class="pln"> </span><span class="str">'house'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">'housecat'</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$foo</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">'cathouse'</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cat$foo</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">'housecat'</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$</span><span class="pun">{</span><span class="pln">foo</span><span class="pun">}</span><span class="pln">cat</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># マッチングする</span></code></pre>
<div class="original">
<p>So far, so good. With the knowledge above you can already perform 
searches with just about any literal string regexp you can dream up. 
Here is a <i>very simple</i> emulation of the Unix grep program:</p>
</div>
<p>今のところ順調です。 これまでの知識をもとに任意のリテラル文字列正規表現に関して 検索を行うことができます。 次の例は Unix の grep プログラムの <i>非常に単純な</i> 模倣です。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> cat </span><span class="pun">&gt;</span><span class="pln"> simple_grep<br>&nbsp; &nbsp; </span><span class="com">#!/usr/bin/perl</span><span class="pln"><br>&nbsp; &nbsp; $regexp </span><span class="pun">=</span><span class="pln"> shift</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(&lt;&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$regexp</span><span class="pun">/;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">^</span><span class="pln">D<br><br>&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> chmod </span><span class="pun">+</span><span class="pln">x simple_grep<br><br>&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> simple_grep abba </span><span class="pun">/</span><span class="pln">usr</span><span class="pun">/</span><span class="pln">dict</span><span class="pun">/</span><span class="pln">words<br>&nbsp; &nbsp; </span><span class="typ">Babbage</span><span class="pln"><br>&nbsp; &nbsp; cabbage<br>&nbsp; &nbsp; cabbages<br>&nbsp; &nbsp; sabbath<br>&nbsp; &nbsp; </span><span class="typ">Sabbathize</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Sabbathizes</span><span class="pln"><br>&nbsp; &nbsp; sabbatical<br>&nbsp; &nbsp; scabbard<br>&nbsp; &nbsp; scabbards</span></code></pre>
<div class="original">
<p>This program is easy to understand. <code>#!/usr/bin/perl</code> is the standard way to invoke a perl program from the shell. <span style="white-space: nowrap;"><code>$regexp = shift;</code></span>
 saves the first command line argument as the regexp to be used, leaving
 the rest of the command line arguments to be treated as files. <span style="white-space: nowrap;"><code>while (&lt;&gt;)</code></span> loops over all the lines in all the files. For each line, <span style="white-space: nowrap;"><code>print if /$regexp/;</code></span> prints the line if the regexp matches the line. In this line, both <code>print</code> and <code>/$regexp/</code> use the default variable <code>$_</code> implicitly.</p>
</div>
<p>このプログラムを理解するのは簡単です。 <code>#!/usr/bin/perl</code> はシェルから perl プログラムを起動する標準的な方法です。 <span style="white-space: nowrap;"><code>$regexp = shift;</code></span> は最初のコマンドライン引数を正規表現として使うために 保存します; そして残りのコマンドライン引数はファイルとして扱うために そのままにしておきます。 <span style="white-space: nowrap;"><code>while (&lt;&gt;)</code></span> ループはすべてのファイルのすべての行に対して 実行されます。 各行において、<span style="white-space: nowrap;"><code>print if /$regexp/;</code></span> はその行が正規表現に マッチングしていれば行の内容を出力します。 この行で、<code>print</code> と <code>/$regexp/</code> は暗黙にデフォルト変数 <code>$_</code> を 使用します。</p>
<div class="original">
<p>With all of the regexps above, if the regexp matched anywhere in the 
string, it was considered a match. Sometimes, however, we'd like to 
specify <i>where</i> in the string the regexp should try to match. To do this, we would use the <i>anchor</i> metacharacters <code>'^'</code> and <code>'$'</code>. The anchor <code>'^'</code> means match at the beginning of the string and the anchor <code>'$'</code> means match at the end of the string, or before a newline at the end of the string. Here is how they are used:</p>
</div>
<p>これまでの正規表現では、文字列のどこかでマッチングすればマッチングしたと みなしてきました。 しかし、ときには文字列の <i>どこで</i> 正規表現がマッチングするのかを 指定したいときがあります。 これを行うためには、<i>アンカー</i> メタ文字である <code>'^'</code> と <code>'$'</code> を使います。 アンカー <code>'^'</code> は文字列の先頭でマッチングすることを意味し、アンカー <code>'$'</code> は文字列の末尾(あるいは文字列の末尾にある改行の前) で マッチングすることを意味します。 以下に例を挙げます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"housekeeper"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">keeper</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"housekeeper"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">keeper</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># doesn't match</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"housekeeper"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">keeper$</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"housekeeper\n"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">keeper$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"housekeeper"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">keeper</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"housekeeper"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">keeper</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングしない</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"housekeeper"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">keeper$</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"housekeeper\n"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">keeper$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># マッチングする</span></code></pre>
<div class="original">
<p>The second regexp doesn't match because <code>'^'</code> constrains <code>keeper</code> to match only at the beginning of the string, but <code>"housekeeper"</code> has keeper starting in the middle. The third regexp does match, since the <code>'$'</code> constrains <code>keeper</code> to match only at the end of the string.</p>
</div>
<p>二番目の正規表現はマッチングしません; なぜなら、<code>'^'</code> は <code>keeper</code> が文字列の 先頭にあるときにのみマッチングすることを強制しますが、<code>"housekeeper"</code> は その先頭以外にkeeperを含んでいます。 三番目の正規表現は、<code>'$'</code> が <code>keeper</code> が文字列の末尾にあるときにのみ マッチングすることを強制しているのでマッチングします。</p>
<div class="original">
<p>When both <code>'^'</code> and <code>'$'</code> are used at the same time, the regexp has to match both the beginning and the end of the string, <i>i.e.</i>, the regexp matches the whole string. Consider</p>
</div>
<p><code>'^'</code> と <code>'$'</code> の両方が同時に使われた場合、その正規表現は文字列の先頭と 末尾両方にマッチングする必要があります; つまり、その正規表現は文字列全体に マッチングするのです。 以下の例で考えてみましょう</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"keeper"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">keep$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># doesn't match</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"keeper"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">keeper$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">""</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># ^$ matches an empty string</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"keeper"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">keep$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># マッチングしない</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"keeper"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">keeper$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">""</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># ^$ は空文字列にマッチングする</span></code></pre>
<div class="original">
<p>The first regexp doesn't match because the string has more to it than <code>keep</code>. Since the second regexp is exactly the string, it matches. Using both <code>'^'</code> and <code>'$'</code>
 in a regexp forces the complete string to match, so it gives you 
complete control over which strings match and which don't. Suppose you 
are looking for a fellow named bert, off in a string by himself:</p>
</div>
<p>最初の正規表現はマッチングしません; なぜなら、文字列は <code>keep</code> 以外のものを 持っているからです。 二番目の正規表現は正確に同じ文字列なのでマッチングします。 <code>'^'</code> と <code>'$'</code> を正規表現の中で使うことによって、文字列全体に マッチングすることを強制します; このため、どの文字列がマッチングしどの 文字列がマッチングしないかを完全に制御することができます。 bert という名前の仲間を探しているとしましょう:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"dogbert"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">bert</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># matches, but not what you want</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"dogbert"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">bert</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする; しかし望んだものではない</span></code></pre>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"dilbert"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">bert</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># doesn't match, but ..</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"bertram"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">bert</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches, so still not good enough</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"dilbert"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">bert</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングしない。しかし…</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"bertram"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">bert</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングする; ということはまだ十分ではない</span></code></pre>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"bertram"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">bert$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># doesn't match, good</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"dilbert"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">bert$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># doesn't match, good</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"bert"</span><span class="pln"> &nbsp; &nbsp;</span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">bert$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches, perfect</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"bertram"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">bert$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># マッチングしない; よし</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"dilbert"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">bert$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># マッチングしない; よし</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"bert"</span><span class="pln"> &nbsp; &nbsp;</span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">bert$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># マッチングする; 完璧</span></code></pre>
<div class="original">
<p>Of course, in the case of a literal string, one could just as easily use the string comparison <span style="white-space: nowrap;"><code>$string eq 'bert'</code></span> and it would be more efficient. The <code>^...$</code> regexp really becomes useful when we add in the more powerful regexp tools below.</p>
</div>
<p>もちろん、リテラル文字列の場合においては、文字列の比較を <span style="white-space: nowrap;"><code>$string eq 'bert'</code></span> を使って簡単に行うことができ、こちらのほうが より効率がよいです。 <code>^...$</code> 正規表現は以下に述べるより強力な正規表現ツールにおいて 便利になります。</p>
<h2 id="Using32character32classes">文字クラスを使う<a href="#Using32character32classes" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Although one can already do quite a lot with the literal string 
regexps above, we've only scratched the surface of regular expression 
technology. In this and subsequent sections we will introduce regexp 
concepts (and associated metacharacter notations) that will allow a 
regexp to represent not just a single character sequence, but a <i>whole class</i> of them.</p>
</div>
<p>先に述べたリテラル文字列の正規表現を使ってさえ多くのことができますが、 それは正規表現テクノロジーの表面をひっかいた程度に過ぎません。 このセクションと続くセクションでは、ただ一文字の文字を表すのではなく <i>文字のクラス全体</i> を表す正規表現のコンセプト (とそれに結び付けられた メタ文字表記)を紹介します。</p>
<div class="original">
<p>One such concept is that of a <i>character class</i>. A character 
class allows a set of possible characters, rather than just a single 
character, to match at a particular point in a regexp. You can define 
your own custom character classes. These are denoted by brackets <code>[...]</code>, with the set of characters to be possibly matched inside. Here are some examples:</p>
</div>
<p>そのようなコンセプトは <i>文字クラス</i> です。 文字クラスは正規表現の特定の場所においてマッチングする可能性のある文字の 集合です(単一の文字ではありません)。 独自のカスタム文字クラスを定義することができます。 これらはブラケット <code>[...]</code> で表現され、マッチングする可能性のある文字の 集合はその内側に置かれます。 以下にいくつか例を挙げます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">cat</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># matches 'cat'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[</span><span class="pln">bcr</span><span class="pun">]</span><span class="pln">at</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># matches 'bat, 'cat', or 'rat'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">item</span><span class="pun">[</span><span class="lit">0123456789</span><span class="pun">]/;</span><span class="pln"> &nbsp;</span><span class="com"># matches 'item0' or ... or 'item9'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"abc"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/[</span><span class="pln">cab</span><span class="pun">]/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># matches 'a'</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">cat</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># 'cat' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[</span><span class="pln">bcr</span><span class="pun">]</span><span class="pln">at</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># 'bat, 'cat', 'rat' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">item</span><span class="pun">[</span><span class="lit">0123456789</span><span class="pun">]/;</span><span class="pln"> &nbsp;</span><span class="com"># 'item0' または ... または 'item9' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"abc"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/[</span><span class="pln">cab</span><span class="pun">]/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># 'a' にマッチング</span></code></pre>
<div class="original">
<p>In the last statement, even though <code>'c'</code> is the first character in the class, <code>'a'</code> matches because the first character position in the string is the earliest point at which the regexp can match.</p>
</div>
<p>最後の文において、<code>'c'</code> がクラスの最初の文字であるにもかかわらず <code>'a'</code> がマッチングします; なぜなら、文字列の最初の文字位置が正規表現が マッチングすることのできる最初の位置にある文字だからです。</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/[</span><span class="pln">yY</span><span class="pun">][</span><span class="pln">eE</span><span class="pun">][</span><span class="pln">sS</span><span class="pun">]/;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># match 'yes' in a case-insensitive way</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># 'yes', 'Yes', 'YES', etc.</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/[</span><span class="pln">yY</span><span class="pun">][</span><span class="pln">eE</span><span class="pun">][</span><span class="pln">sS</span><span class="pun">]/;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># 大小文字を問わず 'yes' にマッチングする</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># 'yes', 'Yes', 'YES' など</span></code></pre>
<div class="original">
<p>This regexp displays a common task: perform a case-insensitive match.
 Perl provides a way of avoiding all those brackets by simply appending 
an <code>'i'</code> to the end of the match. Then <code>/[yY][eE][sS]/;</code> can be rewritten as <code>/yes/i;</code>. The <code>'i'</code> stands for case-insensitive and is an example of a <i>modifier</i> of the matching operation. We will meet other modifiers later in the tutorial.</p>
</div>
<p>この正規表現は一般的な仕事を表しています: 大小文字の違いを無視しての マッチングを行います。 Perl はこのようなブラケットを取り除くやり方を提供しています; それは マッチングの終端に <code>'i'</code> をつけることです。 したがって、<code>/[yY][eE][sS]/;</code> は <code>/yes/i;</code> と書き換えることができます。 この <code>'i'</code> は大小文字の違いを無視することを意味していて、マッチング操作の <i>修飾子</i> (modifier)の実例です。 本チュートリアルの後の方で他の修飾子がでてくることでしょう。</p>
<div class="original">
<p>We saw in the section above that there were ordinary characters, 
which represented themselves, and special characters, which needed a 
backslash <code>'\'</code> to represent themselves. The same is true in a
 character class, but the sets of ordinary and special characters inside
 a character class are different than those outside a character class. 
The special characters for a character class are <code>-]\^$</code> (and the pattern delimiter, whatever it is). <code>']'</code> is special because it denotes the end of a character class. <code>'$'</code> is special because it denotes a scalar variable. <code>'\'</code> is special because it is used in escape sequences, just like above. Here is how the special characters <code>]$\</code> are handled:</p>
</div>
<p>このセクションの前のほうで、自分自身を表す通常の文字と、 それ自身を表すためには バックスラッシュ <code>'\'</code> が必要な特殊文字があることを見てきました。 同じことが文字クラスの中でも言えます; しかし、文字クラスの内側にある通常の 文字と特殊文字の集合は、文字クラスの外側にあるものと異なります。 文字クラスのために特殊な文字は <code>-]\^$</code> (および(何であれ)デリミタ)です。 <code>']'</code> は文字クラスの終端を表すので特殊です。 <code>'$'</code> はスカラ変数を表すので特殊です。 <code>'\'</code> はエスケープシーケンスで使われるので特殊です。 以下は特殊文字 <code>]$\</code> を扱うやり方です:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/[\]</span><span class="pln">c</span><span class="pun">]</span><span class="pln">def</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches ']def' or 'cdef'</span><span class="pln"><br>&nbsp; &nbsp;$x </span><span class="pun">=</span><span class="pln"> </span><span class="str">'bcr'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="str">/[$x]at/</span><span class="pun">;</span><span class="pln"> &nbsp; </span><span class="com"># matches 'bat', 'cat', or 'rat'</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="pun">/[\</span><span class="pln">$x</span><span class="pun">]</span><span class="pln">at</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches '$at' or 'xat'</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="pun">/[\\</span><span class="pln">$x</span><span class="pun">]</span><span class="pln">at</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches '\at', 'bat, 'cat', or 'rat'</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/[\]</span><span class="pln">c</span><span class="pun">]</span><span class="pln">def</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># ']def' または 'cdef' にマッチング</span><span class="pln"><br>&nbsp; &nbsp;$x </span><span class="pun">=</span><span class="pln"> </span><span class="str">'bcr'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="str">/[$x]at/</span><span class="pun">;</span><span class="pln"> &nbsp; </span><span class="com"># 'bat', 'cat', 'rat' にマッチング</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="pun">/[\</span><span class="pln">$x</span><span class="pun">]</span><span class="pln">at</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># '$at' または 'xat' にマッチング</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="pun">/[\\</span><span class="pln">$x</span><span class="pun">]</span><span class="pln">at</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># '\at', 'bat, 'cat', 'rat' にマッチング</span></code></pre>
<div class="original">
<p>The last two are a little tricky. In <code>[\$x]</code>, the backslash protects the dollar sign, so the character class has two members <code>'$'</code> and <code>'x'</code>. In <code>[\\$x]</code>, the backslash is protected, so <code>$x</code> is treated as a variable and substituted in double quote fashion.</p>
</div>
<p>最後の二つはちょっとトリッキーです。 <code>[\$x]</code> の中ではバックスラッシュはドル記号を保護しているので、 文字クラスは <code>'$'</code> と <code>'x'</code> という二つのメンバを持ちます。 <code>[\\$x]</code> ではバックラッシュが保護されているので、<code>$x</code> は変数として 扱われ、ダブルクォート規則に従って置換が行われます。</p>
<div class="original">
<p>The special character <code>'-'</code> acts as a range operator 
within character classes, so that a contiguous set of characters can be 
written as a range. With ranges, the unwieldy <code>[0123456789]</code> and <code>[abc...xyz]</code> become the svelte <code>[0-9]</code> and <code>[a-z]</code>. Some examples are</p>
</div>
<p>特殊文字 <code>'-'</code> は文字クラスの中で範囲演算子として振舞います; このため、 連続した範囲の文字を一つの範囲として記述することができます。 範囲を使うことによって、<code>[0123456789]</code> や <code>[abc...xyz]</code> のような 見づらいものはすっきりとした <code>[0-9]</code> であるとか <code>[a-z]</code> のように 書き換えられます。 幾つか例を挙げましょう</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">item</span><span class="pun">[</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9</span><span class="pun">]/;</span><span class="pln"> &nbsp;</span><span class="com"># matches 'item0' or ... or 'item9'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9bx</span><span class="pun">-</span><span class="pln">z</span><span class="pun">]</span><span class="pln">aa</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches '0aa', ..., '9aa',</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 'baa', 'xaa', 'yaa', or 'zaa'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9a</span><span class="pun">-</span><span class="pln">fA</span><span class="pun">-</span><span class="pln">F</span><span class="pun">]/;</span><span class="pln"> &nbsp;</span><span class="com"># matches a hexadecimal digit</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9a</span><span class="pun">-</span><span class="pln">zA</span><span class="pun">-</span><span class="pln">Z_</span><span class="pun">]/;</span><span class="pln"> </span><span class="com"># matches a "word" character,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># like those in a Perl variable name</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">item</span><span class="pun">[</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9</span><span class="pun">]/;</span><span class="pln"> &nbsp;</span><span class="com"># 'item0' ... 'item9' にマッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9bx</span><span class="pun">-</span><span class="pln">z</span><span class="pun">]</span><span class="pln">aa</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># '0aa' ... '9aa', </span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 'baa', 'xaa', 'yaa', 'zaa' のいずれかにマッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9a</span><span class="pun">-</span><span class="pln">fA</span><span class="pun">-</span><span class="pln">F</span><span class="pun">]/;</span><span class="pln"> &nbsp;</span><span class="com"># 16 進数にマッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9a</span><span class="pun">-</span><span class="pln">zA</span><span class="pun">-</span><span class="pln">Z_</span><span class="pun">]/;</span><span class="pln"> </span><span class="com"># Perl の変数名のような</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 「単語」文字にマッチングする</span></code></pre>
<div class="original">
<p>If <code>'-'</code> is the first or last character in a character class, it is treated as an ordinary character; <code>[-ab]</code>, <code>[ab-]</code> and <code>[a\-b]</code> are all equivalent.</p>
</div>
<p><code>'-'</code> が文字クラスの中の最初か最後の文字であった場合、通常の文字として 扱われます; <code>[-ab]</code>, <code>[ab-]</code>, <code>[a\-b]</code> はすべて等価です。</p>
<div class="original">
<p>The special character <code>'^'</code> in the first position of a character class denotes a <i>negated character class</i>, which matches any character but those in the brackets. Both <code>[...]</code> and <code>[^...]</code> must match a character, or the match fails. Then</p>
</div>
<p>文字クラスの先頭の位置にある特殊文字 <code>'^'</code> は <i>反転文字クラス</i> を表し、 ブラケットの中にない文字にマッチングします。 <code>[...]</code> と <code>[^...]</code> の両方とも、一つの文字にマッチングせねばならず、 そうでない場合にはマッチングは失敗します。 ですから</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/[^</span><span class="pln">a</span><span class="pun">]</span><span class="pln">at</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># doesn't match 'aat' or 'at', but matches</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># all other 'bat', 'cat, '0at', '%at', etc.</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[^</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9</span><span class="pun">]/;</span><span class="pln"> &nbsp;</span><span class="com"># matches a non-numeric character</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[</span><span class="pln">a</span><span class="pun">^]</span><span class="pln">at</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches 'aat' or '^at'; here '^' is ordinary</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/[^</span><span class="pln">a</span><span class="pun">]</span><span class="pln">at</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 'aat' や 'at' にはマッチングしないが、その他の</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># 'bat', 'cat, '0at', '%at' などにはマッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[^</span><span class="lit">0</span><span class="pun">-</span><span class="lit">9</span><span class="pun">]/;</span><span class="pln"> &nbsp;</span><span class="com"># 数字以外にマッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[</span><span class="pln">a</span><span class="pun">^]</span><span class="pln">at</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 'aat' か '^at'にマッチングする; ここでは '^' は通常の文字</span></code></pre>
<div class="original">
<p>Now, even <code>[0-9]</code> can be a bother to write multiple times,
 so in the interest of saving keystrokes and making regexps more 
readable, Perl has several abbreviations for common character classes, 
as shown below. Since the introduction of Unicode, unless the <code>/a</code> modifier is in effect, these character classes match more than just a few characters in the ASCII range.</p>
</div>
<p>ここで、<code>[0-9]</code> でさえ何回も書くには面倒です; ですから、キーストロークの 数を抑えて、かつ正規表現をより読みやすくするために後述するように Perl は 一般的な文字クラスの略記法を持っています。 Unicode の導入のために、<code>/a</code> 修飾子が有効でない限り、これらの文字クラスは ASCII の範囲での数文字よりも多くマッチングします。</p>
<ul>
<li><p></p>
<div class="original">
<p><code>\d</code> matches a digit, not just <code>[0-9]</code> but also digits from non-roman scripts</p>
</div>
<p><code>\d</code> は数字にマッチングします; 単に <code>[0-9]</code> だけではなく、非ローマ字 スクリプトからの数字もマッチングします</p>
</li>
<li><p></p>
<div class="original">
<p><code>\s</code> matches a whitespace character, the set <code>[\ \t\r\n\f]</code> and others</p>
</div>
<p><code>\s</code> は空白文字にマッチングします; <code>[\ \t\r\n\f]</code> やその他のものです</p>
</li>
<li><p></p>
<div class="original">
<p><code>\w</code> matches a word character (alphanumeric or <code>'_'</code>), not just <code>[0-9a-zA-Z_]</code> but also digits and characters from non-roman scripts</p>
</div>
<p><code>\w</code> は単語を構成する文字(英数字 と <code>'_'</code>)にマッチングします; 単に <code>[0-9a-zA-Z_]</code> だけではなく、非ローマ字スクリプトからの数字と文字も マッチングします</p>
</li>
<li><p></p>
<div class="original">
<p><code>\D</code> is a negated <code>\d</code>; it represents any other character than a digit, or <code>[^\d]</code></p>
</div>
<p><code>\D</code> は <code>\d</code> の否定形です; 数字以外の文字、つまり <code>[^\d]</code> を表します。</p>
</li>
<li><p></p>
<div class="original">
<p><code>\S</code> is a negated <code>\s</code>; it represents any non-whitespace character <code>[^\s]</code></p>
</div>
<p><code>\S</code> は <code>\s</code> の否定形です; 非空白文字 <code>[^\s]</code> を表します。</p>
</li>
<li><p></p>
<div class="original">
<p><code>\W</code> is a negated <code>\w</code>; it represents any non-word character <code>[^\w]</code></p>
</div>
<p><code>\W</code> は <code>\w</code> の否定形です; 単語を構成しない文字 <code>[^\w]</code> を表します。</p>
</li>
<li><p></p>
<div class="original">
<p>The period <code>'.'</code> matches any character but <code>"\n"</code> (unless the modifier <code>/s</code> is in effect, as explained below).</p>
</div>
<p>ピリオド <code>'.'</code> は (以下に述べるように、修飾子 <code>//s</code> が有効でない限り) <code>"\n"</code> 以外の任意の文字にマッチングします。</p>
</li>
<li><p></p>
<div class="original">
<p><code>\N</code>, like the period, matches any character but <code>"\n"</code>, but it does so regardless of whether the modifier <code>/s</code> is in effect.</p>
</div>
<p><code>\N</code> は、ピリオドのように、<code>"\n"</code> 以外の任意の文字にマッチングしますが、 <code>/s</code> 修飾子が有効かどうかに関わらずマッチングします。</p>
</li>
</ul>
<div class="original">
<p>The <code>/a</code> modifier, available starting in Perl 5.14, is used to restrict the matches of <code>\d</code>, <code>\s</code>, and <code>\w</code>
 to just those in the ASCII range. It is useful to keep your program 
from being needlessly exposed to full Unicode (and its accompanying 
security considerations) when all you want is to process English-like 
text. (The "a" may be doubled, <code>/aa</code>, to provide even more 
restrictions, preventing case-insensitive matching of ASCII with 
non-ASCII characters; otherwise a Unicode "Kelvin Sign" would caselessly
 match a "k" or "K".)</p>
</div>
<p>Perl 5.14 から利用可能の <code>/a</code> 修飾子は、<code>\d</code>, <code>\s</code>, <code>\w</code> を ASCII の 範囲に制限するために使います。 これは、英語風のテキストを処理したいだけの時にプログラムを不必要に 完全な Unicode (とそれに関連するセキュリティの配慮) にさらされないように するのに有用です。 ("a" を重ねて <code>/aa</code>
 にするとさらに制限されて、ASCII 文字の大文字小文字を 無視したマッチングで非 ASCII 文字にマッチングしなくします; さもなければ、
 Unicode の "Kelvin Sign" は "k" や "K" に、大文字小文字を無視したマッチングが 成功します。)</p>
<div class="original">
<p>The <code>\d\s\w\D\S\W</code> abbreviations can be used both inside and outside of bracketed character classes. Here are some in use:</p>
</div>
<p><code>\d\s\w\D\S\W</code> の省略記法は大かっこ文字クラスの内側でも外側でも 使うことができます。 以下はその例です:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">:\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">:\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches a hh:mm:ss time format</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">s</span><span class="pun">]/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># matches any digit or whitespace character</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/\</span><span class="pln">w</span><span class="pun">\</span><span class="pln">W</span><span class="pun">\</span><span class="pln">w</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># matches a word char, followed by a</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># non-word char, followed by a word char</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/..</span><span class="pln">rt</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># matches any two chars, followed by 'rt'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">end</span><span class="pun">\./;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># matches 'end.'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">end</span><span class="pun">[.]/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># same thing, matches 'end.'</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">:\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">:\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># hh:mm:ss 形式の時間表記にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/[\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">s</span><span class="pun">]/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 数字または空白にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/\</span><span class="pln">w</span><span class="pun">\</span><span class="pln">W</span><span class="pun">\</span><span class="pln">w</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 非単語文字が続きさらに単語文字が続く</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 単語文字にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/..</span><span class="pln">rt</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 'rt' が続く任意の二文字にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">end</span><span class="pun">\./;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># 'end.' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">end</span><span class="pun">[.]/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 同じこと; 'end.' にマッチング</span></code></pre>
<div class="original">
<p>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, <code>\d</code> and <code>\w</code> are sets of characters, it is incorrect to think of <code>[^\d\w]</code> as <code>[\D\W]</code>; in fact <code>[^\d\w]</code> is the same as <code>[^\w]</code>, which is the same as <code>[\W]</code>. Think DeMorgan's laws.</p>
</div>
<p>ピリオドはメタ文字なので、ピリオドそのものにマッチングさせるにはエスケープする 必要があります。 <code>\d</code> や <code>\w</code> は文字の集合なので <code>[^\d\w]</code> を <code>[\D\W]</code> とみなすのは 間違いです; 事実、<code>[^\d\w]</code> は <code>[^\w]</code> と同じであり、これは <code>[\W]</code> と 等価です。 ド・モルガンの法則を考えてみてください。</p>
<div class="original">
<p>In actuality, the period and <code>\d\s\w\D\S\W</code> abbreviations 
are themselves types of character classes, so the ones surrounded by 
brackets are just one type of character class. When we need to make a 
distinction, we refer to them as "bracketed character classes."</p>
</div>
<p>実情としては、ピリオドと <code>\d\s\w\D\S\W</code> の省略形はそれ自身ある種の 文字クラスなので、これらを大かっこで囲んだものは単にある種の文字クラスです。 これを区別する必要がある時には、これらは「大かっこ文字クラス」 (bracketed character classes)と呼びます。</p>
<div class="original">
<p>An anchor useful in basic regexps is the <i>word anchor</i> <code>\b</code>. This matches a boundary between a word character and a non-word character <code>\w\W</code> or <code>\W\w</code>:</p>
</div>
<p>基本的な正規表現で便利なアンカーに <i>語アンカー</i> (word anchor)の <code>\b</code> があります。 これは単語を構成する文字と単語を構成しない文字の間 <code>\w\W</code> や <code>\W\w</code> の 境界にマッチングします:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Housecat catenates house and cat"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cat</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># matches cat in 'housecat'</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">bcat</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches cat in 'catenates'</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cat</span><span class="pun">\</span><span class="pln">b</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches cat in 'housecat'</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">bcat</span><span class="pun">\</span><span class="pln">b</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches 'cat' at end of string</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Housecat catenates house and cat"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cat</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># 'housecat' の cat にマッチング</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">bcat</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 'catenates' の cat にマッチング</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cat</span><span class="pun">\</span><span class="pln">b</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 'housecat' の cat にマッチング</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">bcat</span><span class="pun">\</span><span class="pln">b</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 文字列の終端の'cat'にマッチング</span></code></pre>
<div class="original">
<p>Note in the last example, the end of the string is considered a word boundary.</p>
</div>
<p>最後の例に注意してください; 文字列の終端は単語境界として認識されています。</p>
<div class="original">
<p>For natural language processing (so that, for example, apostrophes are included in words), use instead <code>\b{wb}</code></p>
</div>
<p>自然言語処理のため (そのために、例えば、アポストロフィを単語に含める) なら、 代わりに <code>\b{wb}</code> を使います</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"don't"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="pun">.+?</span><span class="pln"> </span><span class="pun">\</span><span class="pln">b</span><span class="pun">{</span><span class="pln">wb</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># matches the whole string</span></code></pre>
<div class="original">
<p>You might wonder why <code>'.'</code> matches everything but <code>"\n"</code>
 - why not every character? The reason is that often one is matching 
against lines and would like to ignore the newline characters. For 
instance, while the string <code>"\n"</code> represents one line, we would like to think of it as empty. Then</p>
</div>
<p><code>'.'</code> が <code>"\n"</code> 以外の任意の文字にマッチングすることに疑問を感じるかも しれません - なぜすべての文字ではないのでしょうか? その答えはマッチングがしばしば行に対して行われ、改行文字を 無視したいからです。 たとえば、文字列 <code>"\n"</code> が一行を表していたとして、それを空の行として みなしたいでしょう。 ですから</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">""</span><span class="pln"> &nbsp; </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"\n"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># matches, $ anchors before "\n"</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">""</span><span class="pln"> &nbsp; </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># マッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"\n"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># マッチング; "\n" は無視される</span></code></pre>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">""</span><span class="pln"> &nbsp; </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/./;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># doesn't match; it needs a char</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">""</span><span class="pln"> &nbsp; </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^.</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># doesn't match; it needs a char</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"\n"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^.</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># doesn't match; it needs a char other than "\n"</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"a"</span><span class="pln"> &nbsp;</span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^.</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"a\n"</span><span class="pln"> &nbsp;</span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^.</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches, $ anchors before "\n"</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">""</span><span class="pln"> &nbsp; </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/./;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># マッチングしない; キャラクタが必要</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">""</span><span class="pln"> &nbsp; </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^.</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># マッチングしない; キャラクタが必要</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"\n"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^.</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># マッチングしない; "\n" 以外のキャラクタが必要</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"a"</span><span class="pln"> &nbsp;</span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^.</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"a\n"</span><span class="pln"> &nbsp;</span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^.</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングする; "\n" は無視される</span></code></pre>
<div class="original">
<p>This behavior is convenient, because we usually want to ignore 
newlines when we count and match characters in a line. Sometimes, 
however, we want to keep track of newlines. We might even want <code>'^'</code> and <code>'$'</code>
 to anchor at the beginning and end of lines within the string, rather 
than just the beginning and end of the string. Perl allows us to choose 
between ignoring and paying attention to newlines by using the <code>/s</code> and <code>/m</code> modifiers. <code>/s</code> and <code>/m</code>
 stand for single line and multi-line and they determine whether a 
string is to be treated as one continuous string, or as a set of lines. 
The two modifiers affect two aspects of how the regexp is interpreted: 
1) how the <code>'.'</code> character class is defined, and 2) where the anchors <code>'^'</code> and <code>'$'</code> are able to match. Here are the four possible combinations:</p>
</div>
<p>通常はある行において文字を数えたりマッチングしたりするときには改行を 無視したいので、この動作は便利です。 しかし、ときとして改行を保存したいときがあります。 <code>'^'</code> や <code>'$'</code> を文字列の先頭や末尾ではなく行の先頭や末尾に対するアンカーと したいときがあるでしょう。 Perl は <code>/s</code> 修飾子や <code>/m</code> 修飾子を使うことによって改行を無視したり 考慮したりすることを選択することを許しています。 <code>/s</code> と <code>/m</code> はそれぞれ単一行(single line)と複数行(multi-line)を意味し、 文字列を連続した文字としてみなすか行の集合としてみなすかを決定します。 これら二つの修飾子は正規表現がどのように解釈されるかに関して二つの影響を 及ぼします: 1) <code>'.'</code> 文字クラスがどのように定義されるか 2) アンカー <code>'^'</code> と <code>'$'</code> がどこにマッチングできるかです。 四つの可能な組み合わせがあります:</p>
<ul>
<li><p></p>
<div class="original">
<p>no modifiers: Default behavior. <code>'.'</code> matches any character except <code>"\n"</code>. <code>'^'</code> matches only at the beginning of the string and <code>'$'</code> matches only at the end or before a newline at the end.</p>
</div>
<p>修飾子なし: デフォルトの動作です。 <code>'.'</code> は <code>"\n"</code> 以外の任意の文字にマッチングします。 <code>'^'</code> は文字列の先頭にのみマッチングし、<code>'$'</code> は文字列の末尾もしくは 終端にある改行の直前にのみマッチングします。</p>
</li>
<li><p></p>
<div class="original">
<p>s modifier (<code>/s</code>): Treat string as a single long line. <code>'.'</code> matches any character, even <code>"\n"</code>. <code>'^'</code> matches only at the beginning of the string and <code>'$'</code> matches only at the end or before a newline at the end.</p>
</div>
<p>s 修飾子 (<code>/s</code>): 文字列を一つの長い行としてみなします。 <code>'.'</code> は <code>"\n"</code> を含めた任意の文字にマッチングします。 <code>'^'</code> は文字列の先頭にのみマッチングし、<code>'$'</code> は文字列の末尾もしくは 終端にある改行の直前にのみマッチングします。</p>
</li>
<li><p></p>
<div class="original">
<p>m modifier (<code>/m</code>): Treat string as a set of multiple lines. <code>'.'</code> matches any character except <code>"\n"</code>. <code>'^'</code> and <code>'$'</code> are able to match at the start or end of <i>any</i> line within the string.</p>
</div>
<p>m 修飾子 (<code>/m</code>): 文字列を複数行の集合としてみなします。 <code>'.'</code> は <code>"\n"</code> 以外の任意の文字にマッチングします。 <code>'^'</code> と <code>'$'</code> はそれぞれ文字列中の任意の行の先頭と末尾にマッチングします。</p>
</li>
<li><p></p>
<div class="original">
<p>both s and m modifiers (<code>/sm</code>): Treat string as a single long line, but detect multiple lines. <code>'.'</code> matches any character, even <code>"\n"</code>. <code>'^'</code> and <code>'$'</code>, however, are able to match at the start or end of <i>any</i> line within the string.</p>
</div>
<p>s 修飾子と m 修飾子の両方 (<code>/sm</code>): 文字列を単一の長い行としてみなしますが、 複数行を検出します。 <code>'.'</code> は <code>"\n"</code> を含めた任意の文字にマッチングします。 しかし、<code>'^'</code> と <code>'$'</code> はそれぞれ文字列中の任意の行の先頭と末尾に マッチングすることが可能です。</p>
</li>
</ul>
<div class="original">
<p>Here are examples of <code>/s</code> and <code>/m</code> in action:</p>
</div>
<p>以下はアクション中の <code>/s</code> と <code>/m</code> の例です:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"There once was a girl\nWho programmed in Perl\n"</span><span class="pun">;</span></code></pre>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="typ">Who</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># doesn't match, "Who" not at start of string</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># doesn't match, "Who" not at start of string</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># matches, "Who" at start of second line</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">sm</span><span class="pun">;</span><span class="pln"> </span><span class="com"># matches, "Who" at start of second line</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="typ">Who</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングしない; "Who" は文字列の先頭にはない</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングしない; "Who" は文字列の先頭にはない</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングする; "Who" は二行目の先頭にある</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">sm</span><span class="pun">;</span><span class="pln"> </span><span class="com"># マッチングする; "Who" は二行目の先頭にある</span></code></pre>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl</span><span class="pun">.</span><span class="typ">Who</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># doesn't match, "." doesn't match "\n"</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl</span><span class="pun">.</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># matches, "." matches "\n"</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl</span><span class="pun">.</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># doesn't match, "." doesn't match "\n"</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl</span><span class="pun">.</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">sm</span><span class="pun">;</span><span class="pln"> </span><span class="com"># matches, "." matches "\n"</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl</span><span class="pun">.</span><span class="typ">Who</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングしない; "." は "\n" にマッチングしない</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl</span><span class="pun">.</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングする; "." は "\n"にマッチングする</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl</span><span class="pun">.</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングしない; "." は "\n" にマッチングしない</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl</span><span class="pun">.</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">sm</span><span class="pun">;</span><span class="pln"> </span><span class="com"># マッチングする; "." は "\n"にマッチングする</span></code></pre>
<div class="original">
<p>Most of the time, the default behavior is what is wanted, but <code>/s</code> and <code>/m</code> are occasionally very useful. If <code>/m</code> is being used, the start of the string can still be matched with <code>\A</code> and the end of the string can still be matched with the anchors <code>\Z</code> (matches both the end and the newline before, like <code>'$'</code>), and <code>\z</code> (matches only the end):</p>
</div>
<p>ほとんどの場合、デフォルトの動作が望んでいるものですが、<code>/s</code> や <code>/m</code> はとても便利なものです。 もし <code>/m</code> を使っているのなら、文字列の先頭は <code>\A</code> で マッチングさせることができ、文字列の末尾はアンカー <code>\Z</code> (<code>'$'</code> と 同じように、末尾と末尾にある改行の直前にマッチングします) や <code>\z</code> (末尾にのみマッチング)でマッチングさせることができます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> &nbsp; </span><span class="com"># matches, "Who" at start of second line</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="typ">AWho</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># doesn't match, "Who" is not at start of string</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="typ">Who</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする; "Who" は二行目の先頭にある</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="typ">AWho</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングしない; "Who" は文字列の先頭にはない</span></code></pre>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl$</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># matches, "girl" at end of first line</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl</span><span class="pun">\</span><span class="pln">Z</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> </span><span class="com"># doesn't match, "girl" is not at end of string</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl$</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングする; "girl" は一行目の末尾にある</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">girl</span><span class="pun">\</span><span class="pln">Z</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> </span><span class="com"># マッチングしない; "girl" は文字列の末尾にはない</span></code></pre>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="typ">Perl</span><span class="pun">\</span><span class="pln">Z</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> </span><span class="com"># matches, "Perl" is at newline before end</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="typ">Perl</span><span class="pun">\</span><span class="pln">z</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> </span><span class="com"># doesn't match, "Perl" is not at end of string</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="typ">Perl</span><span class="pun">\</span><span class="pln">Z</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> </span><span class="com"># マッチングする; "Perl" は末尾の直前にある改行の前にある</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="typ">Perl</span><span class="pun">\</span><span class="pln">z</span><span class="pun">/</span><span class="pln">m</span><span class="pun">;</span><span class="pln"> </span><span class="com"># マッチングしない; "Perl" は文字列の末尾にはない</span></code></pre>
<div class="original">
<p>We now know how to create choices among classes of characters in a 
regexp. What about choices among words or character strings? Such 
choices are described in the next section.</p>
</div>
<p>正規表現中で文字クラスをどのように選択するかを学びました。 単語や文字並びに関する選択は? その選択は次のセクションで述べます。</p>
<h2 id="Matching32this32or32that">あれやこれやにマッチングする<a href="#Matching32this32or32that" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Sometimes we would like our regexp to be able to match different 
possible words or character strings. This is accomplished by using the <i>alternation</i> metacharacter <code>'|'</code>. To match <code>dog</code> or <code>cat</code>, we form the regexp <code>dog|cat</code>.
 As before, Perl will try to match the regexp at the earliest possible 
point in the string. At each character position, Perl will first try to 
match the first alternative, <code>dog</code>. If <code>dog</code> doesn't match, Perl will then try the next alternative, <code>cat</code>. If <code>cat</code> doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</p>
</div>
<p>正規表現を異なる単語や文字並びにマッチングさせたいと考えることがあるでしょう。 これは <i>選択</i> メタ文字 <code>'|'</code> によって行うことができます。 <code>dog</code> または <code>cat</code> にマッチングさせるには、正規表現を <code>dog|cat</code> のようにします。 以前述べた通り、Perlは文字列の可能な限り最も早い位置でマッチングを 行おうとします。 それぞれの文字位置で、Perlはまずはじめに最初の選択である <code>dog</code> に マッチングさせることを試みます。 もし <code>dog</code> がマッチングしなければ、Perl は次の選択肢である <code>cat</code> を 試します。 <code>cat</code> もまたマッチングしなければ、マッチングは失敗してPerlは文字列の次の 位置に移動します。 幾つか例を挙げましょう:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"cats and dogs"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cat</span><span class="pun">|</span><span class="pln">dog</span><span class="pun">|</span><span class="pln">bird</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches "cat"</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"cats and dogs"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">dog</span><span class="pun">|</span><span class="pln">cat</span><span class="pun">|</span><span class="pln">bird</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches "cat"</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"cats and dogs"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cat</span><span class="pun">|</span><span class="pln">dog</span><span class="pun">|</span><span class="pln">bird</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># "cat" にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"cats and dogs"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">dog</span><span class="pun">|</span><span class="pln">cat</span><span class="pun">|</span><span class="pln">bird</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># "cat" にマッチング</span></code></pre>
<div class="original">
<p>Even though <code>dog</code> is the first alternative in the second regexp, <code>cat</code> is able to match earlier in the string.</p>
</div>
<p>二番目の正規表現において最初の選択肢が <code>dog</code> であるにもかかわらず、 <code>cat</code> が文字列で最初に現れるマッチング対象です。</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"cats"</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">c</span><span class="pun">|</span><span class="pln">ca</span><span class="pun">|</span><span class="pln">cat</span><span class="pun">|</span><span class="pln">cats</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches "c"</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"cats"</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cats</span><span class="pun">|</span><span class="pln">cat</span><span class="pun">|</span><span class="pln">ca</span><span class="pun">|</span><span class="pln">c</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches "cats"</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"cats"</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">c</span><span class="pun">|</span><span class="pln">ca</span><span class="pun">|</span><span class="pln">cat</span><span class="pun">|</span><span class="pln">cats</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># "c" にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"cats"</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cats</span><span class="pun">|</span><span class="pln">cat</span><span class="pun">|</span><span class="pln">ca</span><span class="pun">|</span><span class="pln">c</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># "cats" にマッチング</span></code></pre>
<div class="original">
<p>Here, all the alternatives match at the first string position, so the
 first alternative is the one that matches. If some of the alternatives 
are truncations of the others, put the longest ones first to give them a
 chance to match.</p>
</div>
<p>ここではすべての選択肢が最初の位置でマッチングするので、最初の選択肢が マッチング対象となります。 もし一部の選択肢が他の選択肢を縮めたものであるならば、マッチングのチャンスを 与えるために最も長いものを最初に置きます。</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"cab"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">a</span><span class="pun">|</span><span class="pln">b</span><span class="pun">|</span><span class="pln">c</span><span class="pun">/</span><span class="pln"> </span><span class="com"># matches "c"</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># /a|b|c/ == /[abc]/</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"cab"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">a</span><span class="pun">|</span><span class="pln">b</span><span class="pun">|</span><span class="pln">c</span><span class="pun">/</span><span class="pln"> </span><span class="com"># "c" にマッチング</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># /a|b|c/ == /[abc]/</span></code></pre>
<div class="original">
<p>The last example points out that character classes are like 
alternations of characters. At a given character position, the first 
alternative that allows the regexp match to succeed will be the one that
 matches.</p>
</div>
<p>この最後の例は文字クラスが文字の選択に似ていることを表しています。 与えられた文字位置で、正規表現のマッチングを成功させるための 最初の選択肢はマッチングする一つとなります。</p>
<h2 id="Grouping32things32and32hierarchical32matching">グループ化と階層的マッチング<a href="#Grouping32things32and32hierarchical32matching" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Alternation allows a regexp to choose among alternatives, but by 
itself it is unsatisfying. The reason is that each alternative is a 
whole regexp, but sometime we want alternatives for just part of a 
regexp. For instance, suppose we want to search for housecats or 
housekeepers. The regexp <code>housecat|housekeeper</code> fits the bill, but is inefficient because we had to type <code>house</code> twice. It would be nice to have parts of the regexp be constant, like <code>house</code>, and some parts have alternatives, like <code>cat|keeper</code>.</p>
</div>
<p>選択は正規表現が選択肢の中から選び出すことを許しますが、それ自身は 満足できるものではありません。 
その理由は、各選択肢は正規表現全体でなければならないのに、正規表現の 一部だけを選択したいときがあるからです。 たとえば、housecats か
 housekeepers を検索したいとしましょう。 <code>housecat|housekeeper</code> という正規表現はそれができます; しかし、<code>house</code> を 二回タイプしなければならないので効率がよくありません。 正規表現の一部分を <code>house</code> のように定数にできて、そして一部が <code>cat|keeper</code> のように選択肢を持つようにできればよいのです。</p>
<div class="original">
<p>The <i>grouping</i> metacharacters <code>()</code> solve this 
problem. Grouping allows parts of a regexp to be treated as a single 
unit. Parts of a regexp are grouped by enclosing them in parentheses. 
Thus we could solve the <code>housecat|housekeeper</code> by forming the regexp as <code>house(cat|keeper)</code>. The regexp <code>house(cat|keeper)</code> means match <code>house</code> followed by either <code>cat</code> or <code>keeper</code>. Some more examples are</p>
</div>
<p><i>グループ化</i> メタ文字 <code>()</code> はこの問題を解決します。 グループ化は正規表現の一部分を一つのユニットとして扱うことを許します。 ある正規表現の一部はカッコによって囲まれることでグループ化されます。 したがって、<code>housecat|housekeeper</code> は正規表現を <code>house(cat|keeper)</code> と することによって解決することができます。 正規表現 <code>house(cat|keeper)</code> は、<code>cat</code> か <code>keeper</code> が後続する <code>house</code> にマッチングすることを意味します。 幾つか例を挙げましょう</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/(</span><span class="pln">a</span><span class="pun">|</span><span class="pln">b</span><span class="pun">)</span><span class="pln">b</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># matches 'ab' or 'bb'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/(</span><span class="pln">ac</span><span class="pun">|</span><span class="pln">b</span><span class="pun">)</span><span class="pln">b</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># matches 'acb' or 'bb'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/(^</span><span class="pln">a</span><span class="pun">|</span><span class="pln">b</span><span class="pun">)</span><span class="pln">c</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># matches 'ac' at start of string or 'bc' anywhere</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/(</span><span class="pln">a</span><span class="pun">|[</span><span class="pln">bc</span><span class="pun">])</span><span class="pln">d</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches 'ad', 'bd', or 'cd'</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/(</span><span class="pln">a</span><span class="pun">|</span><span class="pln">b</span><span class="pun">)</span><span class="pln">b</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># 'ab' または 'bb' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/(</span><span class="pln">ac</span><span class="pun">|</span><span class="pln">b</span><span class="pun">)</span><span class="pln">b</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># 'acb' または 'bb' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/(^</span><span class="pln">a</span><span class="pun">|</span><span class="pln">b</span><span class="pun">)</span><span class="pln">c</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># 文字列の先頭にある 'ac' か任意の場所の'bc'にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/(</span><span class="pln">a</span><span class="pun">|[</span><span class="pln">bc</span><span class="pun">])</span><span class="pln">d</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># 'ad', 'bd', 'cd' にマッチング</span></code></pre>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">house</span><span class="pun">(</span><span class="pln">cat</span><span class="pun">|)/;</span><span class="pln"> &nbsp;</span><span class="com"># matches either 'housecat' or 'house'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">house</span><span class="pun">(</span><span class="pln">cat</span><span class="pun">(</span><span class="pln">s</span><span class="pun">|)|)/;</span><span class="pln"> &nbsp;</span><span class="com"># matches either 'housecats' or 'housecat' or</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 'house'. &nbsp;Note groups can be nested.</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">house</span><span class="pun">(</span><span class="pln">cat</span><span class="pun">|)/;</span><span class="pln"> &nbsp;</span><span class="com"># 'housecat' か 'house' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">house</span><span class="pun">(</span><span class="pln">cat</span><span class="pun">(</span><span class="pln">s</span><span class="pun">|)|)/;</span><span class="pln"> &nbsp;</span><span class="com"># 'housecats' か 'housecat' か 'house' のいずれかに</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># マッチング。グループがネストできることに注意</span></code></pre>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/(</span><span class="lit">19</span><span class="pun">|</span><span class="lit">20</span><span class="pun">|)\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># match years 19xx, 20xx, or the Y2K problem, xx</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"20"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(</span><span class="lit">19</span><span class="pun">|</span><span class="lit">20</span><span class="pun">|)\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches the null alternative '()\d\d',</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># because '20\d\d' can't match</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/(</span><span class="lit">19</span><span class="pun">|</span><span class="lit">20</span><span class="pun">|)\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 年を表す19xx, 20xx か 2000 年問題を持つ xx にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"20"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(</span><span class="lit">19</span><span class="pun">|</span><span class="lit">20</span><span class="pun">|)\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 空の選択肢 '()\d\d' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># '20\d\d' はマッチングできないから</span></code></pre>
<div class="original">
<p>Alternations behave the same way in groups as out of them: at a given
 string position, the leftmost alternative that allows the regexp to 
match is taken. So in the last example at the first string position, <code>"20"</code> matches the second alternative, but there is nothing left over to match the next two digits <code>\d\d</code>. So Perl moves on to the next alternative, which is the null alternative and that works, since <code>"20"</code> is two digits.</p>
</div>
<p>選択はグループの中でもその外側と同じように振舞います: 文字列の与えられた 場所で、正規表現がマッチングする最も左にある選択肢が選ばれます。 ですから、最後の例では最初の文字列位置で二番目の選択肢 <code>"20"</code> に マッチングしますが、残りの二つの数字 <code>\d\d</code> にマッチングするものが 残っていません。 このため、Perlは次の選択肢へと移り、<code>"20"</code> が二つの数字なので空の選択肢で うまくいきます。</p>
<div class="original">
<p>The process of trying one alternative, seeing if it matches, and 
moving on to the next alternative, while going back in the string from 
where the previous alternative was tried, if it doesn't, is called <i>backtracking</i>.
 The term "backtracking" comes from the idea that matching a regexp is 
like a walk in the woods. Successfully matching a regexp is like 
arriving at a destination. There are many possible trailheads, one for 
each string position, and each one is tried in order, left to right. 
From each trailhead there may be many paths, some of which get you 
there, and some which are dead ends. When you walk along a trail and hit
 a dead end, you have to backtrack along the trail to an earlier point 
to try another trail. If you hit your destination, you stop immediately 
and forget about trying all the other trails. You are persistent, and 
only if you have tried all the trails from all the trailheads and not 
arrived at your destination, do you declare failure. To be concrete, 
here is a step-by-step analysis of what Perl does when it tries to match
 the regexp</p>
</div>
<p>ある選択肢を試し、マッチングすればそれを選んで次の選択肢へ移り、 マッチングしなければ文字列の以前の選択肢を試した場所に戻る、 という手順は <i>バックトラッキング</i>
 (backtracking)と呼ばれます。 'バックトラッキング'という単語は正規表現のマッチングが森の中の散歩に 
似ていることからきています。 正規表現のマッチングが成功することは目的地にたどり着くことです。 
多くの起点があり、文字列の各位置のひとつで左から右へと順序だてて 一つ一つ試します。 
それぞれの起点からは多くの通り道があり、どれかはあなたが目指す場所で 他のどれかは行き止まりになっています。 
歩いていて行き止まりに当たったら、あなたはもと来た道を後戻り(backtrack)して 別の道を試してみなければなりません。 
目的地に着いたなら、即座に止まって他の道は忘れてしまいます。 あなたは粘り強いので、すべての起点からすべての通り道を試してそれでも 
目的地に着かなければ、失敗を宣言します。 具体的に、Perl が正規表現のマッチングを試しているときに行っていることを 
ステップを追って説明しましょう</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"abcde"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(</span><span class="pln">abd</span><span class="pun">|</span><span class="pln">abc</span><span class="pun">)(</span><span class="pln">df</span><span class="pun">|</span><span class="pln">d</span><span class="pun">|</span><span class="pln">de</span><span class="pun">)/;</span></code></pre>
<dl>
<dt>0. Start with the first letter in the string <code>'a'</code>.</dt>
<dd>
<p>(0. 文字列の最初の文字 <code>'a'</code> から始めます。)</p>
<p>&nbsp;</p>
</dd>
<dt>1. Try the first alternative in the first group <code>'abd'</code>.</dt>
<dd>
<p>(1. 最初のグループの中の最初の選択肢 <code>'abd'</code> を試します。)</p>
<p>&nbsp;</p>
</dd>
<dt>2. Match <code>'a'</code> followed by <code>'b'</code>. So far so good.</dt>
<dd>
<p>(2. <code>'a'</code> とそれに続く <code>'b'</code> にマッチングします。よさそうです。)</p>
<p>&nbsp;</p>
</dd>
<dt>3. <code>'d'</code> in the regexp doesn't match <code>'c'</code> in the string - a dead end. So backtrack two characters and pick the second alternative in the first group <code>'abc'</code>.</dt>
<dd>
<p>(正規表現中の <code>'d'</code> は文字列中の <code>'c'</code> にマッチングしません - 行き止まりです。このため、二文字後戻りして最初のグループの二番目の選択肢である <code>'abc'</code> を取り出します。)</p>
<p>&nbsp;</p>
</dd>
<dt>4. Match <code>'a'</code> followed by <code>'b'</code> followed by <code>'c'</code>. We are on a roll and have satisfied the first group. Set <code>$1</code> to <code>'abc'</code>.</dt>
<dd>
<p>(<code>'a'</code>, <code>'b'</code>, <code>'c'</code> と続けてマッチングします。ここで最初のグループが満足されました。<code>$1</code> に <code>'abc'</code> をセットします。)</p>
<p>&nbsp;</p>
</dd>
<dt>5 Move on to the second group and pick the first alternative <code>'df'</code>.</dt>
<dd>
<p>(二番目のグループへ移動して、最初の選択肢である <code>'df'</code> を取り出します。)</p>
<p>&nbsp;</p>
</dd>
<dt>6 Match the <code>'d'</code>.</dt>
<dd>
<p>(<code>'d'</code> にマッチングします。)</p>
<p>&nbsp;</p>
</dd>
<dt>7. <code>'f'</code> in the regexp doesn't match <code>'e'</code> in the string, so a dead end. Backtrack one character and pick the second alternative in the second group <code>'d'</code>.</dt>
<dd>
<p>(正規表現中の <code>'f'</code> は文字列中の <code>'e'</code> にマッチングしません; 行き止まりです。一文字後戻りして二番目のグループの二番目の選択肢 <code>'d'</code> を取り出します。)</p>
<p>&nbsp;</p>
</dd>
<dt>8. <code>'d'</code> matches. The second grouping is satisfied, so set <code>$2</code> to <code>'d'</code>.</dt>
<dd>
<p>(<code>'d'</code> にマッチングします。二番目のグループは満足されたので、<code>$2</code> に <code>'d'</code> をセットします。)</p>
<p>&nbsp;</p>
</dd>
<dt>9. We are at the end of the regexp, so we are done! We have matched <code>'abcd'</code> out of the string <code>"abcde"</code>.</dt>
<dd>
<p>(正規表現の終端に達しました; これで終わりです!文字列 <code>"abcde"</code> に対して <code>'abcd'</code> がマッチングしました。)</p>
</dd>
</dl>
<div class="original">
<p>There are a couple of things to note about this analysis. First, the third alternative in the second group <code>'de'</code>
 also allows a match, but we stopped before we got to it - at a given 
character position, leftmost wins. Second, we were able to get a match 
at the first character position of the string <code>'a'</code>. If there were no matches at the first position, Perl would move to the second character position <code>'b'</code>
 and attempt the match all over again. Only when all possible paths at 
all possible character positions have been exhausted does Perl give up 
and declare <span style="white-space: nowrap;"><code>$string =~ /(abd|abc)(df|d|de)/;</code></span> to be false.</p>
</div>
<p>この調査に関して注意すべき点が二、三あります。 第一に、二番目のグループの三番目の選択肢 <code>'de'</code> もまたマッチングしますが、 そこに行く前に停止しました - 与えられた文字の位置で、最も左のものが 優先されるからです。 第二に、文字列の最初の文字が <code>'a'</code> であったのでマッチングできました。 もし最初の位置でマッチングに成功しなければ、Perl は二番目にある文字 <code>'b'</code> へと移動して同じことを繰り返します。 すべての可能な文字位置で、すべての可能な道筋が尽きたときにのみ Perl は マッチングをあきらめ、 <span style="white-space: nowrap;"><code>$string =~ /(abd|abc)(df|d|de)/;</code></span> が失敗したと宣言します。</p>
<div class="original">
<p>Even with all this work, regexp matching happens remarkably fast. To 
speed things up, Perl compiles the regexp into a compact sequence of 
opcodes that can often fit inside a processor cache. When the code is 
executed, these opcodes can then run at full throttle and search very 
quickly.</p>
</div>
<p>これだけのことを行ってさえ、正規表現のマッチングは目立って速いものです。 検索速度を向上させるために、Perl 
は正規表現をコンパクトでしばしば プロセッサのキャッシュに納まるようなオペコードの並びへと変換します。 
そのコードが実行されたとき、これらのオペコードはフルスロットルで 走ることができて非常にすばやく検索します。</p>
<h2 id="Extracting32matches">マッチングしたものを取り出す<a href="#Extracting32matches" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>The grouping metacharacters <code>()</code> also serve another 
completely different function: they allow the extraction of the parts of
 a string that matched. This is very useful to find out what matched and
 for text processing in general. For each grouping, the part that 
matched inside goes into the special variables <code>$1</code>, <code>$2</code>, <i>etc</i>. They can be used just as ordinary variables:</p>
</div>
<p>グループ化メタ文字 <code>()</code> はまた、まったく異なる別の機能を有しています: 
マッチングした文字列の一部分を展開することができるのです。 これは一般的に、マッチングしたものを見つけ出したり、テキスト処理のために 
非常に便利なものです。 それぞれのグループ化に対して、マッチングした部分が特殊変数 <code>$1</code>, <code>$2</code> などに 格納されます。 これらの変数は通常の変数と同じように使うことができます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="com"># extract hours, minutes, seconds</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$time </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">):(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">):(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">)/)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># match hh:mm:ss format</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; $hours </span><span class="pun">=</span><span class="pln"> $1</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; $minutes </span><span class="pun">=</span><span class="pln"> $2</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; $seconds </span><span class="pun">=</span><span class="pln"> $3</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>Now, we know that in scalar context, <span style="white-space: nowrap;"><code>$time =~ /(\d\d):(\d\d):(\d\d)/</code></span> returns a true or false value. In list context, however, it returns the list of matched values <code>($1,$2,$3)</code>. So we could write the code more compactly as</p>
</div>
<p>この例ではスカラコンテキストなので、 <span style="white-space: nowrap;"><code>$time =~ /(\d\d):(\d\d):(\d\d)/</code></span> は真か偽の値を返します。 リストコンテキストでは、マッチングした値のリスト <code>($1,$2,$3)</code> を返します。 ですから、コードをよりコンパクトに</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="com"># extract hours, minutes, seconds</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">(</span><span class="pln">$hours</span><span class="pun">,</span><span class="pln"> $minutes</span><span class="pun">,</span><span class="pln"> $second</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$time </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">):(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">):(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">)/);</span></code></pre>
<div class="original">
<p>If the groupings in a regexp are nested, <code>$1</code> gets the group with the leftmost opening parenthesis, <code>$2</code> the next opening parenthesis, <i>etc</i>. Here is a regexp with nested groups:</p>
</div>
<p>正規表現中のグループ化がネストしていた場合、<code>$1</code> は最も左にある 開きかっこによってグループ化されているものを取り、<code>$2</code> は 次の開きかっこによるものを取り…となっていきます。 これがネストしたグループをもつ正規表現です:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/(</span><span class="pln">ab</span><span class="pun">(</span><span class="pln">cd</span><span class="pun">|</span><span class="pln">ef</span><span class="pun">)((</span><span class="pln">gi</span><span class="pun">)|</span><span class="pln">j</span><span class="pun">))/;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp;</span><span class="lit">1</span><span class="pln"> &nbsp;</span><span class="lit">2</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="lit">34</span></code></pre>
<div class="original">
<p>If this regexp matches, <code>$1</code> contains a string starting with <code>'ab'</code>, <code>$2</code> is either set to <code>'cd'</code> or <code>'ef'</code>, <code>$3</code> equals either <code>'gi'</code> or <code>'j'</code>, and <code>$4</code> is either set to <code>'gi'</code>, just like <code>$3</code>, or it remains undefined.</p>
</div>
<p>この正規表現がマッチングすると、<code>$1</code> は <code>'ab'</code> で始まる文字列が入り、 <code>$2</code> は <code>'cd'</code> か <code>'ef'</code> が入り、<code>$3</code> は <code>'gi'</code> か <code>'j'</code> が入り、 <code>$4</code> は <code>$3</code> と同様に <code>'gi'</code> が入るか、未定義のままです。</p>
<div class="original">
<p>For convenience, Perl sets <code>$+</code> to the string held by the highest numbered <code>$1</code>, <code>$2</code>,... that got assigned (and, somewhat related, <code>$^N</code> to the value of the <code>$1</code>, <code>$2</code>,... most-recently assigned; <i>i.e.</i> the <code>$1</code>, <code>$2</code>,... associated with the rightmost closing parenthesis used in the match).</p>
</div>
<p>便利のため、Perl は <code>$+</code> に <code>$1</code>, <code>$2</code> などの代入された番号付け変数の 最も数値の大きなものをセットします(そして、<code>$^N</code> には最も最近代入された <code>$1</code>, <code>$2</code> などの値がセットされます; つまり、マッチングにおいて使われた 閉じカッコの中で最も右にあるものに結び付けられたものです)。</p>
<h2 id="Backreferences">後方参照<a href="#Backreferences" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Closely associated with the matching variables <code>$1</code>, <code>$2</code>, ... are the <i>backreferences</i> <code>\g1</code>, <code>\g2</code>,... Backreferences are simply matching variables that can be used <i>inside</i>
 a regexp. This is a really nice feature; what matches later in a regexp
 is made to depend on what matched earlier in the regexp. Suppose we 
wanted to look for doubled words in a text, like "the the". The 
following regexp finds all 3-letter doubles with a space in between:</p>
</div>
<p>マッチング変数 <code>$1</code>, <code>$2</code> …に密接に結び付けられたものは、 <i>後方参照</i> (backreferences) <code>\g1</code>, <code>\g2</code> …です。 後方参照は正規表現の <i>内側</i>
 で使うことのできるマッチング変数です。 これは実に良い機能です; 正規表現の中で後でマッチングするものがそれ以前に 
マッチングしていたものに依存させることができます。 "the the" のように繰り返しされた単語をテキストの中から探したいとしましょう。 
以下の正規表現はスペースで分けられた三文字の重複単語を見つけ出します:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/\</span><span class="pln">b</span><span class="pun">(\</span><span class="pln">w</span><span class="pun">\</span><span class="pln">w</span><span class="pun">\</span><span class="pln">w</span><span class="pun">)\</span><span class="pln">s</span><span class="pun">\</span><span class="pln">g1</span><span class="pun">\</span><span class="pln">b</span><span class="pun">/;</span></code></pre>
<div class="original">
<p>The grouping assigns a value to <code>\g1</code>, so that the same 3-letter sequence is used for both parts.</p>
</div>
<p>グループ化は値を <code>\g1</code> にセットするので、同じ三文字の並びが両方のパーツで 使われます。</p>
<div class="original">
<p>A similar task is to find words consisting of two identical parts:</p>
</div>
<p>似たような作業としては、同じ部分が 2 回繰り返される単語を 探すというものです:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> simple_grep </span><span class="str">'^(\w\w\w\w|\w\w\w|\w\w|\w)\g1$'</span><span class="pln"> </span><span class="pun">/</span><span class="pln">usr</span><span class="pun">/</span><span class="pln">dict</span><span class="pun">/</span><span class="pln">words<br>&nbsp; &nbsp; beriberi<br>&nbsp; &nbsp; booboo<br>&nbsp; &nbsp; coco<br>&nbsp; &nbsp; mama<br>&nbsp; &nbsp; murmur<br>&nbsp; &nbsp; papa</span></code></pre>
<div class="original">
<p>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations, <i>etc</i>., and uses <code>\g1</code> to look for a repeat. Although <code>$1</code> and <code>\g1</code> represent the same thing, care should be taken to use matched variables <code>$1</code>, <code>$2</code>,... only <i>outside</i> a regexp and backreferences <code>\g1</code>, <code>\g2</code>,... only <i>inside</i> a regexp; not doing so may lead to surprising and unsatisfactory results.</p>
</div>
<p>この正規表現は四文字の組み合わせ、三文字の組み合わせなどを扱うただ一つの グループ化を持っています; そして、<code>\g1</code> は繰り返しを探します。 <code>$1</code> と <code>\g1</code> が同じものを表現しているにもかかわらず、マッチング変数 <code>$1</code>, <code>$2</code> …は正規表現の <i>外側</i> のみで用い、 後方参照 <code>\g1</code>, <code>\g2</code> …は正規表現の <i>内側</i> でのみ使うようにすべきです; そうしないと驚くような不満足な結果を招くかもしれません。</p>
<h2 id="Relative32backreferences">相対後方参照<a href="#Relative32backreferences" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Counting the opening parentheses to get the correct number for a 
backreference is error-prone as soon as there is more than one capturing
 group. A more convenient technique became available with Perl 5.10: 
relative backreferences. To refer to the immediately preceding capture 
group one now may write <code>\g{-1}</code>, the next but last is available via <code>\g{-2}</code>, and so on.</p>
</div>
<p>後方参照で正しい番号を得るために開きかっこを数えるということは、捕捉 グループが複数になるとすぐに間違いを起こしがちになります。 より便利なテクニックである相対後方参照が Perl 5.10 で利用可能です。 直前の捕捉グループを参照するためには <code>\g{-1}</code> と書き、その手前は <code>\g{-2}</code>、などとなります。</p>
<div class="original">
<p>Another good reason in addition to readability and maintainability 
for using relative backreferences is illustrated by the following 
example, where a simple pattern for matching peculiar strings is used:</p>
</div>
<p>相対後方参照を使うことの、可読性と保守性に加えたよい理由は、以下の、 特定の文字列をマッチングするための単純なパターンが使われている例で示します:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $a99a </span><span class="pun">=</span><span class="pln"> </span><span class="str">'([a-z])(\d)\g2\g1'</span><span class="pun">;</span><span class="pln"> &nbsp; </span><span class="com"># matches a11a, g22g, x33x, etc.</span></code></pre>
<div class="original">
<p>Now that we have this pattern stored as a handy string, we might feel tempted to use it as a part of some other pattern:</p>
</div>
<p>ここで、このパターンを便利な文字列として持つことになったので、 これを他のパターンの一部として使いたいと思うかもしれません:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $line </span><span class="pun">=</span><span class="pln"> </span><span class="str">"code=e99e"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$line </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^(\</span><span class="pln">w</span><span class="pun">+)=</span><span class="pln">$a99a$</span><span class="pun">/){</span><span class="pln"> &nbsp; </span><span class="com"># unexpected behavior!</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"$1 is valid\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"> else </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"bad line: '$line'\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>But this doesn't match, at least not the way one might expect. Only after inserting the interpolated <code>$a99a</code> and looking at the resulting full text of the regexp is it obvious that the backreferences have backfired. The subexpression <code>(\w+)</code> has snatched number 1 and demoted the groups in <code>$a99a</code> by one rank. This can be avoided by using relative backreferences:</p>
</div>
<p>しかしこれはマッチングしません; 少なくとも予想した通りには。 変数展開された <code>$a99a</code> を挿入した後でだけ、結果となる 正規表現のテキストを見ると、後方参照が逆効果となるのは明らかです。 部分式 <code>(\w+)</code> が 1 番を奪ってしまい、<code>$a99a</code> のグループが 1 つ格下げになります。 これは相対後方参照を使うことで回避できます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $a99a </span><span class="pun">=</span><span class="pln"> </span><span class="str">'([a-z])(\d)\g{-1}\g{-2}'</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># safe for being interpolated</span></code></pre>
<h2 id="Named32backreferences">名前付き後方参照<a href="#Named32backreferences" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Perl 5.10 also introduced named capture groups and named 
backreferences. To attach a name to a capturing group, you write either <code>(?&lt;name&gt;...)</code> or <code>(?'name'...)</code>. The backreference may then be written as <code>\g{name}</code>.
 It is permissible to attach the same name to more than one group, but 
then only the leftmost one of the eponymous set can be referenced. 
Outside of the pattern a named capture group is accessible through the <code>%+</code> hash.</p>
</div>
<p>Perl 5.10 では名前付きグループと名前付き後方参照も導入されました。 捕捉グループに名前を付けるために、<code>(?&lt;name&gt;...)</code> または <code>(?'name'...)</code> と書けます。 後方参照は <code>\g{name}</code> と書けます。 複数のグループに同じ名前を付けることは出来ますが、一番左のものだけが 参照可能です。 パターンの外側では、名前付き捕捉グループは <code>%+</code> ハッシュを通して アクセスできます。</p>
<div class="original">
<p>Assuming that we have to match calendar dates which may be given in 
one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can 
write three suitable patterns where we use <code>'d'</code>, <code>'m'</code> and <code>'y'</code>
 respectively as the names of the groups capturing the pertaining 
components of a date. The matching operation combines the three patterns
 as alternatives:</p>
</div>
<p>yyyy-mm-dd, mm/dd/yyyy, dd.mm.yyyy の 3 つの形式のどれか 1 つで 与えられる日付とマッチングしなければならないと仮定すると、 <code>'d'</code>, <code>'m'</code>, <code>'y'</code> をそれぞれ日付の要素を捕捉するグループの名前として 使って、三つの適合するパターンを書けます。 マッチング操作は 3 つのパターンの選択として結合します:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $fmt1 </span><span class="pun">=</span><span class="pln"> </span><span class="str">'(?&lt;y&gt;\d\d\d\d)-(?&lt;m&gt;\d\d)-(?&lt;d&gt;\d\d)'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $fmt2 </span><span class="pun">=</span><span class="pln"> </span><span class="str">'(?&lt;m&gt;\d\d)/(?&lt;d&gt;\d\d)/(?&lt;y&gt;\d\d\d\d)'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $fmt3 </span><span class="pun">=</span><span class="pln"> </span><span class="str">'(?&lt;d&gt;\d\d)\.(?&lt;m&gt;\d\d)\.(?&lt;y&gt;\d\d\d\d)'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">for</span><span class="pln"> </span><span class="kwd">my</span><span class="pln"> $d qw</span><span class="pun">(</span><span class="pln"> </span><span class="lit">2006</span><span class="pun">-</span><span class="lit">10</span><span class="pun">-</span><span class="lit">21</span><span class="pln"> </span><span class="lit">15.01</span><span class="pun">.</span><span class="lit">2007</span><span class="pln"> </span><span class="lit">10</span><span class="pun">/</span><span class="lit">31</span><span class="pun">/</span><span class="lit">2005</span><span class="pln"> </span><span class="pun">){</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> $d </span><span class="pun">=~</span><span class="pln"> m</span><span class="pun">{</span><span class="pln">$fmt1</span><span class="pun">|</span><span class="pln">$fmt2</span><span class="pun">|</span><span class="pln">$fmt3</span><span class="pun">}</span><span class="pln"> </span><span class="pun">){</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"day=$+{d} month=$+{m} year=$+{y}\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>If any of the alternatives matches, the hash <code>%+</code> is bound to contain the three key-value pairs.</p>
</div>
<p>もし他のマッチングがある場合は、ハッシュ <code>%+</code> は 3 つのキー-値の組が 含まれることになります。</p>
<h2 id="Alternative32capture32group32numbering">選択捕捉グループ番号付け<a href="#Alternative32capture32group32numbering" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Yet another capturing group numbering technique (also as from Perl 
5.10) deals with the problem of referring to groups within a set of 
alternatives. Consider a pattern for matching a time of the day, civil 
or military style:</p>
</div>
<p>もう一つのグループの番号付けの技術 (これも Perl 5.10 からです) は、 選択の集合の中にあるグループを参照する問題を扱います。 民間形式と軍形式の時刻にマッチングするパターンを考えます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> $time </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">|\</span><span class="pln">d</span><span class="pun">):(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">)|(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">)(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">)/</span><span class="pln"> </span><span class="pun">){</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># process hour and minute</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>Processing the results requires an additional if statement to determine whether <code>$1</code> and <code>$2</code> or <code>$3</code> and <code>$4</code>
 contain the goodies. It would be easier if we could use group numbers 1
 and 2 in second alternative as well, and this is exactly what the 
parenthesized construct <code>(?|...)</code>, set around an alternative achieves. Here is an extended version of the previous pattern:</p>
</div>
<p>結果の処理には、<code>$1</code> と <code>$2</code>、または <code>$3</code> と <code>$4</code> に有用なものが 含まれれているかを決定するために追加の if 文が必要です。 2 番目の選択肢にもグループ番号 1 と 2 をつけられればより簡単になります; これがまさに、選択肢の周りにかっこをつけた構造 <code>(?|...)</code> が 意味するものです。 これは以前のパターンの拡張版です:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">$time </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?|(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">|\</span><span class="pln">d</span><span class="pun">):(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">)|(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">)(\</span><span class="pln">d</span><span class="pun">\</span><span class="pln">d</span><span class="pun">))\</span><span class="pln">s</span><span class="pun">+([</span><span class="pln">A</span><span class="pun">-</span><span class="pln">Z</span><span class="pun">][</span><span class="pln">A</span><span class="pun">-</span><span class="pln">Z</span><span class="pun">][</span><span class="pln">A</span><span class="pun">-</span><span class="pln">Z</span><span class="pun">])/){</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"hour=$1 minute=$2 zone=$3\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>Within the alternative numbering group, group numbers start at the 
same position for each alternative. After the group, numbering continues
 with one higher than the maximum reached across all the alternatives.</p>
</div>
<p>選択番号付けグループの中で、グループ番号はそれぞれの選択に対して 同じ位置から始まります。 このグループの後、番号付けは全ての選択の中での最大値に 1 を加えた値から 続行します。</p>
<h2 id="Position32information">位置情報<a href="#Position32information" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>In addition to what was matched, Perl also provides the positions of what was matched as contents of the <code>@-</code> and <code>@+</code> arrays. <code>$-[0]</code> is the position of the start of the entire match and <code>$+[0]</code> is the position of the end. Similarly, <code>$-[n]</code> is the position of the start of the <code>$n</code> match and <code>$+[n]</code> is the position of the end. If <code>$n</code> is undefined, so are <code>$-[n]</code> and <code>$+[n]</code>. Then this code</p>
</div>
<p>マッチングしたものに加えて、Perl ではマッチングしたものの位置を <code>@-</code> と <code>@+</code> という配列の中身によって提供します。 <code>$-[0]</code> はマッチング全体の開始位置で、<code>$+[0]</code> はマッチング全体の 終了位置です。 同様に、 <code>$-[n]</code> は <code>$n</code> の開始位置であり <code>$+[n]</code> はその終了位置です。 <code>$n</code> が未定義であった場合には、<code>$-[n]</code> と <code>$+[n]</code> もまた未定義です。 従ってこのコードは</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Mmm...donut, thought Homer"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^(</span><span class="typ">Mmm</span><span class="pun">|</span><span class="typ">Yech</span><span class="pun">)\.\.\.(</span><span class="pln">donut</span><span class="pun">|</span><span class="pln">peas</span><span class="pun">)/;</span><span class="pln"> </span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">foreach</span><span class="pln"> $exp </span><span class="pun">(</span><span class="lit">1.</span><span class="pun">.</span><span class="pln">$</span><span class="com">#-) {</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Match $exp: '${$exp}' at position ($-[$exp],$+[$exp])\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>prints</p>
</div>
<p>以下の出力を行います</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="typ">Match</span><span class="pln"> </span><span class="lit">1</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Mmm'</span><span class="pln"> at position </span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="lit">3</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Match</span><span class="pln"> </span><span class="lit">2</span><span class="pun">:</span><span class="pln"> </span><span class="str">'donut'</span><span class="pln"> at position </span><span class="pun">(</span><span class="lit">6</span><span class="pun">,</span><span class="lit">11</span><span class="pun">)</span></code></pre>
<div class="original">
<p>Even if there are no groupings in a regexp, it is still possible to 
find out what exactly matched in a string. If you use them, Perl will 
set <code>$`</code> to the part of the string before the match, will set <code>$&amp;</code> to the part of the string that matched, and will set <code>'$'</code> to the part of the string after the match. An example:</p>
</div>
<p>グループ化を正規表現で使っていなかったとしても、文字列の中で実際に マッチングしたものを見つけ出すことが可能です。 正規表現を使ったとき、 Perl は <code>$`</code> に文字列のマッチングした部分より前の部分を セットし、 <code>$&amp;</code> にはマッチングした部分をセットし、そして <code>'$'</code> には マッチングした部分より後の部分をセットします。 例:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"the cat caught the mouse"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cat</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># $` = 'the ', $&amp; = 'cat', $' = ' caught the mouse'</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">the</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># $` = '', $&amp; = 'the', $' = ' cat caught the mouse'</span></code></pre>
<div class="original">
<p>In the second match, <code>$`</code> equals <code>''</code> because the regexp matched at the first character position in the string and stopped; it never saw the second "the".</p>
</div>
<p>二番目のマッチングでは、<code>$`</code> は <code>''</code> となります; なぜなら、正規表現は文字列の最初の文字位置でマッチングして止まっているからで、 二番目の "the" を決して見ないからなのです。</p>
<div class="original">
<p>If your code is to run on Perl versions earlier than 5.20, it is worthwhile to note that using <code>$`</code> and <code>'$'</code> slows down regexp matching quite a bit, while <code>$&amp;</code> slows it down to a lesser extent, because if they are used in one regexp in a program, they are generated for <i>all</i>
 regexps in the program. So if raw performance is a goal of your 
application, they should be avoided. If you need to extract the 
corresponding substrings, use <code>@-</code> and <code>@+</code> instead:</p>
</div>
<p>コードを 5.20 より前のバージョンの Perl で動かしている場合、 <code>$`</code> や <code>'$'</code> を使うことは正規表現マッチングを目立って遅くさせることに 注意する価値があります; 一方 <code>$&amp;</code> も遅くなる原因です; なぜなら、プログラムの中の正規表現でこれらを使ったならばプログラムの中の <i>すべて</i> の正規表現に対してこれらが生成されるからです。 ですから、生のパフォーマンスがあなたの作るアプリケーションのゴールで あるならば、これらを排除すべきです。 もし対応する部分文字列の展開が必要なら、代わりに <code>@-</code> と<code>@+</code> を 使いましょう:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $</span><span class="str">` is the same as substr( $x, 0, $-[0] )<br>&nbsp; &nbsp; $&amp; is the same as substr( $x, $-[0], $+[0]-$-[0] )<br>&nbsp; &nbsp; $' is the same as substr( $x, $+[0] )</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $</span><span class="str">` は substr( $x, 0, $-[0] ) と同じです<br>&nbsp; &nbsp; $&amp; は substr( $x, $-[0], $+[0]-$-[0] ) と同じです<br>&nbsp; &nbsp; $' は substr( $x, $+[0] ) と同じです</span></code></pre>
<div class="original">
<p>As of Perl 5.10, the <code>${^PREMATCH}</code>, <code>${^MATCH}</code> and <code>${^POSTMATCH}</code> variables may be used. These are only set if the <code>/p</code> modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, <code>${^PREMATCH}</code>, <code>${^MATCH}</code> and <code>${^POSTMATCH}</code> are available whether the <code>/p</code> has been used or not (the modifier is ignored), and <code>$`</code>, <code>'$'</code> and <code>$&amp;</code> do not cause any speed difference.</p>
</div>
<p>Perl 5.10 から、<code>${^PREMATCH}</code>, <code>${^MATCH}</code>, <code>${^POSTMATCH}</code> 変数が 使えます。 これらは <code>/p</code> 修飾子があるときにのみ設定されます。 従って、これらはプログラムの残りの部分では不利益にはなりません。 Perl 5.20 では、<code>${^PREMATCH}</code>, <code>${^MATCH}</code>, <code>${^POSTMATCH}</code> は <code>/p</code> は あってもなくても使えるようになり(この修飾子は無視されます)、<code>$`</code>, <code>'$'</code>, <code>$&amp;</code> を使っても速度が変わらなくなりました。</p>
<h2 id="Non-capturing32groupings">捕捉しないグループ化<a href="#Non-capturing32groupings" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>A group that is required to bundle a set of alternatives may or may 
not be useful as a capturing group. If it isn't, it just creates a 
superfluous addition to the set of available capture group values, 
inside as well as outside the regexp. Non-capturing groupings, denoted 
by <code>(?:regexp)</code>, still allow the regexp to be treated as a 
single unit, but don't establish a capturing group at the same time. 
Both capturing and non-capturing groupings are allowed to co-exist in 
the same regexp. Because there is no extraction, non-capturing groupings
 are faster than capturing groupings. Non-capturing groupings are also 
handy for choosing exactly which parts of a regexp are to be extracted 
to matching variables:</p>
</div>
<p>選択肢の集合をまとめるために必要なグループは、捕捉グループとして 有用な場合もありますし、有用でない場合もあります。 有用でない場合は、これは正規表現の内外で、無駄な捕捉グループ値を 作ることになります。 非捕捉グループ化は <code>(?:regexp)</code>
 のように表記され regexp を一つの ユニットのように扱うことができるようにしますが、同時に捕捉グループを 作成することはしません。 
捕捉するグループ化と捕捉しないグループ化の両方が同じ正規表現の 中で共存することができます。 
部分文字列の抜き出しをしないので、非捕捉グループ化は捕捉する グループ化よりも高速です。 
非捕捉グループ化はマッチング変数を使って抽出する正規表現の部分を 選択するのに便利です:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="com"># match a number, $1-$4 are set, but we only want $1</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/([+-]?\</span><span class="pln"> </span><span class="pun">*(\</span><span class="pln">d</span><span class="pun">+(\.\</span><span class="pln">d</span><span class="pun">*)?|\.\</span><span class="pln">d</span><span class="pun">+)([</span><span class="pln">eE</span><span class="pun">][+-]?\</span><span class="pln">d</span><span class="pun">+)?)/;</span><span class="pln"><br><br>&nbsp; &nbsp; </span><span class="com"># match a number faster , only $1 is set</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/([+-]?\</span><span class="pln"> </span><span class="pun">*(?:\</span><span class="pln">d</span><span class="pun">+(?:\.\</span><span class="pln">d</span><span class="pun">*)?|\.\</span><span class="pln">d</span><span class="pun">+)(?:[</span><span class="pln">eE</span><span class="pun">][+-]?\</span><span class="pln">d</span><span class="pun">+)?)/;</span><span class="pln"><br><br>&nbsp; &nbsp; </span><span class="com"># match a number, get $1 = whole number, $2 = exponent</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/([+-]?\</span><span class="pln"> </span><span class="pun">*(?:\</span><span class="pln">d</span><span class="pun">+(?:\.\</span><span class="pln">d</span><span class="pun">*)?|\.\</span><span class="pln">d</span><span class="pun">+)(?:[</span><span class="pln">eE</span><span class="pun">]([+-]?\</span><span class="pln">d</span><span class="pun">+))?)/;</span></code></pre>
<div class="original">
<p>Non-capturing groupings are also useful for removing nuisance 
elements gathered from a split operation where parentheses are required 
for some reason:</p>
</div>
<p>非捕捉グループ化は、なんらかの理由でかっこが必要なところで、split 操作が もたらす不愉快な要素を取り除くのにも便利です:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">'12aba34ba5'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="lit">@num</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> split </span><span class="pun">/(</span><span class="pln">a</span><span class="pun">|</span><span class="pln">b</span><span class="pun">)+/,</span><span class="pln"> $x</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># @num = ('12','a','34','a','5')</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="lit">@num</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> split </span><span class="pun">/(?:</span><span class="pln">a</span><span class="pun">|</span><span class="pln">b</span><span class="pun">)+/,</span><span class="pln"> $x</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># @num = ('12','34','5')</span></code></pre>
<div class="original">
<p>In Perl 5.22 and later, all groups within a regexp can be set to non-capturing by using the new <code>/n</code> flag:</p>
</div>
<p>Perl 5.22 以降では、正規表現中の全てのグループは、新しい <code>/n</code> フラグを使うことで非捕捉になります:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"hello"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(</span><span class="pln">hi</span><span class="pun">|</span><span class="pln">hello</span><span class="pun">)/</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> </span><span class="com"># $1 is not set!</span></code></pre>
<div class="original">
<p>See <a href="https://perldoc.jp/pod/perlre#n">"n" in perlre</a> for more information.</p>
</div>
<p>さらなる情報については <a href="https://perldoc.jp/pod/perlre#n">"n" in perlre</a> を参照してください。</p>
<h2 id="Matching32repetitions">マッチングの繰り返し<a href="#Matching32repetitions" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>The examples in the previous section display an annoying weakness. We
 were only matching 3-letter words, or chunks of words of 4 letters or 
less. We'd like to be able to match words or, more generally, strings of
 any length, without writing out tedious alternatives like <code>\w\w\w\w|\w\w\w|\w\w|\w</code>.</p>
</div>
<p>先のセクションの例では、腹立たしい弱点が明らかになりました。 三文字の単語か、四文字以下の文字の塊にだけマッチングしていました。 <code>\w\w\w\w|\w\w\w|\w\w|\w</code> のような長たらしい選択を書くことなしに任意の 長さの単語やより一般的には、文字列にマッチングさせたいのです。</p>
<div class="original">
<p>This is exactly the problem the <i>quantifier</i> metacharacters <code>'?'</code>, <code>'*'</code>, <code>'+'</code>, and <code>{}</code>
 were created for. They allow us to delimit the number of repeats for a 
portion of a regexp we consider to be a match. Quantifiers are put 
immediately after the character, character class, or grouping that we 
want to specify. They have the following meanings:</p>
</div>
<p>これは、<code>'?'</code>, <code>'*'</code>, <code>'+'</code>, <code>{}</code> といった <i>量指定子</i>
 (quatifier) メタ文字が作られる元となった問題です。 これらはマッチングさせたいと考えている正規表現の一部分の繰り返し回数を 
指定できます。 量指定子は繰り返しを指定したい文字、文字クラス、またはグループの直後に 置きます。 これらは以下のような意味があります:</p>
<ul>
<li><p></p>
<div class="original">
<p><code>a?</code> means: match <code>'a'</code> 1 or 0 times</p>
</div>
<p><code>a?</code> は: <code>'a'</code> または空文字列にマッチングします。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a*</code> means: match <code>'a'</code> 0 or more times, <i>i.e.</i>, any number of times</p>
</div>
<p><code>a*</code> は: <code>'a'</code> のゼロ回以上の繰り返しにマッチングします。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a+</code> means: match <code>'a'</code> 1 or more times, <i>i.e.</i>, at least once</p>
</div>
<p><code>a+</code> は: <code>'a'</code> の一回以上の繰り返しにマッチングします。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a{n,m}</code> means: match at least <code>n</code> times, but not more than <code>m</code> times.</p>
</div>
<p><code>a{n,m}</code> は: <code>n</code> 回以上 <code>m</code> 回以下の繰り返しにマッチングします。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a{n,}</code> means: match at least <code>n</code> or more times</p>
</div>
<p><code>a{n,}</code> は: <code>n</code> 回以上の繰り返しにマッチングします。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a{n}</code> means: match exactly <code>n</code> times</p>
</div>
<p><code>a{n}</code> は: <code>n</code> 回の繰り返しにマッチングします。</p>
</li>
</ul>
<div class="original">
<p>Here are some examples:</p>
</div>
<p>以下にいくつか例を挙げます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/[</span><span class="pln">a</span><span class="pun">-</span><span class="pln">z</span><span class="pun">]+\</span><span class="pln">s</span><span class="pun">+\</span><span class="pln">d</span><span class="pun">*</span><span class="str">/; &nbsp;# match a lowercase word, at least one space, and<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# any number of digits<br>&nbsp; &nbsp; /</span><span class="pun">(\</span><span class="pln">w</span><span class="pun">+)\</span><span class="pln">s</span><span class="pun">+\</span><span class="pln">g1</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># match doubled words of arbitrary length</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">y</span><span class="pun">(</span><span class="pln">es</span><span class="pun">)?/</span><span class="pln">i</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># matches 'y', 'Y', or a case-insensitive 'yes'</span><span class="pln"><br>&nbsp; &nbsp; $year </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">2</span><span class="pun">,</span><span class="lit">4</span><span class="pun">}</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># make sure year is at least 2 but not more</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># than 4 digits</span><span class="pln"><br>&nbsp; &nbsp; $year </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">4</span><span class="pun">}</span><span class="pln">$</span><span class="pun">|^\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">2</span><span class="pun">}</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># better match; throw out 3-digit dates</span><span class="pln"><br>&nbsp; &nbsp; $year </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">2</span><span class="pun">}(\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">2</span><span class="pun">})?</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># same thing written differently.</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># However, this captures the last two</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># digits in $1 and the other does not.</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/[</span><span class="pln">a</span><span class="pun">-</span><span class="pln">z</span><span class="pun">]+\</span><span class="pln">s</span><span class="pun">+\</span><span class="pln">d</span><span class="pun">*</span><span class="str">/; &nbsp;# 小文字の単語、幾つかの空白、それに続く任意の長さの<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 数字にマッチング<br>&nbsp; &nbsp; /</span><span class="pun">(\</span><span class="pln">w</span><span class="pun">+)\</span><span class="pln">s</span><span class="pun">+\</span><span class="pln">g1</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># 任意の長さの単語の重複にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">y</span><span class="pun">(</span><span class="pln">es</span><span class="pun">)?/</span><span class="pln">i</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># 'y', 'Y', または大小文字を無視して 'yes' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; $year </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">2</span><span class="pun">,</span><span class="lit">4</span><span class="pun">}</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 年が少なくとも2桁あるが最大でも4桁になるように</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># する</span><span class="pln"><br>&nbsp; &nbsp; $year </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">4</span><span class="pun">}|\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">2</span><span class="pun">}</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># もっと良い; 3桁をはじく</span><span class="pln"><br>&nbsp; &nbsp; $year </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">2</span><span class="pun">}(\</span><span class="pln">d</span><span class="pun">{</span><span class="lit">2</span><span class="pun">})?</span><span class="pln">$</span><span class="pun">/;</span><span class="com"># 同じことの違うやり方。しかし、この例では</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $1 を生成する。</span><span class="pln"><br><br>&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> simple_grep </span><span class="str">'^(\w+)\g1$'</span><span class="pln"> </span><span class="pun">/</span><span class="pln">usr</span><span class="pun">/</span><span class="pln">dict</span><span class="pun">/</span><span class="pln">words &nbsp; </span><span class="com"># isn't this easier?</span><span class="pln"><br>&nbsp; &nbsp; beriberi<br>&nbsp; &nbsp; booboo<br>&nbsp; &nbsp; coco<br>&nbsp; &nbsp; mama<br>&nbsp; &nbsp; murmur<br>&nbsp; &nbsp; papa</span></code></pre>
<div class="original">
<p>For all of these quantifiers, Perl will try to match as much of the 
string as possible, while still allowing the regexp to succeed. Thus 
with <code>/a?.../</code>, Perl will first try to match the regexp with the <code>'a'</code> present; if that fails, Perl will try to match the regexp without the <code>'a'</code> present. For the quantifier <code>'*'</code>, we get the following:</p>
</div>
<p>これらの量指定子のすべてで、Perl は正規表現のマッチングが成功するのを許す範囲で 可能な限りの文字列をマッチングさせようとします。 したがって、<code>/a?.../</code> があったとき、Perl は最初に <code>'a'</code> があるものとして 正規表現のマッチングを試みます; もしそれが失敗したら、Perl は <code>'a'</code> が ないものとして正規表現のマッチングを試みます。 量指定子 <code>'*'</code> に関して、以下のようになります:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"the cat in the hat"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^(.*)(</span><span class="pln">cat</span><span class="pun">)(.*)</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $1 = 'the '</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $2 = 'cat'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $3 = ' in the hat'</span></code></pre>
<div class="original">
<p>Which is what we might expect, the match finds the only <code>cat</code> in the string and locks onto it. Consider, however, this regexp:</p>
</div>
<p>これはおそらく期待したもので、文字列の中の <code>cat</code> だけを見つけ出して マッチングします。 しかし、次の例で考えてみましょう:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^(.*)(</span><span class="pln">at</span><span class="pun">)(.*)</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $1 = 'the cat in the h'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $2 = 'at'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $3 = '' &nbsp; (0 characters match)</span></code></pre>
<div class="original">
<p>One might initially guess that Perl would find the <code>at</code> in <code>cat</code> and stop there, but that wouldn't give the longest possible string to the first quantifier <code>.*</code>. Instead, the first quantifier <code>.*</code> grabs as much of the string as possible while still having the regexp match. In this example, that means having the <code>at</code> sequence with the final <code>at</code> in the string. The other important principle illustrated here is that, when there are two or more elements in a regexp, the <i>leftmost</i>
 quantifier, if there is one, gets to grab as much of the string as 
possible, leaving the rest of the regexp to fight over scraps. Thus in 
our example, the first quantifier <code>.*</code> grabs most of the string, while the second quantifier <code>.*</code> gets the empty string. Quantifiers that grab as much of the string as possible are called <i>maximal match</i> or <i>greedy</i> quantifiers.</p>
</div>
<p>Perl は <code>cat</code> の <code>at</code> を見つけて、そこでストップするだろうと考える人が いるかもしれませんが、それでは最初の量指定子 <code>.*</code> に可能な限りの長い 文字列を与えてはいません。 その代わりに、最初の量指定子 <code>.*</code> は正規表現がマッチングする範囲で可能な限りの 長い文字列をつかみとります。 この例では <code>at</code> が文字列の最後の <code>at</code> になるということを意味します。 ここで明らかになるもう一つの重要な規則は二つ以上の要素が正規表現の中に あるときには、<i>最も左にある</i> 量指定子が可能な限りの長さの文字列を つかみとり、正規表現の残りの部分がどうであるかは放っておくというものです。 したがってこの例では、最初の量指定子 <code>.*</code> は文字列のほとんどをつかみ、 二番目の量指定子 <code>.*</code> は空文字列をつかみます。 可能な限りの文字列をつかみとる量指定子は <i>最長マッチング</i> とか <i>貪欲</i> (greedy) であると呼ばれます。</p>
<div class="original">
<p>When a regexp can match a string in several different ways, we can 
use the principles above to predict which way the regexp will match:</p>
</div>
<p>正規表現が幾つかの異なる道筋で文字列にマッチングすることが可能なとき、 正規表現がどのようにマッチングするかを予測するために以下の法則を 使うことができます:</p>
<ul>
<li><p></p>
<div class="original">
<p>Principle 0: Taken as a whole, any regexp will be matched at the earliest possible position in the string.</p>
</div>
<p>法則 0: 全体で、任意の正規表現は文字列中の可能な限り先頭に近い場所で マッチングする。</p>
</li>
<li><p></p>
<div class="original">
<p>Principle 1: In an alternation <code>a|b|c...</code>, the leftmost alternative that allows a match for the whole regexp will be the one used.</p>
</div>
<p>法則 1: 選択 <code>a|b|c...</code> の中で、正規表現全体がマッチングする中で最も左の 選択肢が使われる。</p>
</li>
<li><p></p>
<div class="original">
<p>Principle 2: The maximal matching quantifiers <code>'?'</code>, <code>'*'</code>, <code>'+'</code> and <code>{n,m}</code> will in general match as much of the string as possible while still allowing the whole regexp to match.</p>
</div>
<p>法則 2: 最大マッチング量指定子 <code>'?'</code>, <code>'*'</code>, <code>'+'</code>, <code>{n,m}</code> は 正規表現全体がマッチングする中で最も長い文字列にマッチングする。</p>
</li>
<li><p></p>
<div class="original">
<p>Principle 3: If there are two or more elements in a regexp, the 
leftmost greedy quantifier, if any, will match as much of the string as 
possible while still allowing the whole regexp to match. The next 
leftmost greedy quantifier, if any, will try to match as much of the 
string remaining available to it as possible, while still allowing the 
whole regexp to match. And so on, until all the regexp elements are 
satisfied.</p>
</div>
<p>法則 3: 正規表現の中に二つ以上の要素があったならば、貪欲な量指定子が 
もしあれば、その中で最も左にあるものが正規表現全体がマッチングする条件に おいて可能な限りの長さでマッチングする。 
次の貪欲な量指定子があれば、それは残りの中で正規表現全体がマッチングする 条件において最も長い文字列にマッチングする。 
これをすべての正規表現要素が満足されるまで繰り返す。</p>
</li>
</ul>
<div class="original">
<p>As we have seen above, Principle 0 overrides the others. The regexp 
will be matched as early as possible, with the other principles 
determining how the regexp matches at that earliest character position.</p>
</div>
<p>すでに見たように、法則 0 は他のものを上書きしています。 正規表現は可能な限り早い地点でマッチングしようとし、他の法則はその正規表現が どのようにその最も早く現れた文字位置でマッチングするかを決定しています。</p>
<div class="original">
<p>Here is an example of these principles in action:</p>
</div>
<p>以下はこれらの法則をアクションの中で示した例です:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"The programming republic of Perl"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^(.+)(</span><span class="pln">e</span><span class="pun">|</span><span class="pln">r</span><span class="pun">)(.*)</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $1 = 'The programming republic of Pe'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $2 = 'r'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $3 = 'l'</span></code></pre>
<div class="original">
<p>This regexp matches at the earliest string position, <code>'T'</code>. One might think that <code>'e'</code>, being leftmost in the alternation, would be matched, but <code>'r'</code> produces the longest string in the first quantifier.</p>
</div>
<p>この正規表現は最も早い文字列位置 <code>'T'</code> でマッチングします。 選択の中で最も左にある <code>'e'</code> がマッチングすると考えた人が いるかもしれませんが、<code>'r'</code> が最初の量指定子に関して最長の文字列を 生成します。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(</span><span class="pln">m</span><span class="pun">{</span><span class="lit">1</span><span class="pun">,</span><span class="lit">2</span><span class="pun">})(.*)</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $1 = 'mm'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $2 = 'ing republic of Perl'</span></code></pre>
<div class="original">
<p>Here, The earliest possible match is at the first <code>'m'</code> in <code>programming</code>. <code>m{1,2}</code> is the first quantifier, so it gets to match a maximal <code>mm</code>.</p>
</div>
<p>ここで、最も早い可能な位置は <code>programming</code> の中の最初の <code>'m'</code> です。 <code>m{1,2}</code> は最初の量指定子なので、最も長い <code>mm</code> にマッチングするのです。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/.*(</span><span class="pln">m</span><span class="pun">{</span><span class="lit">1</span><span class="pun">,</span><span class="lit">2</span><span class="pun">})(.*)</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $1 = 'm'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $2 = 'ing republic of Perl'</span></code></pre>
<div class="original">
<p>Here, the regexp matches at the start of the string. The first quantifier <code>.*</code> grabs as much as possible, leaving just a single <code>'m'</code> for the second quantifier <code>m{1,2}</code>.</p>
</div>
<p>これは、文字列の先頭で正規表現はマッチングします。 最初の量指定子 <code>.*</code> は可能な限りの部分をつかみとり、二番目の量指定子 <code>m{1,2}</code> のためには <code>'m'</code> 一文字しか残しません。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(.?)(</span><span class="pln">m</span><span class="pun">{</span><span class="lit">1</span><span class="pun">,</span><span class="lit">2</span><span class="pun">})(.*)</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $1 = 'a'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $2 = 'mm'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $3 = 'ing republic of Perl'</span></code></pre>
<div class="original">
<p>Here, <code>.?</code> eats its maximal one character at the earliest possible position in the string, <code>'a'</code> in <code>programming</code>, leaving <code>m{1,2}</code> the opportunity to match both <code>'m'</code>'s. Finally,</p>
</div>
<p>この例では、<code>.?</code> は文字列の中で可能な限り早い場所での最大一文字、つまり <code>programming</code> の中の <code>'a'</code> をつかみとります; <code>m{1,2}</code> は両方の <code>'m'</code> に マッチングする機会を与えられます。 最終的に、</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"aXXXb"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(</span><span class="pln">X</span><span class="pun">*)/;</span><span class="pln"> </span><span class="com"># matches with $1 = ''</span></code></pre>
<div class="original">
<p>because it can match zero copies of <code>'X'</code> at the beginning of the string. If you definitely want to match at least one <code>'X'</code>, use <code>X+</code>, not <code>X*</code>.</p>
</div>
<p>そしてこうなるわけは、文字列の先頭にある <code>'X'</code> のゼロ回の繰り返しに マッチングすることができるからです。 少なくとも一つの <code>'X'</code> にマッチングさせたいのであるなら、<code>X*</code> ではなく <code>X+</code> を使いましょう。</p>
<div class="original">
<p>Sometimes greed is not good. At times, we would like quantifiers to match a <i>minimal</i> piece of string, rather than a maximal piece. For this purpose, Larry Wall created the <i>minimal match</i> or <i>non-greedy</i> quantifiers <code>??</code>, <code>*?</code>, <code>+?</code>, and <code>{}?</code>. These are the usual quantifiers with a <code>'?'</code> appended to them. They have the following meanings:</p>
</div>
<p>貪欲であることがよくない場合もあります。 文字列の最大の部分ではなく 最小の部分にマッチングする量指定子が欲しいときが あります。 この目的のために、Larry Wall は <i>最小マッチング</i>(minimal match) あるいは <i>無欲な</i>(non-greedy) 量指定子 <code>??</code>, <code>*?</code>, <code>+?</code>, <code>{}?</code> を 作り出しました。 これらは通常の量指定子に <code>'?'</code> を付け加えたものです。 これらは以下のような意味があります:</p>
<ul>
<li><p></p>
<div class="original">
<p><code>a??</code> means: match <code>'a'</code> 0 or 1 times. Try 0 first, then 1.</p>
</div>
<p><code>a??</code> は: 0 回か 1 回の <code>'a'</code> にマッチングします。 はじめに 0 回を試し、それから 1 回を試します。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a*?</code> means: match <code>'a'</code> 0 or more times, <i>i.e.</i>, any number of times, but as few times as possible</p>
</div>
<p><code>a*?</code> は: <code>'a'</code> のゼロ回以上の繰り返しにマッチングします; 任意回の繰り返しができますが、可能な限り少ない回数になります。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a+?</code> means: match <code>'a'</code> 1 or more times, <i>i.e.</i>, at least once, but as few times as possible</p>
</div>
<p><code>a+?</code> は: <code>'a'</code> の一回以上の繰り返しにマッチングします; 一回以上の任意回の繰り返しができますが、可能な限り少ない回数になります。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a{n,m}?</code> means: match at least <code>n</code> times, not more than <code>m</code> times, as few times as possible</p>
</div>
<p><code>a{n,m}?</code> は: <code>n</code> 回以上 <code>m</code> 回以下の繰り返しにマッチングしますが、可能な 限り少ない回数になります。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a{n,}?</code> means: match at least <code>n</code> times, but as few times as possible</p>
</div>
<p><code>a{n,}?</code> は: 少なくとも <code>n</code> 回の繰り返しにマッチングしますが、可能な限り 少ない回数になります。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a{n}?</code> means: match exactly <code>n</code> times. Because we match exactly <code>n</code> times, <code>a{n}?</code> is equivalent to <code>a{n}</code> and is just there for notational consistency.</p>
</div>
<p><code>a{n}?</code> は: ちょうど <code>n</code> 回の繰り返しにマッチングします。 ちょうど <code>n</code> 回なので、<code>a{n}?</code> は <code>a{n}</code> と等価であり、一貫性のためだけに 存在します。</p>
</li>
</ul>
<div class="original">
<p>Let's look at the example above, but with minimal quantifiers:</p>
</div>
<p>先の例を最小量指定子を使ったものにしてみましょう:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"The programming republic of Perl"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^(.+?)(</span><span class="pln">e</span><span class="pun">|</span><span class="pln">r</span><span class="pun">)(.*)</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $1 = 'Th'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $2 = 'e'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $3 = ' programming republic of Perl'</span></code></pre>
<div class="original">
<p>The minimal string that will allow both the start of the string <code>'^'</code> and the alternation to match is <code>Th</code>, with the alternation <code>e|r</code> matching <code>'e'</code>. The second quantifier <code>.*</code> is free to gobble up the rest of the string.</p>
</div>
<p>マッチングするために文字列の開始位置 <code>'^'</code> と選択の両方を満足する最小の 文字列は <code>Th</code> で、選択 <code>e|r</code> は <code>'e'</code> にマッチングします。 二番目の量指定子 <code>.*</code> は文字列の残りから自由につかみとることができます。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(</span><span class="pln">m</span><span class="pun">{</span><span class="lit">1</span><span class="pun">,</span><span class="lit">2</span><span class="pun">}?)(.*?)</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $1 = 'm'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $2 = 'ming republic of Perl'</span></code></pre>
<div class="original">
<p>The first string position that this regexp can match is at the first <code>'m'</code> in <code>programming</code>. At this position, the minimal <code>m{1,2}?</code> matches just one <code>'m'</code>. Although the second quantifier <code>.*?</code> would prefer to match no characters, it is constrained by the end-of-string anchor <code>'$'</code> to match the rest of the string.</p>
</div>
<p>この正規表現がマッチングすることのできる文字列の最初の位置は <code>programming</code> の中の最初の <code>'m'</code> です。 この位置で、最小マッチング <code>m{1,2}?</code> はただ一つの <code>'m'</code> です。 二番目の量指定子 <code>.*?</code> が空にマッチングしようとしますがそれは文字列の 終端アンカー <code>'$'</code> が阻止して、文字列の残りにマッチングします。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(.*?)(</span><span class="pln">m</span><span class="pun">{</span><span class="lit">1</span><span class="pun">,</span><span class="lit">2</span><span class="pun">}?)(.*)</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $1 = 'The progra'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $2 = 'm'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $3 = 'ming republic of Perl'</span></code></pre>
<div class="original">
<p>In this regexp, you might expect the first minimal quantifier <code>.*?</code> to match the empty string, because it is not constrained by a <code>'^'</code>
 anchor to match the beginning of the word. Principle 0 applies here, 
however. Because it is possible for the whole regexp to match at the 
start of the string, it <i>will</i> match at the start of the string. Thus the first quantifier has to match everything up to the first <code>'m'</code>. The second minimal quantifier matches just one <code>'m'</code> and the third quantifier matches the rest of the string.</p>
</div>
<p>この正規表現において、最小量指定子 <code>.*?</code> は空文字列にマッチングすると 考えるかもしれませんが、<code>'^'</code> アンカーが単語の先頭にマッチングすることを 強制していません。 法則 0 がここで適用されます。 文字列の先頭で正規表現全体をマッチングさせることが可能なので、文字列の先頭で マッチング <i>します</i>。 したがって、最初の量指定子は最初の <code>'m'</code> までにマッチングします。 二番目の最小量指定子はただ一文字の <code>'m'</code> にマッチングして、三番目の量指定子が 文字列の残りにマッチングします。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(.??)(</span><span class="pln">m</span><span class="pun">{</span><span class="lit">1</span><span class="pun">,</span><span class="lit">2</span><span class="pun">})(.*)</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $1 = 'a'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $2 = 'mm'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $3 = 'ing republic of Perl'</span></code></pre>
<div class="original">
<p>Just as in the previous regexp, the first quantifier <code>.??</code> can match earliest at position <code>'a'</code>, so it does. The second quantifier is greedy, so it matches <code>mm</code>, and the third matches the rest of the string.</p>
</div>
<p>先の正規表現と同じようですが、最初の量指定子 <code>.??</code> は最初の <code>'a'</code> の 位置でマッチングできるのでそうします。 二番目の量指定子は貪欲なので <code>mm</code> にマッチングし、三番目のものが文字列の 残りにマッチングします。</p>
<div class="original">
<p>We can modify principle 3 above to take into account non-greedy quantifiers:</p>
</div>
<p>先に挙げた法則 3 を、無欲な量指定子を考慮したものにするために修正します:</p>
<ul>
<li><p></p>
<div class="original">
<p>Principle 3: If there are two or more elements in a regexp, the 
leftmost greedy (non-greedy) quantifier, if any, will match as much 
(little) of the string as possible while still allowing the whole regexp
 to match. The next leftmost greedy (non-greedy) quantifier, if any, 
will try to match as much (little) of the string remaining available to 
it as possible, while still allowing the whole regexp to match. And so 
on, until all the regexp elements are satisfied.</p>
</div>
<p>法則 3: 正規表現の中に二つ以上の要素があったならば、貪欲な量指定子(もしくは 無欲な量指定子)がもしあれば、その中で最も左にあるものが
 正規表現全体がマッチングする条件において可能な限りの長さでマッチングする。 
次の貪欲な量指定子(もしくは無欲な量指定子)があれば、それは残りの中で 
正規表現全体がマッチングする条件において最も長い(最も短い)文字列にマッチングする。 これをすべての正規表現要素が満足されるまで繰り返す。</p>
</li>
</ul>
<div class="original">
<p>Just like alternation, quantifiers are also susceptible to backtracking. Here is a step-by-step analysis of the example</p>
</div>
<p>選択と同じように、量指定子もまたバックトラッキングを行う可能性があります。 以下はステップごとに追った例です</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"the cat in the hat"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^(.*)(</span><span class="pln">at</span><span class="pun">)(.*)</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $1 = 'the cat in the h'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $2 = 'at'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $3 = '' &nbsp; (0 matches)</span></code></pre>
<dl>
<dt>0. Start with the first letter in the string <code>'t'</code>.</dt>
<dd>
<p>(0. 文字列の最初の文字 <code>'t'</code> で始まる。)</p>
<p>&nbsp;</p>
</dd>
<dt>1. The first quantifier <code>'.*'</code> starts out by matching the whole string "<code>the cat in the hat</code>".</dt>
<dd>
<p>(1. 最初の量指定子 <code>'.*'</code> は文字列全体 "<code>the cat in the hat</code>" にまずはじめにマッチングする。)</p>
<p>&nbsp;</p>
</dd>
<dt>2. <code>'a'</code> in the regexp element <code>'at'</code> doesn't match the end of the string. Backtrack one character.</dt>
<dd>
<p>(2. 正規表現要素 <code>'at'</code> の <code>'a'</code> は文字列の末尾にマッチングしない。一文字後戻りする。)</p>
<p>&nbsp;</p>
</dd>
<dt>3. <code>'a'</code> in the regexp element <code>'at'</code> still doesn't match the last letter of the string <code>'t'</code>, so backtrack one more character.</dt>
<dd>
<p>(3. 正規表現要素 <code>'at'</code> の <code>'a'</code> は文字列の最後の文字 <code>'t'</code> にマッチングしないので、更に一文字後戻りする。)</p>
<p>&nbsp;</p>
</dd>
<dt>4. Now we can match the <code>'a'</code> and the <code>'t'</code>.</dt>
<dd>
<p>(4. ここで <code>'a'</code> と <code>'t'</code> にマッチングすることができる。)</p>
<p>&nbsp;</p>
</dd>
<dt>5. Move on to the third element <code>'.*'</code>. Since we are at the end of the string and <code>'.*'</code> can match 0 times, assign it the empty string.</dt>
<dd>
<p>(三番目の要素 <code>'.*'</code> に移る。文字列の末尾に位置していて、<code>'.*'</code> は 0 回の繰り返しにマッチングすることができるので空文字列を代入する。)</p>
<p>&nbsp;</p>
</dd>
<dt>6. We are done!</dt>
<dd>
<p>(完了!)</p>
</dd>
</dl>
<div class="original">
<p>Most of the time, all this moving forward and backtracking happens 
quickly and searching is fast. There are some pathological regexps, 
however, whose execution time exponentially grows with the size of the 
string. A typical structure that blows up in your face is of the form</p>
</div>
<p>ほとんどの場合、前方への移動と後戻りが起こったときには迅速に行われ、 検索は高速です。 
しかしながら、中には文字列の長さに応じて指数的に実行時間が延びるような 病理学的(pathological)な正規表現もあります。 
そのようなものの例は以下のようなものです</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/(</span><span class="pln">a</span><span class="pun">|</span><span class="pln">b</span><span class="pun">+)*/;</span></code></pre>
<div class="original">
<p>The problem is the nested indeterminate quantifiers. There are many 
different ways of partitioning a string of length n between the <code>'+'</code> and <code>'*'</code>: one repetition with <code>b+</code> of length n, two repetitions with the first <code>b+</code> length k and the second with length n-k, m repetitions whose bits add up to length n, <i>etc</i>.
 In fact there are an exponential number of ways to partition a string 
as a function of its length. A regexp may get lucky and match early in 
the process, but if there is no match, Perl will try <i>every</i> possibility before giving up. So be careful with nested <code>'*'</code>'s, <code>{n,m}</code>'s, and <code>'+'</code>'s. The book <i>Mastering Regular Expressions</i> by Jeffrey Friedl gives a wonderful discussion of this and other efficiency issues.</p>
</div>
<p>問題は不確定のネストした量指定子があることです。 <code>'+'</code> と <code>'*'</code> の間にある長さ n の文字列には複数の異なる分け方が存在します: 一つは長さ n の <code>b+</code> で、二つ目は長さ k の <code>b+</code>
 と n-k の長さのもの、 繰り返し m は長さ n まで加える、などです。 長さの関数として文字列を分割する方法の数は指数的な数になります。
 正規表現は幸運なときには処理の早い段階でマッチングに成功するかもしれませんが、 マッチングしなかった場合には Perl は音を上げるまで <i>すべての</i> 可能性を 試します。 ですから、ネストした <code>'*'</code>, <code>{n,m}</code>, <code>'+'</code> には注意してください。 Jeffrey Friedl による <i>Mastering Regular Expressions</i> (邦訳 「詳説正規表現」) という本はこういった効率の問題についてすばらしい 解説をしています。</p>
<h2 id="Possessive32quantifiers">絶対最大量指定子<a href="#Possessive32quantifiers" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Backtracking during the relentless search for a match may be a waste 
of time, particularly when the match is bound to fail. Consider the 
simple pattern</p>
</div>
<p>マッチングのための容赦ない検索中のバックトラッキングは時間の無駄の場合が あります; とくにマッチングが失敗する運命にあるときはそうです。 簡単なパターンを考えてみます</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/^\</span><span class="pln">w</span><span class="pun">+\</span><span class="pln">s</span><span class="pun">+\</span><span class="pln">w</span><span class="pun">+</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># a word, spaces, a word</span></code></pre>
<div class="original">
<p>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as <span style="white-space: nowrap;"><code>"abc "</code></span> or <span style="white-space: nowrap;"><code>"abc def "</code></span>,
 the regexp engine will backtrack, approximately once for each character
 in the string. But we know that there is no way around taking <i>all</i> of the initial word characters to match the first repetition, that <i>all</i> spaces must be eaten by the middle part, and the same goes for the second word.</p>
</div>
<p>これが、<span style="white-space: nowrap;"><code>"abc "</code></span> や <span style="white-space: nowrap;"><code>"abc def "</code></span> のような、パターンが 想定していなかったような文字列に適用されると、正規表現エンジンは 文字列のそれぞれの文字に対してほぼ 1 回バックトラックを行います。 しかし、私たちは <i>全ての</i> 最初の単語文字列が最初の繰り返しにマッチングし、 <i>全ての</i> 空白が中間の部分で消費され、2 番目の単語も同じように なるしかない、ということを知っています。</p>
<div class="original">
<p>With the introduction of the <i>possessive quantifiers</i> in Perl 5.10, we have a way of instructing the regexp engine not to backtrack, with the usual quantifiers with a <code>'+'</code>
 appended to them. This makes them greedy as well as stingy; once they 
succeed they won't give anything back to permit another solution. They 
have the following meanings:</p>
</div>
<p>Perl 5.10 での <i>絶対最大量指定子</i> の導入によって、 普通の量指定子に <code>'+'</code> 
を追加することで、正規表現エンジンに バックトラックしないように指示することができるようになります。 
これは貪欲であるのと同様出し惜しみをするようにします; 一旦マッチングすると、 他の解決策のために手放すということをしなくなります。 
これらは以下のような意味があります:</p>
<ul>
<li><p></p>
<div class="original">
<p><code>a{n,m}+</code> means: match at least <code>n</code> times, not more than <code>m</code> times, as many times as possible, and don't give anything up. <code>a?+</code> is short for <code>a{0,1}+</code></p>
</div>
<p><code>a{n,m}+</code> は: 最小で <code>n</code> 回、最大で <code>m</code> 回の間で出来るだけたくさん マッチングし、そして何も手放しません。 <code>a?+</code> は <code>a{0,1}+</code> の省略形です。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a{n,}+</code> means: match at least <code>n</code> times, but as many times as possible, and don't give anything up. <code>a*+</code> is short for <code>a{0,}+</code> and <code>a++</code> is short for <code>a{1,}+</code>.</p>
</div>
<p><code>a{n,}+</code> は: 最小で <code>n</code> 回で出来るだけたくさんマッチングし、 そして何も手放しません。 <code>a*+</code> は <code>a{0,}+</code> の省略形で、<code>a++</code> は <code>a{1,}+</code> の省略形です。</p>
</li>
<li><p></p>
<div class="original">
<p><code>a{n}+</code> means: match exactly <code>n</code> times. It is just there for notational consistency.</p>
</div>
<p><code>a{n}+</code> は: 正確に <code>n</code> 回にマッチングします。 これは単に一貫性のためにあります。</p>
</li>
</ul>
<div class="original">
<p>These possessive quantifiers represent a special case of a more general concept, the <i>independent subexpression</i>, see below.</p>
</div>
<p>これらの絶対最大量指定子は、以下で述べる、より一般的な概念である <i>独立部分式</i> の特殊な場合を表現しています。</p>
<div class="original">
<p>As an example where a possessive quantifier is suitable we consider 
matching a quoted string, as it appears in several programming 
languages. The backslash is used as an escape character that indicates 
that the next character is to be taken literally, as another character 
for the string. Therefore, after the opening quote, we expect a 
(possibly empty) sequence of alternatives: either some character except 
an unescaped quote or backslash or an escaped character.</p>
</div>
<p>絶対最大量指定子がふさわしい例として、いくつかのプログラミング言語で 現れるような、クォートされた文字列のマッチングを考えます。 
バックスラッシュは次の文字が他の文字と同様リテラルに扱われることを示す エスケープ文字として使われます。 
従って、開きクォートの後、選択肢の(空かもしれない)並びを想定します: エスケープされていないクォート文字以外の何らかの文字か、 
バックスラッシュか、エスケープされた文字です。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/</span><span class="str">"(?:[^"</span><span class="pun">\\]++|\\.)*+</span><span class="str">"/;</span></code></pre>
<h2 id="Building32a32regexp">正規表現を組み立てる<a href="#Building32a32regexp" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>At this point, we have all the basic regexp concepts covered, so 
let's give a more involved example of a regular expression. We will 
build a regexp that matches numbers.</p>
</div>
<p>ここまでで、すべての基本的な正規表現のコンセプトをカバーしました; ですから、もっと複雑な正規表現に行ってみましょう。 例として、数値にマッチングする正規表現を組み立てます。</p>
<div class="original">
<p>The first task in building a regexp is to decide what we want to 
match and what we want to exclude. In our case, we want to match both 
integers and floating point numbers and we want to reject any string 
that isn't a number.</p>
</div>
<p>正規表現を組み立てるにあたっての最初の仕事は何にマッチングさせるかと何を 排除するかを決めることです。 今回は、整数と浮動小数点数の両方にマッチングさせ、数値でない文字列をすべて 排除します。</p>
<div class="original">
<p>The next task is to break the problem down into smaller problems that are easily converted into a regexp.</p>
</div>
<p>次の仕事は問題を、より正規表現に変換しやすい小さいな問題に 分解することです。</p>
<div class="original">
<p>The simplest case is integers. These consist of a sequence of digits,
 with an optional sign in front. The digits we can represent with <code>\d+</code> and the sign can be matched with <code>[+-]</code>. Thus the integer regexp is</p>
</div>
<p>もっとも簡単なケースは整数です。 これは数字の並びであり、省略可能な符号が先頭にあります。 数字は <code>\d+</code> で表すことができ、符号は <code>[+-]</code> にマッチングさせることが できます。 したがって、整数にマッチングする正規表現は以下のようになります</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/[+-]?\</span><span class="pln">d</span><span class="pun">+/;</span><span class="pln"> &nbsp;</span><span class="com"># matches integers</span></code></pre>
<div class="original">
<p>A floating point number potentially has a sign, an integral part, a 
decimal point, a fractional part, and an exponent. One or more of these 
parts is optional, so we need to check out the different possibilities. 
Floating point numbers which are in proper form include 123., 0.345, 
.34, -1e6, and 25.4E-72. As with integers, the sign out front is 
completely optional and can be matched by <code>[+-]?</code>. We can see
 that if there is no exponent, floating point numbers must have a 
decimal point, otherwise they are integers. We might be tempted to model
 these with <code>\d*\.\d*</code>, but this would also match just a 
single decimal point, which is not a number. So the three cases of 
floating point number without exponent are</p>
</div>
<p>浮動小数点数は符号と、整数部と、小数点と、小数部と、指数部を持つ可能性が あります。 
これらの一つ以上のパーツが省略可能であり、可能なものをチェックする必要が あります。 
正しい形式の浮動小数点数は123.、0.345、.34、-1e6、25.4E072 といったものを 含みます。 
整数と同じように、先頭にある符合は省略可能で <code>[+-]?</code> にマッチングします。 もし指数部がないことがわかれば、浮動小数点数は小数点を持たなければならず、 これがない場合にはそれは整数です。 <code>\d*\.\d*</code> というパターンを使うことを思いつくかもしれませんが、これは 数値ではないただ一つの小数点にもマッチングしてしまいます。 ですから、指数部のない浮動小数点には以下の三つのケースが存在します</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/[+-]?\</span><span class="pln">d</span><span class="pun">+\./;</span><span class="pln"> &nbsp;</span><span class="com"># 1., 321., etc.</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="pun">/[+-]?\.\</span><span class="pln">d</span><span class="pun">+</span><span class="str">/; &nbsp;# .1, .234, etc.<br>&nbsp; &nbsp;/</span><span class="pun">[+-]?\</span><span class="pln">d</span><span class="pun">+\.\</span><span class="pln">d</span><span class="pun">+/;</span><span class="pln"> &nbsp;</span><span class="com"># 1.0, 30.56, etc.</span></code></pre>
<div class="original">
<p>These can be combined into a single regexp with a three-way alternation:</p>
</div>
<p>これらは三つの選択を使った単一の正規表現にまとめることができます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/[+-]?(\</span><span class="pln">d</span><span class="pun">+\.\</span><span class="pln">d</span><span class="pun">+|\</span><span class="pln">d</span><span class="pun">+\.|\.\</span><span class="pln">d</span><span class="pun">+)/;</span><span class="pln"> &nbsp;</span><span class="com"># floating point, no exponent</span></code></pre>
<div class="original">
<p>In this alternation, it is important to put <code>'\d+\.\d+'</code> before <code>'\d+\.'</code>. If <code>'\d+\.'</code> were first, the regexp would happily match that and ignore the fractional part of the number.</p>
</div>
<p>この選択肢において、<code>'\d+\.\d+'が'\d+\.'</code> より前に置かれていることが 重要です。 もし <code>'\d+\.'</code> が先頭にあったなら、この正規表現は数値の小数部を無視して マッチングしてしまうでしょう。</p>
<div class="original">
<p>Now consider floating point numbers with exponents. The key observation here is that <i>both</i>
 integers and numbers with decimal points are allowed in front of an 
exponent. Then exponents, like the overall sign, are independent of 
whether we are matching numbers with or without decimal points, and can 
be "decoupled" from the mantissa. The overall form of the regexp now 
becomes clear:</p>
</div>
<p>ここで指数部を持つ浮動小数点数を考えてみましょう。 ここでのポイントは指数部の前に整数と小数点を伴った数の <i>両方</i> が 現れることができるということです。 指数部は符号と同じように、小数点を伴うか伴わないかに関係なくマッチングし、 仮数部から「分離」することも可能です。 正規表現の全体の形式がこれで明らかになりました:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/^(</span><span class="pln">optional sign</span><span class="pun">)(</span><span class="pln">integer </span><span class="pun">|</span><span class="pln"> f</span><span class="pun">.</span><span class="pln">p</span><span class="pun">.</span><span class="pln"> mantissa</span><span class="pun">)(</span><span class="pln">optional exponent</span><span class="pun">)</span><span class="pln">$</span><span class="pun">/;</span></code></pre>
<div class="original">
<p>The exponent is an <code>'e'</code> or <code>'E'</code>, followed by an integer. So the exponent regexp is</p>
</div>
<p>指数部は整数が続く <code>'e'</code> もしくは <code>'E'</code> です。 ですから指数部の正規表現は以下のようになります</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/[</span><span class="pln">eE</span><span class="pun">][+-]?\</span><span class="pln">d</span><span class="pun">+/;</span><span class="pln"> &nbsp;</span><span class="com"># exponent</span></code></pre>
<div class="original">
<p>Putting all the parts together, we get a regexp that matches numbers:</p>
</div>
<p>すべてのパーツを一つにまとめることによって、数値にマッチングする正規表現を 手に入れます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/^[+-]?(\</span><span class="pln">d</span><span class="pun">+\.\</span><span class="pln">d</span><span class="pun">+|\</span><span class="pln">d</span><span class="pun">+\.|\.\</span><span class="pln">d</span><span class="pun">+|\</span><span class="pln">d</span><span class="pun">+)([</span><span class="pln">eE</span><span class="pun">][+-]?\</span><span class="pln">d</span><span class="pun">+)?</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># Ta da!</span></code></pre>
<div class="original">
<p>Long regexps like this may impress your friends, but can be hard to decipher. In complex situations like this, the <code>/x</code>
 modifier for a match is invaluable. It allows one to put nearly 
arbitrary whitespace and comments into a regexp without affecting their 
meaning. Using it, we can rewrite our "extended" regexp in the more 
pleasing form</p>
</div>
<p>このような長い正規表現を友人に説明することがあるかもしれませんが、 解読するのが難しいかもしれません。 このような複雑なものにおいては、<code>/x</code> 修飾子は重要なものです。 この修飾子は正規表現に対してその意味を変えることなく、ほぼ任意の空白を 入れたりコメントを入れたりすることを許します。 これを使うことによって、よりわかりやすい形式に正規表現を 「拡張」することができます</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/^</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">[+-]?</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># first, match an optional sign</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># then match integers or f.p. mantissas:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+\.\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp;</span><span class="com"># mantissa of the form a.b</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\</span><span class="pln">d</span><span class="pun">+\.</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># mantissa of the form a.</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\.\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># mantissa of the form .b</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># integer of the form a</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> </span><span class="pun">[</span><span class="pln">eE</span><span class="pun">]</span><span class="pln"> </span><span class="pun">[+-]?</span><span class="pln"> </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> </span><span class="pun">)?</span><span class="pln"> &nbsp;</span><span class="com"># finally, optionally match an exponent</span><span class="pln"><br>&nbsp; &nbsp;$</span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/^</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">[+-]?</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># まずはじめに、省略可能な符号にマッチング</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 続いて整数か f.p. 仮数部にマッチング:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+\.\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp;</span><span class="com"># a.b 形式の仮数部</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\</span><span class="pln">d</span><span class="pun">+\.</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># a. 形式の仮数部</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\.\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># .b 形式の仮数部</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># a 形式の整数</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> </span><span class="pun">[</span><span class="pln">eE</span><span class="pun">]</span><span class="pln"> </span><span class="pun">[+-]?</span><span class="pln"> </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> </span><span class="pun">)?</span><span class="pln"> &nbsp;</span><span class="com"># 最後に、省略可能な指数部にマッチング</span><span class="pln"><br>&nbsp; &nbsp;$</span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span></code></pre>
<div class="original">
<p>If whitespace is mostly irrelevant, how does one include space characters in an extended regexp? The answer is to backslash it <span style="white-space: nowrap;"><code>'\ '</code></span> or put it in a character class <span style="white-space: nowrap;"><code>[ ]</code></span>. The same thing goes for pound signs: use <code>\#</code> or <code>[#]</code>.
 For instance, Perl allows a space between the sign and the mantissa or 
integer, and we could add this to our regexp as follows:</p>
</div>
<p>もし空白が余計なものであれば、拡張された正規表現にスペースを含ませるには どうすればよいのでしょうか? その答えは <span style="white-space: nowrap;"><code>'\ '</code></span> のように バックスラッシュを前置するか、<span style="white-space: nowrap;"><code>[ ]</code></span> のように文字クラスに 押し込めることです。 同じことが '#' にも言えます: <code>\#</code> か <code>[#]</code> を使います。 たとえば、Perl が符号と仮数部(もしくは整数部) の間に空白を置くことを 許すとすると、以下のように正規表現に加えることができます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/^</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">[+-]?\</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># first, match an optional sign *and space*</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># then match integers or f.p. mantissas:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+\.\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp;</span><span class="com"># mantissa of the form a.b</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\</span><span class="pln">d</span><span class="pun">+\.</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># mantissa of the form a.</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\.\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># mantissa of the form .b</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># integer of the form a</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> </span><span class="pun">[</span><span class="pln">eE</span><span class="pun">]</span><span class="pln"> </span><span class="pun">[+-]?</span><span class="pln"> </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> </span><span class="pun">)?</span><span class="pln"> &nbsp;</span><span class="com"># finally, optionally match an exponent</span><span class="pln"><br>&nbsp; &nbsp;$</span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/^</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">[+-]?\</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># まずはじめに、省略可能な符号と*スペース*にマッチング</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 続いて整数か f.p. 仮数部にマッチング:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+\.\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp;</span><span class="com"># a.b 形式の仮数部</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\</span><span class="pln">d</span><span class="pun">+\.</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># a. 形式の仮数部</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\.\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># .b 形式の仮数部</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># a 形式の整数</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> </span><span class="pun">[</span><span class="pln">eE</span><span class="pun">]</span><span class="pln"> </span><span class="pun">[+-]?</span><span class="pln"> </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> </span><span class="pun">)?</span><span class="pln"> &nbsp;</span><span class="com"># 最後に、省略可能な指数部にマッチング</span><span class="pln"><br>&nbsp; &nbsp;$</span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span></code></pre>
<div class="original">
<p>In this form, it is easier to see a way to simplify the alternation. Alternatives 1, 2, and 4 all start with <code>\d+</code>, so it could be factored out:</p>
</div>
<p>この形式においては、選択肢を単純にする方法を見つけるのは簡単です。 選択肢 1, 2, 4 はすべて <code>\d+</code> で始まっています; ですからこれは まとめることができます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/^</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">[+-]?\</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># first, match an optional sign</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># then match integers or f.p. mantissas:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># start out with a ...</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">\.\</span><span class="pln">d</span><span class="pun">*</span><span class="pln"> </span><span class="com"># mantissa of the form a.b or a.</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">)?</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># ? takes care of integers of the form a</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\.\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># mantissa of the form .b</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> </span><span class="pun">[</span><span class="pln">eE</span><span class="pun">]</span><span class="pln"> </span><span class="pun">[+-]?</span><span class="pln"> </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> </span><span class="pun">)?</span><span class="pln"> &nbsp;</span><span class="com"># finally, optionally match an exponent</span><span class="pln"><br>&nbsp; &nbsp;$</span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/^</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">[+-]?\</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># まずはじめに、省略可能な符号にマッチング</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 続いて整数か f.p. 仮数部にマッチング:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># はじめは…</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">\.\</span><span class="pln">d</span><span class="pun">*</span><span class="pln"> </span><span class="com"># a.b形式もしくはa.形式の仮数部</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">)?</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># ? はa形式の整数を考慮する</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\.\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># .b形式の仮数部</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> </span><span class="pun">[</span><span class="pln">eE</span><span class="pun">]</span><span class="pln"> </span><span class="pun">[+-]?</span><span class="pln"> </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> </span><span class="pun">)?</span><span class="pln"> &nbsp;</span><span class="com"># 最後に、省略可能な指数部にマッチング</span><span class="pln"><br>&nbsp; &nbsp;$</span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span></code></pre>
<div class="original">
<p>Starting in Perl v5.26, specifying <code>/xx</code> changes the 
square-bracketed portions of a pattern to ignore tabs and space 
characters unless they are escaped by preceding them with a backslash. 
So, we could write</p>
</div>
<p>Perl v5.26 から、<code>/xx</code> を指定すると、逆スラッシュを前置することによって エスケープしない限り、タブとスペースの文字をを無視するように パターンの大かっこで囲まれた部分を変更します。 従って、次のように書けます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/^</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">[</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="pun">]?\</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> &nbsp; </span><span class="com"># first, match an optional sign</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># then match integers or f.p. mantissas:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># start out with a ...</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">\.\</span><span class="pln">d</span><span class="pun">*</span><span class="pln"> </span><span class="com"># mantissa of the form a.b or a.</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">)?</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># ? takes care of integers of the form a</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|\.\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># mantissa of the form .b</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(</span><span class="pln"> </span><span class="pun">[</span><span class="pln"> e E </span><span class="pun">]</span><span class="pln"> </span><span class="pun">[</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="pun">]?</span><span class="pln"> </span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> </span><span class="pun">)?</span><span class="pln"> &nbsp;</span><span class="com"># finally, optionally match an exponent</span><span class="pln"><br>&nbsp; &nbsp;$</span><span class="pun">/</span><span class="pln">xx</span><span class="pun">;</span></code></pre>
<div class="original">
<p>This doesn't really improve the legibility of this example, but it's 
available in case you want it. Squashing the pattern down to the compact
 form, we have</p>
</div>
<p>これはこの例の読みやすさを本当に改善してはいませんが、 使いたい場所では利用可能です。 コンパクトな型式にパターンを圧縮すると、次のようになります:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/^[+-]?\</span><span class="pln"> </span><span class="pun">*(\</span><span class="pln">d</span><span class="pun">+(\.\</span><span class="pln">d</span><span class="pun">*)?|\.\</span><span class="pln">d</span><span class="pun">+)([</span><span class="pln">eE</span><span class="pun">][+-]?\</span><span class="pln">d</span><span class="pun">+)?</span><span class="pln">$</span><span class="pun">/;</span></code></pre>
<div class="original">
<p>This is our final regexp. To recap, we built a regexp by</p>
</div>
<p>これが最終形の正規表現です。 ここでは以下のようにして正規表現を組み立てました。</p>
<ul>
<li><p></p>
<div class="original">
<p>specifying the task in detail,</p>
</div>
<p>なすべきことを詳細に確定し、</p>
</li>
<li><p></p>
<div class="original">
<p>breaking down the problem into smaller parts,</p>
</div>
<p>問題を小さなパーツに分割し、</p>
</li>
<li><p></p>
<div class="original">
<p>translating the small parts into regexps,</p>
</div>
<p>その小さなパーツを正規表現に変換し、</p>
</li>
<li><p></p>
<div class="original">
<p>combining the regexps,</p>
</div>
<p>その正規表現を組み合わせ、</p>
</li>
<li><p></p>
<div class="original">
<p>and optimizing the final combined regexp.</p>
</div>
<p>組み合わされた最終的な正規表現を最適化する。</p>
</li>
</ul>
<div class="original">
<p>These are also the typical steps involved in writing a computer 
program. This makes perfect sense, because regular expressions are 
essentially programs written in a little computer language that 
specifies patterns.</p>
</div>
<p>これはコンピュータプログラムを書くにあたっての典型的なステップでも あります。 正規表現はパターンを特定する小さなコンピュータ言語で書く プログラムであるので、このことはまさに当てはまります。</p>
<h2 id="Using32regular32expressions32in32Perl">Perl で正規表現を使う<a href="#Using32regular32expressions32in32Perl" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>The last topic of Part 1 briefly covers how regexps are used in Perl programs. Where do they fit into Perl syntax?</p>
</div>
<p>パート 1 の最後のトピックは正規表現がPerlプログラムでどのように 使われているかを説明します。 正規表現は Perl の構文のどこにフィットしているのでしょう?</p>
<div class="original">
<p>We have already introduced the matching operator in its default <code>/regexp/</code> and arbitrary delimiter <code>m!regexp!</code> forms. We have used the binding operator <code>=~</code> and its negation <code>!~</code> to test for string matches. Associated with the matching operator, we have discussed the single line <code>/s</code>, multi-line <code>/m</code>, case-insensitive <code>/i</code> and extended <code>/x</code> modifiers. There are a few more things you might want to know about matching operators.</p>
</div>
<p>すでにデフォルトの <code>/regexp/</code> と任意のデリミタを持つ <code>m!regexp!</code> 形式の マッチング演算子を説明しています。 マッチングさせる文字列を指定するために <code>=~</code> 演算子や <code>!~</code> 演算子を 使っています。 マッチング演算子について、単一行修飾子 <code>/s</code>、複数行修飾子 <code>/m</code>、 大小文字の違いを無視する修飾子 <code>/i</code>、拡張修飾子 <code>/x</code> について述べました。 マッチング演算子に関して、知っておきたいであろういくつかの事柄があります。</p>
<h3 id="Prohibiting32substitution">置換を禁止する<a href="#Prohibiting32substitution" class="toc_link">¶</a></h3>
<p></p>
<div class="original">
<p>If you change <code>$pattern</code> after the first substitution 
happens, Perl will ignore it. If you don't want any substitutions at 
all, use the special delimiter <code>m''</code>:</p>
</div>
<p>もし最初の置換が行われた後で <code>$pattern</code> を変更したとしても、Perl は それを無視します。 すべての置換を行いたくないというのであれば、特殊なデリミタ <code>m''</code> を使います:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="lit">@pattern</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="str">'Seuss'</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(&lt;&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> m</span><span class="str">'@pattern'</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># matches literal '@pattern', not 'Seuss'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="lit">@pattern</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="str">'Seuss'</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(&lt;&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> m</span><span class="str">'@pattern'</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># 'Seuss' ではなくリテラルの '@pattern' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>Similar to strings, <code>m''</code> acts like apostrophes on a regexp; all other <code>'m'</code> delimiters act like quotes. If the regexp evaluates to the empty string, the regexp in the <i>last successful match</i> is used instead. So we have</p>
</div>
<p>文字列と同様、<code>m''</code> は正規表現においてシングルクォートのように振舞います。 他のすべての <code>'m'</code> デリミタはダブルクォートのように振舞います。 もし正規表現が空文字列を評価したならば、その正規表現は <i>最後に成功した</i> マッチングにある正規表現が代わりに使われます。</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"dog"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">d</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 'd' matches</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"dogbert =~ //; &nbsp;# this matches the 'd' regexp used before</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"dog"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">d</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 'd' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">"dogbert =~ //; &nbsp;# 直前に使われた正規表現である 'd' にマッチング</span></code></pre>
<h3 id="Global32matching">グローバルマッチング<a href="#Global32matching" class="toc_link">¶</a></h3>
<p></p>
<div class="original">
<p>The final two modifiers we will discuss here, <code>/g</code> and <code>/c</code>, concern multiple matches. The modifier <code>/g</code>
 stands for global matching and allows the matching operator to match 
within a string as many times as possible. In scalar context, successive
 invocations against a string will have <code>/g</code> jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the <code>pos()</code> function.</p>
</div>
<p>ここで議論する最後の二つの修飾子 <code>/g</code> と <code>/c</code> は複数回マッチングに 関連するものです。 修飾子 <code>/g</code> はグローバルマッチングを意味し、マッチング演算子に対して 文字列の中で可能な限りの回数マッチングするようにします。 スカラコンテキストでは、ある文字列に対する連続した呼び出しはマッチングから マッチングへとジャンプする <code>/g</code> を持ち、その文字列の中での位置を記憶します。 <code>pos()</code> 関数を使ってこの位置を取り出したり設定したりすることができます。</p>
<div class="original">
<p>The use of <code>/g</code> is shown in the following example. Suppose
 we have a string that consists of words separated by spaces. If we know
 how many words there are in advance, we could extract the words using 
groupings:</p>
</div>
<p><code>/g</code> を使った例を以下に挙げます。 ここで、空白によって区切られた単語の並びからなる文字列があるとします。 もしいくつの単語があるかがわかっていれば、グループ化を使って単語を 取り出すことができます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"cat dog house"</span><span class="pun">;</span><span class="pln"> </span><span class="com"># 3 words</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">s</span><span class="pun">*(\</span><span class="pln">w</span><span class="pun">+)\</span><span class="pln">s</span><span class="pun">+(\</span><span class="pln">w</span><span class="pun">+)\</span><span class="pln">s</span><span class="pun">+(\</span><span class="pln">w</span><span class="pun">+)\</span><span class="pln">s</span><span class="pun">*</span><span class="pln">$</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $1 = 'cat'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $2 = 'dog'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $3 = 'house'</span></code></pre>
<div class="original">
<p>But what if we had an indeterminate number of words? This is the sort of task <code>/g</code> was made for. To extract all words, form the simple regexp <code>(\w+)</code> and loop over all matches with <code>/(\w+)/g</code>:</p>
</div>
<p>しかしもし不定個の単語があるとしたら? これが <code>/g</code> が作られた理由となった類の仕事です。 すべての単語を取り出すために、単純な <code>(\w+)</code> という正規表現を使い、 <code>/(\w+)/g</code> をループで使ってすべてにマッチングさせます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(\</span><span class="pln">w</span><span class="pun">+)/</span><span class="pln">g</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Word is $1, ends at position "</span><span class="pun">,</span><span class="pln"> pos $x</span><span class="pun">,</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>prints</p>
</div>
<p>以下の出力を行います</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="typ">Word</span><span class="pln"> is cat</span><span class="pun">,</span><span class="pln"> ends at position </span><span class="lit">3</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Word</span><span class="pln"> is dog</span><span class="pun">,</span><span class="pln"> ends at position </span><span class="lit">7</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Word</span><span class="pln"> is house</span><span class="pun">,</span><span class="pln"> ends at position </span><span class="lit">13</span></code></pre>
<div class="original">
<p>A failed match or changing the target string resets the position. If 
you don't want the position reset after failure to match, add the <code>/c</code>, as in <code>/regexp/gc</code>.
 The current position in the string is associated with the string, not 
the regexp. This means that different strings have different positions 
and their respective positions can be set or read independently.</p>
</div>
<p>マッチングに失敗したり、ターゲット文字列を変更するとこの位置は リセットされます。 もしマッチングに失敗したときに位置をリセットしたくないのであれば、 <code>/regexp/gc</code> のように <code>/c</code> を追加します。 文字列の中のカレント位置はその文字列に結び付けられていて、正規表現にでは ありません。 このことは異なる文字列は異なる位置を持っていて、それらのそれぞれの位置は 独立にセットしたり読み出したりすることが可能です。</p>
<div class="original">
<p>In list context, <code>/g</code> returns a list of matched groupings,
 or if there are no groupings, a list of matches to the whole regexp. So
 if we wanted just the words, we could use</p>
</div>
<p>リストコンテキストでは、<code>/g</code> はマッチングしたグループのリストを返します; グループ化の指定がなければ、正規表現全体にマッチングするリストを返します。 ですから、単に単語が欲しいのでれば</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="lit">@words</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(\</span><span class="pln">w</span><span class="pun">+)/</span><span class="pln">g</span><span class="pun">);</span><span class="pln"> &nbsp;</span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $words[0] = 'cat'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $words[1] = 'dog'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $words[2] = 'house'</span></code></pre>
<div class="original">
<p>Closely associated with the <code>/g</code> modifier is the <code>\G</code> anchor. The <code>\G</code> anchor matches at the point where the previous <code>/g</code> match left off. <code>\G</code> allows us to easily do context-sensitive matching:</p>
</div>
<p><code>/g</code> 修飾子は\Gアンカーに強く結び付けられています。 <code>\G</code> アンカーは直前の <code>/g</code> マッチングで残った部分にマッチングします。 <code>\G</code> はコンテキストを考慮したマッチング(context-sensitive matching)を 容易にさせます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $metric </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># use metric units</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">...</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">FILE</span><span class="pun">&gt;;</span><span class="pln"> &nbsp;</span><span class="com"># read in measurement</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^([+-]?\</span><span class="pln">d</span><span class="pun">+)\</span><span class="pln">s</span><span class="pun">*</span><span class="str">/g; &nbsp;# get magnitude<br>&nbsp; &nbsp; $weight = $1;<br>&nbsp; &nbsp; if ($metric) { # error checking<br>&nbsp; &nbsp; &nbsp; &nbsp; print "Units error!" unless $x =~ /</span><span class="pun">\</span><span class="typ">Gkg</span><span class="pun">\./</span><span class="pln">g</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; else </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Units error!"</span><span class="pln"> </span><span class="kwd">unless</span><span class="pln"> $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="typ">Glbs</span><span class="pun">\./</span><span class="pln">g</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">G</span><span class="pun">\</span><span class="pln">s</span><span class="pun">+(</span><span class="pln">widget</span><span class="pun">|</span><span class="pln">sprocket</span><span class="pun">)/</span><span class="pln">g</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># continue processing</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $metric </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># metric ユニットを使う</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">...</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">FILE</span><span class="pun">&gt;;</span><span class="pln"> &nbsp;</span><span class="com"># 測定のために読み込み</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^([+-]?\</span><span class="pln">d</span><span class="pun">+)\</span><span class="pln">s</span><span class="pun">*</span><span class="str">/g; &nbsp;# 重さを取得<br>&nbsp; &nbsp; $weight = $1;<br>&nbsp; &nbsp; if ($metric) { # エラーチェック<br>&nbsp; &nbsp; &nbsp; &nbsp; print "Units error!" unless $x =~ /</span><span class="pun">\</span><span class="typ">Gkg</span><span class="pun">\./</span><span class="pln">g</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; else </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Units error!"</span><span class="pln"> </span><span class="kwd">unless</span><span class="pln"> $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="typ">Glbs</span><span class="pun">\./</span><span class="pln">g</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">G</span><span class="pun">\</span><span class="pln">s</span><span class="pun">+(</span><span class="pln">widget</span><span class="pun">|</span><span class="pln">sprocket</span><span class="pun">)/</span><span class="pln">g</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># 処理を続ける</span></code></pre>
<div class="original">
<p>The combination of <code>/g</code> and <code>\G</code> allows us to process the string a bit at a time and use arbitrary Perl logic to decide what to do next. Currently, the <code>\G</code> anchor is only fully supported when used to anchor to the start of the pattern.</p>
</div>
<p><code>/g</code> と <code>\G</code> の組み合わせは一度に文字列を少しだけ処理して、次に 行うことを決定するために任意の Perl のロジックを使うことを可能にします。 現在のところ、<code>\G</code> アンカーはパターンの最初に使われたときのみ 完全にサポートされます。</p>
<div class="original">
<p><code>\G</code> is also invaluable in processing fixed-length records
 with regexps. Suppose we have a snippet of coding region DNA, encoded 
as base pair letters <code>ATCGTTGAAT...</code> and we want to find all the stop codons <code>TGA</code>.
 In a coding region, codons are 3-letter sequences, so we can think of 
the DNA snippet as a sequence of 3-letter records. The naive regexp</p>
</div>
<p><code>\G</code> はまた、正規表現を使って固定長のレコードを処理するときに貴重なものです。 基礎となる組み合わせ文字でエンコードされた <code>ATCGTTGAAT...</code>
 のような DNA の符号化部分があるとして、すべてのストップコドン (codon: 3 つの 
ヌクレオチドから成る，遺伝情報の単位)を見つけ出したいとしましょう。 符号化部分の中では、コドンは三文字の並びなので DNA の断片を 
三文字のレコードの並びとしてみなすことができます。 単純な正規表現である</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="com"># expanded, this is "ATC GTT GAA TGC AAA TGA CAT GAC"</span><span class="pln"><br>&nbsp; &nbsp; $dna </span><span class="pun">=</span><span class="pln"> </span><span class="str">"ATCGTTGAATGCAAATGACATGAC"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $dna </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">TGA</span><span class="pun">/;</span></code></pre>
<div class="original">
<p>doesn't work; it may match a <code>TGA</code>, but there is no guarantee that the match is aligned with codon boundaries, <i>e.g.</i>, the substring <span style="white-space: nowrap;"><code>GTT GAA</code></span> gives a match. A better solution is</p>
</div>
<p>はうまくいきません; これは <code>TGA</code> にマッチングはしますが、 <span style="white-space: nowrap;"><code>GTT GAA</code></span> のようにコドンの境界にないものにもマッチングしてしまいます。 より良い解決策は以下のようなものです</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$dna </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(\</span><span class="pln">w</span><span class="pun">\</span><span class="pln">w</span><span class="pun">\</span><span class="pln">w</span><span class="pun">)*?</span><span class="pln">TGA</span><span class="pun">/</span><span class="pln">g</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> &nbsp;</span><span class="com"># note the minimal *?</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Got a TGA stop codon at position "</span><span class="pun">,</span><span class="pln"> pos $dna</span><span class="pun">,</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>which prints</p>
</div>
<p>これは以下を出力します</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="typ">Got</span><span class="pln"> a TGA stop codon at position </span><span class="lit">18</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Got</span><span class="pln"> a TGA stop codon at position </span><span class="lit">23</span></code></pre>
<div class="original">
<p>Position 18 is good, but position 23 is bogus. What happened?</p>
</div>
<p>Position 18 は良いですが、23 は変です。 何が起きているのでしょう?</p>
<div class="original">
<p>The answer is that our regexp works well until we get past the last 
real match. Then the regexp will fail to match a synchronized <code>TGA</code> and start stepping ahead one character position at a time, not what we want. The solution is to use <code>\G</code> to anchor the match to the codon alignment:</p>
</div>
<p>その答えは、私たちの正規表現が最後に本当にマッチングしたところまでは うまくいっているからです。 それからこの正規表現は <code>TGA</code> の同期に失敗して私たちが望んでいない場所から マッチングのステップを始めてしまうのです。 解決策は、コドンの境界にマッチングさせるために <code>\G</code> を 使って印付けをすることです:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$dna </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">G</span><span class="pun">(\</span><span class="pln">w</span><span class="pun">\</span><span class="pln">w</span><span class="pun">\</span><span class="pln">w</span><span class="pun">)*?</span><span class="pln">TGA</span><span class="pun">/</span><span class="pln">g</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Got a TGA stop codon at position "</span><span class="pun">,</span><span class="pln"> pos $dna</span><span class="pun">,</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>This prints</p>
</div>
<p>これは</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="typ">Got</span><span class="pln"> a TGA stop codon at position </span><span class="lit">18</span></code></pre>
<div class="original">
<p>which is the correct answer. This example illustrates that it is 
important not only to match what is desired, but to reject what is not 
desired.</p>
</div>
<p>を出力し、そして正しい答えです。 この例はマッチングしたものにマッチングすることだけが重要なのではなく、 望んでいないものを排除することもまたそうなのだということを 明らかにしました。</p>
<div class="original">
<p>(There are other regexp modifiers that are available, such as <code>/o</code>, but their specialized uses are beyond the scope of this introduction. )</p>
</div>
<p>(<code>/o</code> のようなその他の正規表現修飾子も利用可能ですが、これらの特殊な 使用法はこの序論のスコープからは外れます。)</p>
<h3 id="Search32and32replace">検索と置換<a href="#Search32and32replace" class="toc_link">¶</a></h3>
<p></p>
<div class="original">
<p>Regular expressions also play a big role in <i>search and replace</i> operations in Perl. Search and replace is accomplished with the <code>s///</code> operator. The general form is <code>s/regexp/replacement/modifiers</code>, with everything we know about regexps and modifiers applying in this case as well. The <i>replacement</i> is a Perl double-quoted string that replaces in the string whatever is matched with the <code>regexp</code>. The operator <code>=~</code> is also used here to associate a string with <code>s///</code>. If matching against <code>$_</code>, the <span style="white-space: nowrap;"><code>$_ =~</code></span> can be dropped. If there is a match, <code>s///</code> returns the number of substitutions made; otherwise it returns false. Here are a few examples:</p>
</div>
<p>正規表現はまた、Perl における検索と置換操作において大きな役割を 果たしています。 検索と置換は <code>s///</code> 演算子に結び付けられています。 一般的な形は <code>s/regexp/replacement/modifiers</code> で、知っているすべての 正規表現と修飾子をここで使うことができます。 <i>replacement</i> は Perlでのダブルクォートで囲まれた文字列で、 <code>regexp</code> にマッチングした文字列を置き換えるものです。 <code>=~</code> 演算子もまた <code>s///</code> を伴った文字列に結びつけられるために使われます。 <code>$_</code> に対してマッチングを行う場合には、<span style="white-space: nowrap;"><code>$_ =~</code></span> は省略できます。 マッチングに成功した場合には <code>s///</code> は置換が行われた数を返します; 失敗した場合には偽を返します。 幾つか例を挙げましょう:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Time to feed the cat!"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/</span><span class="pln">cat</span><span class="pun">/</span><span class="pln">hacker</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># $x contains "Time to feed the hacker!"</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/^(</span><span class="typ">Time</span><span class="pun">.*</span><span class="pln">hacker</span><span class="pun">)!</span><span class="pln">$</span><span class="pun">/</span><span class="pln">$1 now</span><span class="pun">!</span><span class="str">/) {<br>&nbsp; &nbsp; &nbsp; &nbsp; $more_insistent = 1;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; $y = "'quoted words'";<br>&nbsp; &nbsp; $y =~ s/</span><span class="pun">^</span><span class="str">'(.*)'</span><span class="pln">$</span><span class="pun">/</span><span class="pln">$1</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># strip single quotes,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $y contains "quoted words"</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Time to feed the cat!"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/</span><span class="pln">cat</span><span class="pun">/</span><span class="pln">hacker</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># $x の内容は "Time to feed the hacker!"</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/^(</span><span class="typ">Time</span><span class="pun">.*</span><span class="pln">hacker</span><span class="pun">)!</span><span class="pln">$</span><span class="pun">/</span><span class="pln">$1 now</span><span class="pun">!</span><span class="str">/) {<br>&nbsp; &nbsp; &nbsp; &nbsp; $more_insistent = 1;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; $y = "'quoted words'";<br>&nbsp; &nbsp; $y =~ s/</span><span class="pun">^</span><span class="str">'(.*)'</span><span class="pln">$</span><span class="pun">/</span><span class="pln">$1</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># シングルクォートを剥ぎ取る</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $y の内容は "quoted words"</span></code></pre>
<div class="original">
<p>In the last example, the whole string was matched, but only the part inside the single quotes was grouped. With the <code>s///</code> operator, the matched variables <code>$1</code>, <code>$2</code>, <i>etc</i>. are immediately available for use in the replacement expression, so we use <code>$1</code> to replace the quoted string with just what was quoted. With the global modifier, <code>s///g</code> will search and replace all occurrences of the regexp in the string:</p>
</div>
<p>最後の例では、文字列全体がマッチングしますが、シングルクォートの内部の 部分のみがグループ化されます。 <code>s///</code> 演算子では、マッチングした変数 <code>$1</code>, <code>$2</code>, などは置換式で 使えるように直ちに利用可能になるので、クォートされた文字列を中身で 置換するために <code>$1</code> を使います。 グローバル修飾子付きなので、<code>s///g</code> は文字列中の全てを検索して置換します:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"I batted 4 for 4"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/</span><span class="lit">4</span><span class="pun">/</span><span class="pln">four</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># doesn't do it all:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $x contains "I batted four for 4"</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"I batted 4 for 4"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/</span><span class="lit">4</span><span class="pun">/</span><span class="pln">four</span><span class="pun">/</span><span class="pln">g</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># does it all:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $x contains "I batted four for four"</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"I batted 4 for 4"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/</span><span class="lit">4</span><span class="pun">/</span><span class="pln">four</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># すべてにはマッチングしない:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $x の内容は "I batted four for 4"</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"I batted 4 for 4"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/</span><span class="lit">4</span><span class="pun">/</span><span class="pln">four</span><span class="pun">/</span><span class="pln">g</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># すべてにマッチング:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $x の内容は "I batted four for four"</span></code></pre>
<div class="original">
<p>If you prefer "regex" over "regexp" in this tutorial, you could use the following program to replace it:</p>
</div>
<p>このチュートリアルにある "regexp" を "regex" にすることを望むのなら、 以下のプログラムを使って置換することができます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> cat </span><span class="pun">&gt;</span><span class="pln"> simple_replace<br>&nbsp; &nbsp; </span><span class="com">#!/usr/bin/perl</span><span class="pln"><br>&nbsp; &nbsp; $regexp </span><span class="pun">=</span><span class="pln"> shift</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $replacement </span><span class="pun">=</span><span class="pln"> shift</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(&lt;&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; s</span><span class="pun">/</span><span class="pln">$regexp</span><span class="pun">/</span><span class="pln">$replacement</span><span class="pun">/</span><span class="pln">g</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">^</span><span class="pln">D<br><br>&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> simple_replace regexp regex perlretut</span><span class="pun">.</span><span class="pln">pod</span></code></pre>
<div class="original">
<p>In <code>simple_replace</code> we used the <code>s///g</code> 
modifier to replace all occurrences of the regexp on each line. (Even 
though the regular expression appears in a loop, Perl is smart enough to
 compile it only once.) As with <code>simple_grep</code>, both the <code>print</code> and the <code>s/$regexp/$replacement/g</code> use <code>$_</code> implicitly.</p>
</div>
<p><code>simple_replace</code> では各行のすべての正規表現にマッチングする部分を 置換するために <code>s///g</code> 修飾子を使います。 (正規表現がループ中にあるように見えますが、Perl はこれを一度だけ コンパイルするぐらい賢いです。) <code>simple_grep</code> と同様、<code>print</code> と <code>s/$regexp/$replacement/g</code> で <code>$_</code> を暗黙に使用しています。</p>
<div class="original">
<p>If you don't want <code>s///</code> to change your original variable you can use the non-destructive substitute modifier, <code>s///r</code>. This changes the behavior so that <code>s///r</code> returns the final substituted string (instead of the number of substitutions):</p>
</div>
<p>基の変数を変更するために <code>s///</code> を使いたくないなら、非破壊置換修飾子である <code>s///r</code> が使えます。 これは、<code>s///r</code> が (置換の数ではなく)最終的に置換された文字列を返すように 振る舞いを変更します:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"I like dogs."</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $y </span><span class="pun">=</span><span class="pln"> $x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/</span><span class="pln">dogs</span><span class="pun">/</span><span class="pln">cats</span><span class="pun">/</span><span class="pln">r</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"$x $y\n"</span><span class="pun">;</span></code></pre>
<div class="original">
<p>That example will print "I like dogs. I like cats". Notice the original <code>$x</code> variable has not been affected. The overall result of the substitution is instead stored in <code>$y</code>. If the substitution doesn't affect anything then the original string is returned:</p>
</div>
<p>この例は、"I like dogs. I like cats" を表示します。 元の <code>$x</code> 変数は影響を受けないことに注意してください。 置換の結果全体は代わりに <code>$y</code> に格納されます。 置換が何も影響を与えなかった場合、元の文字列が返されます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"I like dogs."</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $y </span><span class="pun">=</span><span class="pln"> $x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/</span><span class="pln">elephants</span><span class="pun">/</span><span class="pln">cougars</span><span class="pun">/</span><span class="pln">r</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"$x $y\n"</span><span class="pun">;</span><span class="pln"> </span><span class="com"># prints "I like dogs. I like dogs."</span></code></pre>
<div class="original">
<p>One other interesting thing that the <code>s///r</code> flag allows is chaining substitutions:</p>
</div>
<p><code>s///r</code> フラグによるもう一つの興味深いことは、置換の連鎖です:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Cats are great."</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> $x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/</span><span class="typ">Cats</span><span class="pun">/</span><span class="typ">Dogs</span><span class="pun">/</span><span class="pln">r </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/</span><span class="typ">Dogs</span><span class="pun">/</span><span class="typ">Frogs</span><span class="pun">/</span><span class="pln">r </span><span class="pun">=~</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; s</span><span class="pun">/</span><span class="typ">Frogs</span><span class="pun">/</span><span class="typ">Hedgehogs</span><span class="pun">/</span><span class="pln">r</span><span class="pun">,</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="com"># prints "Hedgehogs are great."</span></code></pre>
<div class="original">
<p>A modifier available specifically to search and replace is the <code>s///e</code> evaluation modifier. <code>s///e</code>
 treats the replacement text as Perl code, rather than a double-quoted 
string. The value that the code returns is substituted for the matched 
substring. <code>s///e</code> is useful if you need to do a bit of 
computation in the process of replacing text. This example counts 
character frequencies in a line:</p>
</div>
<p>検索と置換において使うことのできる修飾子に評価修飾子 <code>s///e</code> があります。 <code>s///e</code> は、置換文字列をダブルクォートされた文字列ではなく Perl コードとして扱います。 コードが返した値はマッチングした部分文字列と置換されます。 <code>s///e</code> は置換テキストの処理においてちょっとした計算を行う必要が あるときに便利です。 以下の例はある行の文字の出現頻度を数えます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Bill the cat"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/(.)/</span><span class="pln">$chars</span><span class="pun">{</span><span class="pln">$1</span><span class="pun">}++;</span><span class="pln">$1</span><span class="pun">/</span><span class="pln">eg</span><span class="pun">;</span><span class="pln"> </span><span class="com"># final $1 replaces char with itself</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"frequency of '$_' is $chars{$_}\n"</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sort </span><span class="pun">{</span><span class="pln">$chars</span><span class="pun">{</span><span class="pln">$b</span><span class="pun">}</span><span class="pln"> </span><span class="pun">&lt;=&gt;</span><span class="pln"> $chars</span><span class="pun">{</span><span class="pln">$a</span><span class="pun">}}</span><span class="pln"> keys </span><span class="pun">%</span><span class="pln">chars</span><span class="pun">);</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Bill the cat"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/(.)/</span><span class="pln">$chars</span><span class="pun">{</span><span class="pln">$1</span><span class="pun">}++;</span><span class="pln">$1</span><span class="pun">/</span><span class="pln">eg</span><span class="pun">;</span><span class="pln"> </span><span class="com"># 最終的に $1 はそれ自身の文字に置換される</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"frequency of '$_' is $chars{$_}\n"</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sort </span><span class="pun">{</span><span class="pln">$chars</span><span class="pun">{</span><span class="pln">$b</span><span class="pun">}</span><span class="pln"> </span><span class="pun">&lt;=&gt;</span><span class="pln"> $chars</span><span class="pun">{</span><span class="pln">$a</span><span class="pun">}}</span><span class="pln"> keys </span><span class="pun">%</span><span class="pln">chars</span><span class="pun">);</span></code></pre>
<div class="original">
<p>This prints</p>
</div>
<p>これは</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; frequency of </span><span class="str">' '</span><span class="pln"> is </span><span class="lit">2</span><span class="pln"><br>&nbsp; &nbsp; frequency of </span><span class="str">'t'</span><span class="pln"> is </span><span class="lit">2</span><span class="pln"><br>&nbsp; &nbsp; frequency of </span><span class="str">'l'</span><span class="pln"> is </span><span class="lit">2</span><span class="pln"><br>&nbsp; &nbsp; frequency of </span><span class="str">'B'</span><span class="pln"> is </span><span class="lit">1</span><span class="pln"><br>&nbsp; &nbsp; frequency of </span><span class="str">'c'</span><span class="pln"> is </span><span class="lit">1</span><span class="pln"><br>&nbsp; &nbsp; frequency of </span><span class="str">'e'</span><span class="pln"> is </span><span class="lit">1</span><span class="pln"><br>&nbsp; &nbsp; frequency of </span><span class="str">'h'</span><span class="pln"> is </span><span class="lit">1</span><span class="pln"><br>&nbsp; &nbsp; frequency of </span><span class="str">'i'</span><span class="pln"> is </span><span class="lit">1</span><span class="pln"><br>&nbsp; &nbsp; frequency of </span><span class="str">'a'</span><span class="pln"> is </span><span class="lit">1</span></code></pre>
<div class="original">
<p>As with the match <code>m//</code> operator, <code>s///</code> can use other delimiters, such as <code>s!!!</code> and <code>s{}{}</code>, and even <code>s{}//</code>. If single quotes are used <code>s'''</code>, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. <code>s///</code> in list context returns the same thing as in scalar context, <i>i.e.</i>, the number of matches.</p>
</div>
<p><code>m//</code> 演算子と同様に、<code>s///</code> も <code>s!!!</code> や <code>s{}{}</code> 、 果ては <code>s{}//</code> のように異なるデリミタを使うことができます。 <code>s'''</code> のようにシングルクォートが使われた場合、その正規表現と 置換テキストはシングルクォート文字列のように扱われ、変数の置き換えは 行われません。 リストコンテキストでの <code>s///</code> はスカラコンテキストのときと同じように、 マッチングした数を返します。</p>
<h3 id="The32split32function">split 関数<a href="#The32split32function" class="toc_link">¶</a></h3>
<p></p>
<div class="original">
<p>The <code>split()</code> function is another place where a regexp is used. <code>split /regexp/, string, limit</code> separates the <code>string</code>
 operand into a list of substrings and returns that list. The regexp 
must be designed to match whatever constitutes the separators for the 
desired substrings. The <code>limit</code>, if present, constrains splitting into no more than <code>limit</code> number of strings. For example, to split a string into words, use</p>
</div>
<p><code>split()</code> 関数は、正規表現が使えるもう一つの場所です。 <code>split /regexp/, string, limit</code> は <code>string</code> オペランドを部分文字列の リストに分割し、そのリストを返します。 正規表現は、目的の部分文字列のセパレータを構成するものに マッチングするようにしなければなりません。 <code>limit</code> が与えられた場合には、文字列を <code>limit</code> 個を超える数には 分割しません。 たとえば、文字列を単語に分割するには以下のようにします</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Calvin and Hobbes"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="lit">@words</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> split </span><span class="pun">/\</span><span class="pln">s</span><span class="pun">+/,</span><span class="pln"> $x</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># $word[0] = 'Calvin'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $word[1] = 'and'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># $word[2] = 'Hobbes'</span></code></pre>
<div class="original">
<p>If the empty regexp <code>//</code> is used, the regexp always 
matches and the string is split into individual characters. If the 
regexp has groupings, then the resulting list contains the matched 
substrings from the groupings as well. For instance,</p>
</div>
<p><code>//</code> が使われた場合には、その正規表現は常にマッチングし、文字列は個々の文字に 分割されます。 正規表現がグループ化を伴っていた場合には、グループ化されたものも部分文字列に 含まれるようになります。 例を挙げると以下のようになります</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"/usr/bin/perl"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="lit">@dirs</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> split m</span><span class="pun">!</span><span class="str">/!, $x; &nbsp;# $dirs[0] = ''<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# $dirs[1] = 'usr'<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# $dirs[2] = 'bin'<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# $dirs[3] = 'perl'<br>&nbsp; &nbsp; @parts = split m!(/</span><span class="pun">)!,</span><span class="pln"> $x</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># $parts[0] = ''</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $parts[1] = '/'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $parts[2] = 'usr'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $parts[3] = '/'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $parts[4] = 'bin'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $parts[5] = '/'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># $parts[6] = 'perl'</span></code></pre>
<div class="original">
<p>Since the first character of <code>$x</code> matched the regexp, <code>split</code> prepended an empty initial element to the list.</p>
</div>
<p><code>$x</code> の最初の文字に正規表現がマッチングしているので、<code>split</code> はリストの 最初の要素に空要素を置きます。</p>
<div class="original">
<p>If you have read this far, congratulations! You now have all the 
basic tools needed to use regular expressions to solve a wide range of 
text processing problems. If this is your first time through the 
tutorial, why not stop here and play around with regexps a while.... <span style="white-space: nowrap;">Part 2</span> concerns the more esoteric aspects of regular expressions and those concepts certainly aren't needed right at the start.</p>
</div>
<p>ここまで読み進めてきたのならおめでとう! あなたは広範囲のテキスト処理を解決するのに必要な正規表現の基本的な部分を すべて会得しました。 このチュートリアルを初めて読んでここまできたのなら、ここで立ち止まって 正規表現を使ってみるのも良いでしょう。 <span style="white-space: nowrap;">Part 2</span> ではより難解な正規表現の側面に言及します。</p>
<h1 id="Part322:32Power32tools">パート 2: 強力なツール<a href="#Part322:32Power32tools" class="toc_link">¶</a></h1>
<p></p>
<div class="original">
<p>OK, you know the basics of regexps and you want to know more. If 
matching regular expressions is analogous to a walk in the woods, then 
the tools discussed in Part 1 are analogous to topo maps and a compass, 
basic tools we use all the time. Most of the tools in part 2 are 
analogous to flare guns and satellite phones. They aren't used too often
 on a hike, but when we are stuck, they can be invaluable.</p>
</div>
<p>あなたはすでに正規表現の基本的なことを知っていて、より深く 知ろうとしています。 
正規表現のマッチングが森の中を歩くことに類似しているのなら、パート 1 で 
述べられたツールは地図でありコンパスであり、いつも使う基本的な道具です。 パート 2 での大部分のツールは照明弾であり、衛星電話です。 
ハイキングにはそうそう使うものではありませんが、困り果てたときには とても貴重なものです。</p>
<div class="original">
<p>What follows are the more advanced, less used, or sometimes esoteric 
capabilities of Perl regexps. In Part 2, we will assume you are 
comfortable with the basics and concentrate on the advanced features.</p>
</div>
<p>以下に挙げるものは Perl の正規表現においてより高度で、 あまり使うことのない、時として難解な機能です。 Part 2 では、あなたが基本を良く知っていてより進んだ機能に集中できることを 仮定しています。</p>
<h2 id="More32on32characters44-32strings44-32and32character32classes">文字、文字列、文字クラスについての追加事項<a href="#More32on32characters44-32strings44-32and32character32classes" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>There are a number of escape sequences and character classes that we haven't covered yet.</p>
</div>
<p>まだカバーしていない幾つかのエスケープシーケンスや文字クラスがあります。</p>
<div class="original">
<p>There are several escape sequences that convert characters or strings
 between upper and lower case, and they are also available within 
patterns. <code>\l</code> and <code>\u</code> convert the next character to lower or upper case, respectively:</p>
</div>
<p>文字や文字列の大小文字を変換するエスケープシーケンスがあり、 これらもパターンで使えます。 <code>\l</code> や <code>\u</code> は続く文字をそれぞれ小文字と大文字に変換します:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"perl"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $string </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">u$x</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches 'Perl' in $string</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"M(rs?|s)\\."</span><span class="pun">;</span><span class="pln"> </span><span class="com"># note the double backslash</span><span class="pln"><br>&nbsp; &nbsp; $string </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">l$x</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches 'mr.', 'mrs.', and 'ms.',</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"perl"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $string </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">u$x</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># $string の中の 'Perl' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"M(rs?|s)\\."</span><span class="pun">;</span><span class="pln"> </span><span class="com"># 二重のバックスラッシュに注意</span><span class="pln"><br>&nbsp; &nbsp; $string </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">l$x</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 'mr.', 'mrs.', 'ms.' にマッチング</span></code></pre>
<div class="original">
<p>A <code>\L</code> or <code>\U</code> indicates a lasting conversion of case, until terminated by <code>\E</code> or thrown over by another <code>\U</code> or <code>\L</code>:</p>
</div>
<p><code>\L</code> や <code>\U</code> は、<code>\E</code> で終端されるか、別の <code>\U</code> や <code>\L</code> で 上書きされるまで、大文字小文字を変換することを示します:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"This word is in lower case:\L SHOUT\E"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">shout</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># matches</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"I STILL KEYPUNCH CARDS FOR MY 360"</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="typ">Ukeypunch</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches punch card string</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"This word is in lower case:\L SHOUT\E"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">shout</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"I STILL KEYPUNCH CARDS FOR MY 360"</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="typ">Ukeypunch</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># パンチカード文字列にマッチングする</span></code></pre>
<div class="original">
<p>If there is no <code>\E</code>, case is converted until the end of the string. The regexps <code>\L\u$word</code> or <code>\u\L$word</code> convert the first character of <code>$word</code> to uppercase and the rest of the characters to lowercase.</p>
</div>
<p><code>\E</code> がない場合には、大小文字の変換は文字列の終端まで行われます。 <code>\L\u$word</code> や <code>\u\L$word</code> は <code>$word</code> の最初の文字を大文字へと変換し、 残りの文字は小文字にします。</p>
<div class="original">
<p>Control characters can be escaped with <code>\c</code>, so that a control-Z character would be matched with <code>\cZ</code>. The escape sequence <code>\Q</code>...<code>\E</code> quotes, or protects most non-alphabetic characters. For instance,</p>
</div>
<p>制御文字は <code>\c</code> を使ってエスケープすることができます; ですから、 control-Z 文字は <code>\cZ</code> にマッチングします。 <code>\Q</code>...<code>\E</code> というエスケープシーケンスは大部分の非アルファベット文字を クォートまたはプロテクトします。 たとえば</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"\QThat !^*&amp;%~&amp; cat!"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">Q</span><span class="pun">!^*&amp;%~&amp;\</span><span class="pln">E</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># check for rough language</span></code></pre>
<div class="original">
<p>It does not protect <code>'$'</code> or <code>'@'</code>, so that variables can still be substituted.</p>
</div>
<p>これは <code>'$'</code> や <code>'@'</code> を保護しないので、変数の置換は行われます。</p>
<div class="original">
<p><code>\Q</code>, <code>\L</code>, <code>\l</code>, <code>\U</code>, <code>\u</code> and <code>\E</code>
 are actually part of double-quotish syntax, and not part of regexp 
syntax proper. They will work if they appear in a regular expression 
embedded directly in a program, but not when contained in a string that 
is interpolated in a pattern.</p>
</div>
<p><code>\Q</code>, <code>\L</code>, <code>\l</code>, <code>\U</code>, <code>\u</code>, <code>\E</code> は実際にはダブルクォート風文法の 一部で、正規表現文法の一部ではありません。 これらはプログラム中の正規表現に直接埋め込まれている場合は動作しますが、 パターン内で展開された文字列に含まれている場合には動作しません。</p>
<div class="original">
<p>Perl regexps can handle more than just the standard ASCII character set. Perl supports <i>Unicode</i>,
 a standard for representing the alphabets from virtually all of the 
world's written languages, and a host of symbols. Perl's text strings 
are Unicode strings, so they can contain characters with a value 
(codepoint or character number) higher than 255.</p>
</div>
<p>Perl の正規表現は標準の ASCII 文字セットを超えた扱いをすることができます。 Perl は現在は事実上世界の全ての言語のアルファベットを表現する標準である <i>Unicode</i> をサポートしています。 Perl のテキスト文字列は Unicode 文字列で、255 以上の値(コードポイントまたは 文字番号)を持つ文字を含みます。</p>
<div class="original">
<p>What does this mean for regexps? Well, regexp users don't need to 
know much about Perl's internal representation of strings. But they do 
need to know 1) how to represent Unicode characters in a regexp and 2) 
that a matching operation will treat the string to be searched as a 
sequence of characters, not bytes. The answer to 1) is that Unicode 
characters greater than <code>chr(255)</code> are represented using the <code>\x{hex}</code> notation, because <code>\x</code><i>XY</i> (without curly braces and <i>XY</i> are two hex digits) doesn't go further than 255. (Starting in Perl 5.14, if you're an octal fan, you can also use <code>\o{oct}</code>.)</p>
</div>
<p>このことが正規表現に及ぼす影響は? そう、正規表現ユーザーは perl での文字列の内部表現を知る必要はありません。 
しかし、知っておくべきことがあります; 1) 正規表現において Unicode 文字をどのように表現するか 2) 
マッチング操作がバイト列ではなく、Unicode 文字列として扱うということです。 1)に対する答えは <code>chr(255)</code> を越える Unicode 文字は <code>\x{hex}</code> 表記を 使って表現されるだろうということです; なぜなら、<code>\x</code><i>XY</i> 表記(中かっこなしで <i>XY</i> は二つの 16 進数) は 255 を 超えないからです。 (Perl 5.14 から、8 進数が好みなら、<code>\o{oct}</code> も使えます。)</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/\</span><span class="pln">x</span><span class="pun">{</span><span class="lit">263a</span><span class="pun">}/;</span><span class="pln"> &nbsp;</span><span class="com"># match a Unicode smiley face :)</span></code></pre>
<div class="original">
<p><b>NOTE</b>: In Perl 5.6.0 it used to be that one needed to say <code>use utf8</code> to use any Unicode features. This is no more the case: for almost all Unicode processing, the explicit <code>utf8</code>
 pragma is not needed. (The only case where it matters is if your Perl 
script is in Unicode and encoded in UTF-8, then an explicit <code>use utf8</code> is needed.)</p>
</div>
<p><b>注意</b>: Perl 5.6.0 では何かしらの Unicode 機構を使うときには <code>use utf8</code> を 宣言する必要がありました。 これは現在ではあてはまりません: ほとんどすべての Unicode 処理においては、 <code>utf8</code> プラグマは必要ありません。 (これが意味を持つただ一つのケースは、 あなたの Perl スクリプトが Unicode で書かれていて、かつそれが UTF-8 で エンコーディングされている場合で、このときは陽に <code>use utf8</code> を指定する必要があります。)</p>
<div class="original">
<p>Figuring out the hexadecimal sequence of a Unicode character you want
 or deciphering someone else's hexadecimal Unicode regexp is about as 
much fun as programming in machine code. So another way to specify 
Unicode characters is to use the <i>named character</i> escape sequence <code>\N{<i>name</i>}</code>. <i>name</i>
 is a name for the Unicode character, as specified in the Unicode 
standard. For instance, if we wanted to represent or match the 
astrological sign for the planet Mercury, we could use</p>
</div>
<p>あなたが必要な Unicode 文字を 16 進数で表記することや、別の誰かが 16 進表記の Unicode 正規表現を解読することは、機械語で プログラミングすることを楽しむかのようです。 ですから、Unicode 文字を指定する別の方法として <code>\N{<i>name</i>}</code> のような <i>名前付き文字</i> エスケープシーケンスを使うものがあります。 <code>name</code> は Unicode 文字に対する名前であって、Unicode standard で 定義されているものです。 たとえば、水星を表す占星術記号を表したりマッチングさせるために 以下のようにします</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"abc\N{MERCURY}def"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">N</span><span class="pun">{</span><span class="pln">MERCURY</span><span class="pun">}/;</span><span class="pln"> &nbsp; </span><span class="com"># matches</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"abc\N{MERCURY}def"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\</span><span class="pln">N</span><span class="pun">{</span><span class="pln">MERCURY</span><span class="pun">}/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチング</span></code></pre>
<div class="original">
<p>One can also use "short" names:</p>
</div>
<p>「短い」名前を使うこともできます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\N{GREEK SMALL LETTER SIGMA} is called sigma.\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\N{greek:Sigma} is an upper-case sigma.\n"</span><span class="pun">;</span></code></pre>
<div class="original">
<p>You can also restrict names to a certain alphabet by specifying the <a href="https://perldoc.jp/pod/charnames">charnames</a> pragma:</p>
</div>
<p><a href="https://perldoc.jp/pod/charnames">charnames</a> プラグマを指定することで名前を特定のアルファベットに 制限することもできます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">use</span><span class="pln"> charnames qw</span><span class="pun">(</span><span class="pln">greek</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"\N{sigma} is Greek sigma\n"</span><span class="pun">;</span></code></pre>
<div class="original">
<p>An index of character names is available on-line from the Unicode Consortium, <a href="https://www.unicode.org/charts/charindex.html">http://www.unicode.org/charts/charindex.html</a>; explanatory material with links to other resources at <a href="https://www.unicode.org/standard/where">http://www.unicode.org/standard/where</a>.</p>
</div>
<p>文字名の一覧は Unicode Consortium の <a href="https://www.unicode.org/charts/charindex.html">http://www.unicode.org/charts/charindex.html</a> からオンラインで 利用可能です; その他のリソースへのリンクを含む説明に関する情報は <a href="https://www.unicode.org/standard/where">http://www.unicode.org/standard/where</a> にあります。</p>
<div class="original">
<p>The answer to requirement 2) is that a regexp (mostly) uses Unicode 
characters. The "mostly" is for messy backward compatibility reasons, 
but starting in Perl 5.14, any regexp compiled in the scope of a <code>use feature 'unicode_strings'</code> (which is automatically turned on within the scope of a <code>use 5.012</code> or higher) will turn that "mostly" into "always". If you want to handle Unicode properly, you should ensure that <code>'unicode_strings'</code>
 is turned on. Internally, this is encoded to bytes using either UTF-8 
or a native 8 bit encoding, depending on the history of the string, but 
conceptually it is a sequence of characters, not bytes. See <a href="https://perldoc.jp/pod/perlunitut">perlunitut</a> for a tutorial about that.</p>
</div>
<p>2) の答えは、正規表現は(ほとんど) Unicode 文字を使うというものです。 「ほとんど」というのはぐちゃぐちゃな後方互換性の理由ですが、 Perl 5.14 から、<code>use feature 'unicode_strings'</code> (これは <code>use 5.012</code> 以上が 有効なスコープ内では自動的にオンになります) によって「ほとんど」は「常に」に なります。 Unicode を適切に扱いたいなら、<code>'unicode_strings'</code>
 をオンに するようにするべきです。 内部では、これは UTF-8 かネイティブな 8 ビットエンコーディングを使った 
バイトでエンコードされてます; どちらかは文字列の履歴に依存します; しかし理論的には、これはバイトの列ではなく文字の列です。 
これに関するチュートリアルについては <a href="https://perldoc.jp/pod/perlunitut">perlunitut</a> を参照してください。</p>
<div class="original">
<p>Let us now discuss Unicode character classes, most usually called "character properties". These are represented by the <code>\p{<i>name</i>}</code> escape sequence. The negation of this is <code>\P{<i>name</i>}</code>. For example, to match lower and uppercase characters,</p>
</div>
<p>ほとんどの場合「文字特性」と呼ばれる、Unicode 文字クラスについて述べましょう。 これらは <code>\p{<i>name</i>}</code> エスケープシーケンスで表されます。 この否定は <code>\P{<i>name</i>}</code> です。 たとえば小文字や大文字の文字にマッチングさせるには、</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"BOB"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">p</span><span class="pun">{</span><span class="typ">IsUpper</span><span class="pun">}/;</span><span class="pln"> &nbsp; </span><span class="com"># matches, uppercase char class</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">P</span><span class="pun">{</span><span class="typ">IsUpper</span><span class="pun">}/;</span><span class="pln"> &nbsp; </span><span class="com"># doesn't match, char class sans uppercase</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">p</span><span class="pun">{</span><span class="typ">IsLower</span><span class="pun">}/;</span><span class="pln"> &nbsp; </span><span class="com"># doesn't match, lowercase char class</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">P</span><span class="pun">{</span><span class="typ">IsLower</span><span class="pun">}/;</span><span class="pln"> &nbsp; </span><span class="com"># matches, char class sans lowercase</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"BOB"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">p</span><span class="pun">{</span><span class="typ">IsUpper</span><span class="pun">}/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする; 大文字の文字クラス</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">P</span><span class="pun">{</span><span class="typ">IsUpper</span><span class="pun">}/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングしない; 文字クラスは大文字以外</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">p</span><span class="pun">{</span><span class="typ">IsLower</span><span class="pun">}/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングしない; 小文字の文字クラス</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^\</span><span class="pln">P</span><span class="pun">{</span><span class="typ">IsLower</span><span class="pun">}/;</span><span class="pln"> &nbsp; </span><span class="com"># マッチングする; 文字クラスは小文字以外</span></code></pre>
<div class="original">
<p>(The "<code>Is</code>" is optional.)</p>
</div>
<p>("<code>Is</code>" はオプションです。)</p>
<div class="original">
<p>There are many, many Unicode character properties. For the full list see <a href="https://perldoc.jp/pod/perluniprops">perluniprops</a>.
 Most of them have synonyms with shorter names, also listed there. Some 
synonyms are a single character. For these, you can drop the braces. For
 instance, <code>\pM</code> is the same thing as <code>\p{Mark}</code>, meaning things like accent marks.</p>
</div>
<p>Unicode 文字特性はとてもとてもたくさんあります。 完全な一覧については <a href="https://perldoc.jp/pod/perluniprops">perluniprops</a> を参照してください。 これらのほとんどはより短い名前の同義語で、これらも一覧されています。 一文字の同義語もあります。 これらについては、中かっこを省略できます。 例えば、<code>\pM</code> は <code>\p{Mark}</code> と同じことで、アクセント記号のようなものを 意味します。</p>
<div class="original">
<p>The Unicode <code>\p{Script}</code> and <code>\p{Script_Extensions}</code> properties are used to categorize every Unicode character into the language script it is written in. (<code>Script_Extensions</code> is an improved version of <code>Script</code>, which is retained for backward compatibility, and so you should generally use <code>Script_Extensions</code>.)
 For example, English, French, and a bunch of other European languages 
are written in the Latin script. But there is also the Greek script, the
 Thai script, the Katakana script, <i>etc</i>. You can test whether a character is in a particular script (based on <code>Script_Extensions</code>) with, for example <code>\p{Latin}</code>, <code>\p{Greek}</code>, or <code>\p{Katakana}</code>. To test if it isn't in the Balinese script, you would use <code>\P{Balinese}</code>.</p>
</div>
<p>Unicode の <code>\p{Script}</code> と <code>\p{Script_Extensions}</code> 特性は、全ての Unicode 文字を、それが書かれる言語用字に分類します。 (<code>Script_Extensions</code> は <code>Script</code> の改良版で、後方互換性を持っているので、 一般的に <code>Script_Extensions</code> を使うべきです。) 例えば、英語、フランス語、および多くのその他のヨーロッパ言語は ラテン用字で書かれます。 しかし、ギリシャ用字、タイ用字、カタカナ用字などもあります。 ある文字が (<code>Script_Extensions</code> を基として)特定の用字に含まれるかを、 例えば <code>\p{Latin}</code>, <code>\p{Greek}</code>, <code>\p{Katakana}</code> のようにしてテスト出来ます。 バリ用字に含まれないかどうかをテストするには、<code>\P{Balinese}</code> として使います。</p>
<div class="original">
<p>What we have described so far is the single form of the <code>\p{...}</code> character classes. There is also a compound form which you may run into. These look like <code>\p{<i>name</i>=<i>value</i>}</code> or <code>\p{<i>name</i>:<i>value</i>}</code>
 (the equals sign and colon can be used interchangeably). These are more
 general than the single form, and in fact most of the single forms are 
just Perl-defined shortcuts for common compound forms. For example, the 
script examples in the previous paragraph could be written equivalently 
as <code>\p{Script_Extensions=Latin}</code>, <code>\p{Script_Extensions:Greek}</code>, <code>\p{script_extensions=katakana}</code>, and <code>\P{script_extensions=balinese}</code> (case is irrelevant between the <code>{}</code>
 braces). You may never have to use the compound forms, but sometimes it
 is necessary, and their use can make your code easier to understand.</p>
</div>
<p>今のところ記述してきたものは <code>\p{...}</code> 文字クラスの単一形式です。 あなたが出会うであろう複合形式もあります。 これらは <code>\p{<i>name</i>=<i>value</i>}</code> や <code>\p{<i>name</i>:<i>value</i>}</code> のような形です (等号とコロンは交換可能です)。 これらは単一形式よりより一般的で、実際ほとんどの単一形式は単に 共通複合形式の Perl 定義のショートカットです。 例えば、以前の段落でのスクリプトの例は <code>\p{Script_Extensions=Latin}</code>, <code>\p{Script_Extensions:Greek}</code>, <code>\p{script_extensions=katakana}</code>, and <code>\P{script_extensions=balinese}</code> と 等価に書けます (大文字小文字は <code>{}</code> の中では無意味です)。 複合形式を使う必要は決してありませんが、ときどき必要になり、これを使うことで コードが理解しやすくなります。</p>
<div class="original">
<p><code>\X</code> is an abbreviation for a character class that comprises a Unicode <i>extended grapheme cluster</i>.
 This represents a "logical character": what appears to be a single 
character, but may be represented internally by more than one. As an 
example, using the Unicode full names, <i>e.g.</i>, "<span style="white-space: nowrap;">A + COMBINING RING</span>" is a grapheme cluster with base character "A" and combining character "<span style="white-space: nowrap;">COMBINING RING</span>, which translates in Danish to "A" with the circle atop it, as in the word Ångstrom.</p>
</div>
<p><code>\X</code> は、Unicode の <i>拡張書記素クラスタ</i> (extended grapheme cluster) を 構成する文字クラスの並びの略記です。 これは「論理文字」を表現します: 一つの文字のように見えるけれども、内部では 複数で表現されるものです。 例えば、"<span style="white-space: nowrap;">A + COMBINING RING</span>" のような Unicode の完全な名前を使うと、 基底文字 "A" と結合文字 <span style="white-space: nowrap;">COMBINING RING</span> による書記素クラスタで、 これはデンマーク語では "A" の上に丸がついたものに変換され、オングストローム (Ångstrom)という単語で使われます。</p>
<div class="original">
<p>For the full and latest information about Unicode see the latest Unicode standard, or the Unicode Consortium's website <a href="https://www.unicode.org/">http://www.unicode.org</a></p>
</div>
<p>Unicode に関するすべての情報や最新の情報を得るには、Unicode standard の 最新のものを見るか、Unicode コンソーシアムの web サイト <a href="https://www.unicode.org/">http://www.unicode.org/</a> を参照してください。</p>
<div class="original">
<p>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form <code>[:<i>name</i>:]</code>, with <i>name</i> the name of the POSIX class. The POSIX classes are <code>alpha</code>, <code>alnum</code>, <code>ascii</code>, <code>cntrl</code>, <code>digit</code>, <code>graph</code>, <code>lower</code>, <code>print</code>, <code>punct</code>, <code>space</code>, <code>upper</code>, and <code>xdigit</code>, and two extensions, <code>word</code> (a Perl extension to match <code>\w</code>), and <code>blank</code> (a GNU extension). The <code>/a</code>
 modifier restricts these to matching just in the ASCII range; otherwise
 they can match the same as their corresponding Perl Unicode classes: <code>[:upper:]</code> is the same as <code>\p{IsUpper}</code>, <i>etc</i>. (There are some exceptions and gotchas with this; see <a href="https://perldoc.jp/pod/perlrecharclass">perlrecharclass</a> for a full discussion.) The <code>[:digit:]</code>, <code>[:word:]</code>, and <code>[:space:]</code> correspond to the familiar <code>\d</code>, <code>\w</code>, and <code>\s</code> character classes. To negate a POSIX class, put a <code>'^'</code> in front of the name, so that, <i>e.g.</i>, <code>[:^digit:]</code> corresponds to <code>\D</code> and, under Unicode, <code>\P{IsDigit}</code>. The Unicode and POSIX character classes can be used just like <code>\d</code>, with the exception that POSIX character classes can only be used inside of a character class:</p>
</div>
<p>これらのクラスでは不足と言うかのように、Perl は POSIX 形式の文字クラスも 定義します。 これらは <code>[:<i>name</i>:]</code> の形式で、<i>name</i> は POSIX クラス名です。 POSIX クラスは <code>alpha</code>, <code>alnum</code>, <code>ascii</code>, <code>cntrl</code>, <code>digit</code>, <code>graph</code>, <code>lower</code>, <code>print</code>, <code>punct</code>, <code>space</code>, <code>upper</code>, <code>xdigit</code> および二つの拡張 <code>word</code> (<code>\w</code> にマッチングする Perl 拡張), <code>blank</code> (GNU 拡張) です。 <code>/a</code> 修飾子はこれらを ASCII の範囲だけでマッチングするように制限します; さもなければ対応する Perl Unicode クラスと同じようにマッチングします: <code>[:upper:]</code> は <code>\p{IsUpper}</code> と同じ、などです。 (ここにはいくつかの例外とコツがあります; 完全な議論については <a href="https://perldoc.jp/pod/perlrecharclass">perlrecharclass</a> を参照してください。) <code>[:digit:]</code>, <code>[:word:]</code>, <code>[:space:]</code> は親しんでいる <code>\d</code>, <code>\w</code>, <code>\s</code> 文字クラスに対応します。 POSIX クラスを否定するためには名前の前に <code>'^'</code> を置きます; 従って、例えば <code>[:^digit:]</code> は <code>\D</code> に対応し、Unicode では <code>\P{IsDigit}</code> に対応します。 Unicode と POSIX の文字クラスはちょうど <code>\d</code> のように使えますが、 POSIX 文字クラスは文字クラスの中でのみ使えます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/\</span><span class="pln">s</span><span class="pun">+[</span><span class="pln">abc</span><span class="pun">[:</span><span class="pln">digit</span><span class="pun">:]</span><span class="pln">xyz</span><span class="pun">]\</span><span class="pln">s</span><span class="pun">*</span><span class="str">/; &nbsp;# match a,b,c,x,y,z, or a digit<br>&nbsp; &nbsp; /</span><span class="pun">^=</span><span class="pln">item</span><span class="pun">\</span><span class="pln">s</span><span class="pun">[[:</span><span class="pln">digit</span><span class="pun">:]]/;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># match '=item',</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># followed by a space and a digit</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/\</span><span class="pln">s</span><span class="pun">+[</span><span class="pln">abc</span><span class="pun">\</span><span class="pln">p</span><span class="pun">{</span><span class="typ">IsDigit</span><span class="pun">}</span><span class="pln">xyz</span><span class="pun">]\</span><span class="pln">s</span><span class="pun">+</span><span class="str">/; &nbsp;# match a,b,c,x,y,z, or a digit<br>&nbsp; &nbsp; /</span><span class="pun">^=</span><span class="pln">item</span><span class="pun">\</span><span class="pln">s</span><span class="pun">\</span><span class="pln">p</span><span class="pun">{</span><span class="typ">IsDigit</span><span class="pun">}/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># match '=item',</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># followed by a space and a digit</span></code></pre>
<div class="original">
<p>Whew! That is all the rest of the characters and character classes.</p>
</div>
<p>ふう! これが文字と文字クラスで残っていたこと全てです。</p>
<h2 id="Compiling32and32saving32regular32expressions">正規表現のコンパイルと保管<a href="#Compiling32and32saving32regular32expressions" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>In Part 1 we mentioned that Perl compiles a regexp into a compact 
sequence of opcodes. Thus, a compiled regexp is a data structure that 
can be stored once and used again and again. The regexp quote <code>qr//</code> does exactly that: <code>qr/string/</code> compiles the <code>string</code> as a regexp and transforms the result into a form that can be assigned to a variable:</p>
</div>
<p>パート 1 では、Perl は正規表現をコンパクトなオペコードの並びにコンパイルすると 述べました。 従って、コンパイルされた正規表現は一度だけ格納されて繰り返し使うことのできる データ構造です。 <code>qr//</code> で表される正規表現クォートは次のようなものです: <code>qr/string/</code> は <code>string</code> を正規表現としてコンパイルして結果を変数に 代入することのできる形式へと変換します:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $reg </span><span class="pun">=</span><span class="pln"> qr</span><span class="pun">/</span><span class="pln">foo</span><span class="pun">+</span><span class="pln">bar</span><span class="pun">?/;</span><span class="pln"> &nbsp;</span><span class="com"># reg contains a compiled regexp</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $reg </span><span class="pun">=</span><span class="pln"> qr</span><span class="pun">/</span><span class="pln">foo</span><span class="pun">+</span><span class="pln">bar</span><span class="pun">?/;</span><span class="pln"> &nbsp;</span><span class="com"># reg はコンパイル済み正規表現を保持する</span></code></pre>
<div class="original">
<p>Then <code>$reg</code> can be used as a regexp:</p>
</div>
<p><code>$reg</code> は正規表現として使うことができます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"fooooba"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> $reg</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># matches, just like /foo+bar?/</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$reg</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># same thing, alternate form</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"fooooba"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> $reg</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># マッチングする; /foo+bar?/ と同様</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$reg</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># 同じことを別の形式で</span></code></pre>
<div class="original">
<p><code>$reg</code> can also be interpolated into a larger regexp:</p>
</div>
<p><code>$reg</code> はより大きな正規表現の中で展開することもできます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(</span><span class="pln">abc</span><span class="pun">)?</span><span class="pln">$reg</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># still matches</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(</span><span class="pln">abc</span><span class="pun">)?</span><span class="pln">$reg</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># これもマッチングする</span></code></pre>
<div class="original">
<p>As with the matching operator, the regexp quote can use different delimiters, <i>e.g.</i>, <code>qr!!</code>, <code>qr{}</code> or <code>qr~~</code>. Apostrophes as delimiters (<code>qr''</code>) inhibit any interpolation.</p>
</div>
<p>マッチング演算子を伴ったときのように正規表現クォートは <code>qr!!</code>, <code>qr{}</code>, <code>qr~~</code> のような異なるデリミタを使うことができます。 シングルクォートを使ったデリミタ (<code>qr''</code>) は変数展開を抑止します。</p>
<div class="original">
<p>Pre-compiled regexps are useful for creating dynamic matches that 
don't need to be recompiled each time they are encountered. Using 
pre-compiled regexps, we write a <code>grep_step</code> program which greps for a sequence of patterns, advancing to the next pattern as soon as one has been satisfied.</p>
</div>
<p>コンパイル済み正規表現は、現れるたびにコンパイルする必要のない動的な マッチングを生成するのに便利です。 コンパイル済み正規表現を使って、ひとつのパターンを満足したらすぐに次の パターンに進むような、パターンの並びを grep する <code>grep_step</code> を書けます。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> cat </span><span class="pun">&gt;</span><span class="pln"> grep_step<br>&nbsp; &nbsp; </span><span class="com">#!/usr/bin/perl</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="com"># grep_step - match &lt;number&gt; regexps, one after the other</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="com"># usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2 ...</span><span class="pln"><br><br>&nbsp; &nbsp; $number </span><span class="pun">=</span><span class="pln"> shift</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $regexp</span><span class="pun">[</span><span class="pln">$_</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> shift </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="lit">0.</span><span class="pun">.</span><span class="pln">$number</span><span class="pun">-</span><span class="lit">1</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="lit">@compiled</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> map qr</span><span class="pun">/</span><span class="pln">$_</span><span class="pun">/,</span><span class="pln"> </span><span class="lit">@regexp</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$line </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$line </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$compiled</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]/)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> $line</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shift </span><span class="lit">@compiled</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">last</span><span class="pln"> </span><span class="kwd">unless</span><span class="pln"> </span><span class="lit">@compiled</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">^</span><span class="pln">D<br><br>&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> grep_step </span><span class="lit">3</span><span class="pln"> shift </span><span class="kwd">print</span><span class="pln"> </span><span class="kwd">last</span><span class="pln"> grep_step<br>&nbsp; &nbsp; $number </span><span class="pun">=</span><span class="pln"> shift</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> $line</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">last</span><span class="pln"> </span><span class="kwd">unless</span><span class="pln"> </span><span class="lit">@compiled</span><span class="pun">;</span></code></pre>
<div class="original">
<p>Storing pre-compiled regexps in an array <code>@compiled</code> allows us to simply loop through the regexps without any recompilation, thus gaining flexibility without sacrificing speed.</p>
</div>
<p>コンパイル済み正規表現を配列 <code>@compiled</code> に格納することで、 再コンパイルすることなく正規表現を使うことができ、これにより 速度を犠牲にすることなく柔軟性を手に入れることができました。</p>
<h2 id="Composing32regular32expressions32at32runtime">実行時に正規表現を構成する<a href="#Composing32regular32expressions32at32runtime" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Backtracking is more efficient than repeated tries with different 
regular expressions. If there are several regular expressions and a 
match with any of them is acceptable, then it is possible to combine 
them into a set of alternatives. If the individual expressions are input
 data, this can be done by programming a join operation. We'll exploit 
this idea in an improved version of the <code>simple_grep</code> program: a program that matches multiple patterns:</p>
</div>
<p>バックトラッキングは、異なる正規表現を繰り返し試すよりも効果的です。 もしいくつかの正規表現があって、そのどれとマッチングしてもいい場合、
 それらを選択肢の集合に結合できます。 もしこの正規表現が入力データなら、これは結合操作をプログラミングすることで 行えます。 このアイデアを <code>simple_grep</code> プログラムの拡張版 (複数のパターンにマッチングするプログラム)で利用することにします:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> cat </span><span class="pun">&gt;</span><span class="pln"> multi_grep<br>&nbsp; &nbsp; </span><span class="com">#!/usr/bin/perl</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="com"># multi_grep - match any of &lt;number&gt; regexps</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="com"># usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2 ...</span><span class="pln"><br><br>&nbsp; &nbsp; $number </span><span class="pun">=</span><span class="pln"> shift</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $regexp</span><span class="pun">[</span><span class="pln">$_</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> shift </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="lit">0.</span><span class="pun">.</span><span class="pln">$number</span><span class="pun">-</span><span class="lit">1</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; $pattern </span><span class="pun">=</span><span class="pln"> join </span><span class="str">'|'</span><span class="pun">,</span><span class="pln"> </span><span class="lit">@regexp</span><span class="pun">;</span><span class="pln"><br><br>&nbsp; &nbsp; </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$line </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> $line </span><span class="kwd">if</span><span class="pln"> $line </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$pattern</span><span class="pun">/;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">^</span><span class="pln">D<br><br>&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> multi_grep </span><span class="lit">2</span><span class="pln"> shift </span><span class="kwd">for</span><span class="pln"> multi_grep<br>&nbsp; &nbsp; $number </span><span class="pun">=</span><span class="pln"> shift</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $regexp</span><span class="pun">[</span><span class="pln">$_</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> shift </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="lit">0.</span><span class="pun">.</span><span class="pln">$number</span><span class="pun">-</span><span class="lit">1</span><span class="pun">);</span></code></pre>
<div class="original">
<p>Sometimes it is advantageous to construct a pattern from the <i>input</i>
 that is to be analyzed and use the permissible values on the left hand 
side of the matching operations. As an example for this somewhat 
paradoxical situation, let's assume that our input contains a command 
verb which should match one out of a set of available command verbs, 
with the additional twist that commands may be abbreviated as long as 
the given string is unique. The program below demonstrates the basic 
algorithm.</p>
</div>
<p>入力を検査して、マッチング操作の左側に許される値として使うために パターンを構築することには好都合な場合もあります。 
このいくらか奇妙な状況の例として、入力は与えられたコマンド動詞の集合の どれか一つにマッチングするもので、かつ、与えられた文字列がユニークで 
ある限りコマンド名を省略できる、と仮定します。 以下のプログラムは基本的なアルゴリズムを例示します。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> cat </span><span class="pun">&gt;</span><span class="pln"> keymatch<br>&nbsp; &nbsp; </span><span class="com">#!/usr/bin/perl</span><span class="pln"><br>&nbsp; &nbsp; $kwds </span><span class="pun">=</span><span class="pln"> </span><span class="str">'copy compare list print'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">while</span><span class="pun">(</span><span class="pln"> $cmd </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;&gt;</span><span class="pln"> </span><span class="pun">){</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; $cmd </span><span class="pun">=~</span><span class="pln"> s</span><span class="pun">/^\</span><span class="pln">s</span><span class="pun">+|\</span><span class="pln">s</span><span class="pun">+</span><span class="pln">$</span><span class="pun">/</span><span class="str">/g; &nbsp;# trim leading and trailing spaces<br>&nbsp; &nbsp; &nbsp; &nbsp; if( ( @matches = $kwds =~ /</span><span class="pun">\</span><span class="pln">b$cmd</span><span class="pun">\</span><span class="pln">w</span><span class="pun">*/</span><span class="pln">g </span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">){</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"command: '@matches'\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">elsif</span><span class="pun">(</span><span class="pln"> </span><span class="lit">@matches</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">){</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"no such command: '$cmd'\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"> else </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"not unique: '$cmd' (could be one of: @matches)\n"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">^</span><span class="pln">D<br><br>&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> keymatch<br>&nbsp; &nbsp; li<br>&nbsp; &nbsp; command</span><span class="pun">:</span><span class="pln"> </span><span class="str">'list'</span><span class="pln"><br>&nbsp; &nbsp; co<br>&nbsp; &nbsp; not unique</span><span class="pun">:</span><span class="pln"> </span><span class="str">'co'</span><span class="pln"> </span><span class="pun">(</span><span class="pln">could be one of</span><span class="pun">:</span><span class="pln"> copy compare</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; printer<br>&nbsp; &nbsp; </span><span class="kwd">no</span><span class="pln"> such command</span><span class="pun">:</span><span class="pln"> </span><span class="str">'printer'</span></code></pre>
<div class="original">
<p>Rather than trying to match the input against the keywords, we match 
the combined set of keywords against the input. The pattern matching 
operation <span style="white-space: nowrap;"><code>$kwds =~ /\b($cmd\w*)/g</code></span> does several things at the same time. It makes sure that the given command begins where a keyword begins (<code>\b</code>). It tolerates abbreviations due to the added <code>\w*</code>. It tells us the number of matches (<code>scalar @matches</code>) and all the keywords that were actually matched. You could hardly ask for more.</p>
</div>
<p>入力をキーワードとマッチングしようとするのではなく、キーワードの 集合を結合したものを入力とマッチングします。 パターンマッチング操作 <span style="white-space: nowrap;"><code>$kwds =~ /\b($cmd\w*)/g</code></span> は 同時に複数のことを行います。 これは与えられたコマンドがキーワードの開始位置で始まることを確認します (<code>\b</code>)。 これは <code>\w*</code> を追加することによって短縮を許容します。 これはマッチングした数 (<code>scalar @matches</code>) と、実際にマッチングした キーワードを知らせます。 これ以上聞きたいこともないでしょう。</p>
<h2 id="Embedding32comments32and32modifiers32in32a32regular32expression">正規表現にコメントや修飾子を埋め込む<a href="#Embedding32comments32and32modifiers32in32a32regular32expression" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Starting with this section, we will be discussing Perl's set of <i>extended patterns</i>.
 These are extensions to the traditional regular expression syntax that 
provide powerful new tools for pattern matching. We have already seen 
extensions in the form of the minimal matching constructs <code>??</code>, <code>*?</code>, <code>+?</code>, <code>{n,m}?</code>, and <code>{n,}?</code>. Most of the extensions below have the form <code>(?char...)</code>, where the <code>char</code> is a character that determines the type of extension.</p>
</div>
<p>このセクションのはじめで、Perl の <i>拡張パターン</i>(extended patterns)の 集合について述べると言いました。 以下に述べるのは、伝統的な正規表現構文を拡張して、パターンマッチングに おいて新しい強力なツールを提供するものです。 すでに、<code>??</code>, <code>*?</code>, <code>+?</code>, <code>{n,m}?</code>, <code>{n,}?</code> といった 最小マッチングの拡張について述べました。 後述する拡張のほとんどは <code>(?char...)</code> という形式で、<code>char</code> は 拡張の型を指定する文字です。</p>
<div class="original">
<p>The first extension is an embedded comment <code>(?#text)</code>. 
This embeds a comment into the regular expression without affecting its 
meaning. The comment should not have any closing parentheses in the 
text. An example is</p>
</div>
<p>最初の拡張はコメント <code>(?#text)</code> です。 これは正規表現に、その意味を変更することなくコメントを埋め込みます。 コメントはテキストの中で閉じカッコ以外の任意のものを持てます。 例を挙げましょう</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/(?</span><span class="com"># Match an integer:)[+-]?\d+/;</span></code></pre>
<div class="original">
<p>This style of commenting has been largely superseded by the raw, freeform commenting that is allowed with the <code>/x</code> modifier.</p>
</div>
<p>このスタイルのコメントは、<code>/x</code> 修飾子を使ったときの自由形式の コメントにとって代わられています。</p>
<div class="original">
<p>Most modifiers, such as <code>/i</code>, <code>/m</code>, <code>/s</code> and <code>/x</code> (or any combination thereof) can also be embedded in a regexp using <code>(?i)</code>, <code>(?m)</code>, <code>(?s)</code>, and <code>(?x)</code>. For instance,</p>
</div>
<p><code>/i</code>, <code>/m</code>, <code>/s</code>, <code>/x</code> のようなほとんどの修飾子(あるいはその 組み合わせ)は <code>(?i)</code>, <code>(?m)</code>, <code>(?s)</code>, <code>(?x)</code> を使って正規表現に 埋め込むこともできます。 例を挙げましょう:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/(?</span><span class="pln">i</span><span class="pun">)</span><span class="pln">yes</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># match 'yes' case insensitively</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">yes</span><span class="pun">/</span><span class="pln">i</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># same thing</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/(?</span><span class="pln">x</span><span class="pun">)(</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># freeform version of an integer regexp</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">[+-]?</span><span class="pln"> &nbsp;</span><span class="com"># match an optional sign</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># match a sequence of digits</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/(?</span><span class="pln">i</span><span class="pun">)</span><span class="pln">yes</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 大小文字の違いを無視して 'yes' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">yes</span><span class="pun">/</span><span class="pln">i</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># 同じこと</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/(?</span><span class="pln">x</span><span class="pun">)(</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># 自由形式の整数にマッチングする正規表現</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">[+-]?</span><span class="pln"> &nbsp;</span><span class="com"># 省略可能な符号</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">\</span><span class="pln">d</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># 数字の並びにマッチング</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span></code></pre>
<div class="original">
<p>Embedded modifiers can have two important advantages over the usual 
modifiers. Embedded modifiers allow a custom set of modifiers for <i>each</i> regexp pattern. This is great for matching an array of regexps that must have different modifiers:</p>
</div>
<p>埋め込み修飾子は通常の修飾子に比べて二つの利点があります。 埋め込み修飾子は正規表現のパターンの <i>それぞれに</i> 別々の修飾子を 与えることができます。 これは異なる修飾子を持った正規表現の配列にマッチングさせるのに有利です:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $pattern</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">'(?i)doctor'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $pattern</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">'Johnson'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">...</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(&lt;&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">foreach</span><span class="pln"> $patt </span><span class="pun">(</span><span class="lit">@pattern</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$patt</span><span class="pun">/;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>The second advantage is that embedded modifiers (except <code>/p</code>,
 which modifies the entire regexp) only affect the regexp inside the 
group the embedded modifier is contained in. So grouping can be used to 
localize the modifier's effects:</p>
</div>
<p>二番目の利点は、埋め込み修飾子(正規表現全体を修正する <code>/p</code> を除きます) はそれが埋め込まれたグループの中にある正規表現にだけ影響するということです。 このため、グループ化を修飾子の影響を局所化するために使うことができます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/</span><span class="typ">Answer</span><span class="pun">:</span><span class="pln"> </span><span class="pun">((?</span><span class="pln">i</span><span class="pun">)</span><span class="pln">yes</span><span class="pun">)/;</span><span class="pln"> &nbsp;</span><span class="com"># matches 'Answer: yes', 'Answer: YES', etc.</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/</span><span class="typ">Answer</span><span class="pun">:</span><span class="pln"> </span><span class="pun">((?</span><span class="pln">i</span><span class="pun">)</span><span class="pln">yes</span><span class="pun">)/;</span><span class="pln"> &nbsp;</span><span class="com"># 'Answer: yes', 'Answer: YES' などにマッチング</span></code></pre>
<div class="original">
<p>Embedded modifiers can also turn off any modifiers already present by using, <i>e.g.</i>, <code>(?-i)</code>. Modifiers can also be combined into a single expression, <i>e.g.</i>, <code>(?s-i)</code> turns on single line mode and turns off case insensitivity.</p>
</div>
<p>埋め込み修飾子は <code>(?-i)</code> のようにして任意の修飾子を無効にすることも できます。 修飾子は一つの式にまとめることもでき、たとえば <code>(?s-i)</code> は 単一行モードを有効にして大小文字の違いを無視ししないようにします。</p>
<div class="original">
<p>Embedded modifiers may also be added to a non-capturing grouping. <code>(?i-m:regexp)</code> is a non-capturing grouping that matches <code>regexp</code> case insensitively and turns off multi-line mode.</p>
</div>
<p>埋め込みの修飾子は非捕捉グループ化にも追加できます。 <code>(?i-m:regexp)</code> は <code>regexp</code> に大小文字の違いを無視してマッチングし 複数行モードをオフにする非捕捉グループ化です。</p>
<h2 id="Looking32ahead32and32looking32behind">先読みと戻り読み<a href="#Looking32ahead32and32looking32behind" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>This section concerns the lookahead and lookbehind assertions. First, a little background.</p>
</div>
<p>本セクションでは先読み(lookahead)と戻り読み(後読み: lookbehind)の 表明について述べます。 まずはじめにちょっとした背景から。</p>
<div class="original">
<p>In Perl regular expressions, most regexp elements "eat up" a certain 
amount of string when they match. For instance, the regexp element <code>[abc]</code>
 eats up one character of the string when it matches, in the sense that 
Perl moves to the next character position in the string after the match.
 There are some elements, however, that don't eat up characters (advance
 the character position) if they match. The examples we have seen so far
 are the anchors. The anchor <code>'^'</code> matches the beginning of the line, but doesn't eat any characters. Similarly, the word boundary anchor <code>\b</code> matches wherever a character matching <code>\w</code> is next to a character that doesn't, but it doesn't eat up any characters itself. Anchors are examples of <i>zero-width assertions</i>:
 zero-width, because they consume no characters, and assertions, because
 they test some property of the string. In the context of our walk in 
the woods analogy to regexp matching, most regexp elements move us along
 a trail, but anchors have us stop a moment and check our surroundings. 
If the local environment checks out, we can proceed forward. But if the 
local environment doesn't satisfy us, we must backtrack.</p>
</div>
<p>Perlの正規表現では、ほとんどの正規表現要素はそれにマッチングしたときに文字列の 一部を「食い取り」(eat up)します。 たとえば、<code>[abc]</code>
 という正規表現要素はそれにマッチングしたときに文字列の 文字一つを食い取ります; そして Perl はマッチングの後で文字列の次の位置の 
文字へと移動します。 しかしながら、マッチングしたときに文字を食い取らない(が、文字位置は進める) 要素が存在します。 
その例はアンカーとしてすでに登場しています。 <code>'^'</code> というアンカーは行の先頭にマッチングしますが文字を食い取ることはしません。 同様に語境界アンカー <code>\b</code>
 はたとえば単語を構成する文字で、次が単語を 構成する文字でない場所にマッチングしますが、文字を食い取ることはしません。 
アンカーは「ゼロ幅の表明」(zero-width assertions) の実例です: 
文字を消費しないのでゼロ幅で、文字列のなんらかの属性をテストするので 表明です。 
正規表現のマッチングを森の中での歩行にたとえた文脈で言えば、大部分の 正規表現要素は移動を伴うものであるが、アンカーは足を止めて周囲を 
確認するようなものです。 局所的な環境をチェックしたなら、進むことができます。 しかし局所的な環境が私たちを満足するものでなければ、私たちは 
後戻りしなければなりません。</p>
<div class="original">
<p>Checking the environment entails either looking ahead on the trail, looking behind, or both. <code>'^'</code> looks behind, to see that there are no characters before. <code>'$'</code> looks ahead, to see that there are no characters after. <code>\b</code> looks both ahead and behind, to see if the characters on either side differ in their "word-ness".</p>
</div>
<p>環境をチェックすることは道の上で先を見通したり、後ろを振り返ったり することです。 <code>'^'</code> は後ろを振り返って、文字が存在していないかどうかを確認します。 <code>'$'</code> は先を見て、更に文字が続いていないかどうかを確認します。 <code>\b</code> は先や後ろを、そこにある文字がそれぞれに対して異なる 単語属性("word-ness")であるかどうかを確認します。</p>
<div class="original">
<p>The lookahead and lookbehind assertions are generalizations of the 
anchor concept. Lookahead and lookbehind are zero-width assertions that 
let us specify which characters we want to test for. The lookahead 
assertion is denoted by <code>(?=regexp)</code> and the lookbehind assertion is denoted by <code>(?&lt;=fixed-regexp)</code>. Some examples are</p>
</div>
<p>先読み表明や戻り読み表明はアンカーの考え方を一般化したものです。 先読み表明と戻り読み表明はゼロ幅の表明で、文字が テストしたいものであることを指定します。 先読み表明は <code>(?=regexp)</code> で表され、戻り読み表明は <code>(?&lt;=fixed-regexp)</code> で表されます。 幾つか例を挙げましょう</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"I catch the housecat 'Tom-cat' with catnip"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cat</span><span class="pun">(?=\</span><span class="pln">s</span><span class="pun">)/;</span><span class="pln"> &nbsp; </span><span class="com"># matches 'cat' in 'housecat'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="lit">@catwords</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?&lt;=\</span><span class="pln">s</span><span class="pun">)</span><span class="pln">cat</span><span class="pun">\</span><span class="pln">w</span><span class="pun">+</span><span class="str">/g); &nbsp;# matches,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# $catwords[0] = 'catch'<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# $catwords[1] = 'catnip'<br>&nbsp; &nbsp; $x =~ /</span><span class="pun">\</span><span class="pln">bcat</span><span class="pun">\</span><span class="pln">b</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches 'cat' in 'Tom-cat'</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?&lt;=\</span><span class="pln">s</span><span class="pun">)</span><span class="pln">cat</span><span class="pun">(?=\</span><span class="pln">s</span><span class="pun">)/;</span><span class="pln"> </span><span class="com"># doesn't match; no isolated 'cat' in</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># middle of $x</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"I catch the housecat 'Tom-cat' with catnip"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">cat</span><span class="pun">(?=\</span><span class="pln">s</span><span class="pun">)/;</span><span class="pln"> &nbsp; </span><span class="com"># 'housecat'の'cat'にマッチング</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="lit">@catwords</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?&lt;=\</span><span class="pln">s</span><span class="pun">)</span><span class="pln">cat</span><span class="pun">\</span><span class="pln">w</span><span class="pun">+</span><span class="str">/g); &nbsp;# マッチングする<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# $catwords[0] = 'catch'<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# $catwords[1] = 'catnip'<br>&nbsp; &nbsp; $x =~ /</span><span class="pun">\</span><span class="pln">bcat</span><span class="pun">\</span><span class="pln">b</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># 'Tom-cat'の'cat'にマッチング</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?&lt;=\</span><span class="pln">s</span><span class="pun">)</span><span class="pln">cat</span><span class="pun">(?=\</span><span class="pln">s</span><span class="pun">)/;</span><span class="pln"> </span><span class="com"># マッチングしない; $xの中間に 'cat' はない</span></code></pre>
<div class="original">
<p>Note that the parentheses in <code>(?=regexp)</code> and <code>(?&lt;=regexp)</code>
 are non-capturing, since these are zero-width assertions. Thus in the 
second regexp, the substrings captured are those of the whole regexp 
itself. Lookahead <code>(?=regexp)</code> can match arbitrary regexps, but lookbehind <code>(?&lt;=fixed-regexp)</code> only works for regexps of fixed width, <i>i.e.</i>, a fixed number of characters long. Thus <code>(?&lt;=(ab|bc))</code> is fine, but <code>(?&lt;=(ab)*)</code> is not. The negated versions of the lookahead and lookbehind assertions are denoted by <code>(?!regexp)</code> and <code>(?&lt;!fixed-regexp)</code> respectively. They evaluate true if the regexps do <i>not</i> match:</p>
</div>
<p><code>(?=regexp)</code> と <code>(?&lt;=regexp)</code> の中にあるカッコが、これらがゼロ幅の 表明であるために捕捉を行わないことに注意してください。 したがって、二番目の正規表現では捕捉された部分文字列は 正規表現全体に対応するものになります。 先読み表明 <code>(?=regexp)</code> には任意の正規表現を使うことができますが、 戻り読み表明 <code>(?&lt;=fixed-regexp)</code> は固定長の正規表現、たとえば 固定長の文字並びでのみ使うことができます。 このため、<code>(?&lt;=(ab|bc))</code> は大丈夫ですが <code>(?&lt;=(ab)*)</code> は使えません。 先読み表明と戻り読み表明の否定形はそれぞれ <code>(?!regexp)</code> と <code>(?&lt;!fixed-regexp)</code> で表されます。 これらはその正規表現がマッチングしなかったときに真となります。</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"foobar"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">foo</span><span class="pun">(?!</span><span class="pln">bar</span><span class="pun">)/;</span><span class="pln"> &nbsp;</span><span class="com"># doesn't match, 'bar' follows 'foo'</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">foo</span><span class="pun">(?!</span><span class="pln">baz</span><span class="pun">)/;</span><span class="pln"> &nbsp;</span><span class="com"># matches, 'baz' doesn't follow 'foo'</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?&lt;!\</span><span class="pln">s</span><span class="pun">)</span><span class="pln">foo</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches, there is no \s before 'foo'</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"foobar"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">foo</span><span class="pun">(?!</span><span class="pln">bar</span><span class="pun">)/;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングしない; 'bar' が 'foo' に続いている</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">foo</span><span class="pun">(?!</span><span class="pln">baz</span><span class="pun">)/;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングする; 'baz' は 'foo' に続いていない</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?&lt;!\</span><span class="pln">s</span><span class="pun">)</span><span class="pln">foo</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングする; \s は 'foo' の前にない</span></code></pre>
<div class="original">
<p>Here is an example where a string containing blank-separated words, 
numbers and single dashes is to be split into its components. Using <code>/\s+/</code>
 alone won't work, because spaces are not required between dashes, or a 
word or a dash. Additional places for a split are established by looking
 ahead and behind:</p>
</div>
<p>これは、空白で区切られた単語、数値、一つのダッシュを含む文字列を、その要素で split するという例です。 単に <code>/\s+/</code> だけを使っても動作しません; なぜならダッシュの間、単語、 ダッシュには空白が不要だからです。 split のための追加の場所は前方参照と後方参照で構築されます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $str </span><span class="pun">=</span><span class="pln"> </span><span class="str">"one two - --6-8"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="lit">@toks</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> split </span><span class="pun">/</span><span class="pln"> </span><span class="pun">\</span><span class="pln">s</span><span class="pun">+</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># a run of spaces</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">|</span><span class="pln"> </span><span class="pun">(?&lt;=\</span><span class="pln">S</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(?=-)</span><span class="pln"> &nbsp; &nbsp;</span><span class="com"># any non-space followed by '-'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">|</span><span class="pln"> </span><span class="pun">(?&lt;=-)</span><span class="pln"> &nbsp;</span><span class="pun">(?=\</span><span class="pln">S</span><span class="pun">)</span><span class="pln"> &nbsp; </span><span class="com"># a '-' followed by any non-space</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">x</span><span class="pun">,</span><span class="pln"> $str</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># @toks = qw(one two - - - 6 - 8)</span></code></pre>
<h2 id="Using32independent32subexpressions32to32prevent32backtracking">バックトラッキングの抑制のために独立部分式を使う<a href="#Using32independent32subexpressions32to32prevent32backtracking" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p><i>Independent subexpressions</i> are regular expressions, in the 
context of a larger regular expression, that function independently of 
the larger regular expression. That is, they consume as much or as 
little of the string as they wish without regard for the ability of the 
larger regexp to match. Independent subexpressions are represented by <code>(?&gt;regexp)</code>. We can illustrate their behavior by first considering an ordinary regexp:</p>
</div>
<p><i>独立部分式</i> (Independent subexpressions) はより大きな正規表現の中で 
独立した機能を持った正規表現です。 つまり、より大きな正規表現がマッチングすることには関係なく、望む限りの大きな 
文字列もしくは望む限りの小さな文字列にマッチングしたものを消費します。 独立部分式は <code>(?&gt;regexp)</code> で表されます。 これの振る舞いを通常の正規表現を使って説明しましょう:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"ab"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">a</span><span class="pun">*</span><span class="pln">ab</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># matches</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"ab"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">a</span><span class="pun">*</span><span class="pln">ab</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングする</span></code></pre>
<div class="original">
<p>This obviously matches, but in the process of matching, the subexpression <code>a*</code> first grabbed the <code>'a'</code>. Doing so, however, wouldn't allow the whole regexp to match, so after backtracking, <code>a*</code> eventually gave back the <code>'a'</code> and matched the empty string. Here, what <code>a*</code> matched was <i>dependent</i> on what the rest of the regexp matched.</p>
</div>
<p>これは明らかにマッチングしますが、しかし、マッチングのプロセスにおいて 部分式 <code>a*</code> は最初に <code>'a'</code> をつかみとります。 それを行うことによって、正規表現全体がマッチングすることを許さず、そのために バックトラッキングが起きて <code>a*</code> は <code>'a'</code> を戻して空文字列にマッチングします。 ここで、<code>a*</code> は正規表現の残りの部分のマッチングに依存してマッチングしました。</p>
<div class="original">
<p>Contrast that with an independent subexpression:</p>
</div>
<p>独立部分式を使うと対照的に:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?&gt;</span><span class="pln">a</span><span class="pun">*)</span><span class="pln">ab</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># doesn't match!</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?&gt;</span><span class="pln">a</span><span class="pun">*)</span><span class="pln">ab</span><span class="pun">/;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングしない!</span></code></pre>
<div class="original">
<p>The independent subexpression <code>(?&gt;a*)</code> doesn't care about the rest of the regexp, so it sees an <code>'a'</code> and grabs it. Then the rest of the regexp <code>ab</code> cannot match. Because <code>(?&gt;a*)</code> is independent, there is no backtracking and the independent subexpression does not give up its <code>'a'</code>. Thus the match of the regexp as a whole fails. A similar behavior occurs with completely independent regexps:</p>
</div>
<p>この独立部分式 <code>(?&gt;a*)</code> は正規表現の残りの部分を考慮しません; そのため、<code>'a'</code> を見つけたらそれをつかみとります。 そして残りの正規表現 <code>ab</code> はマッチングできません。 <code>(?&gt;a*)</code> は独立しているので、バックトラッキングは行わず、独立部分式は <code>'a'</code> を戻すこともありません。 結果として正規表現全体のマッチングは失敗します。 同様の動作が、完全に独立した正規表現においても発生します:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"ab"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">a</span><span class="pun">*</span><span class="str">/g; &nbsp; # matches, eats an 'a'<br>&nbsp; &nbsp; $x =~ /</span><span class="pun">\</span><span class="typ">Gab</span><span class="pun">/</span><span class="pln">g</span><span class="pun">;</span><span class="pln"> </span><span class="com"># doesn't match, no 'a' available</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"ab"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">a</span><span class="pun">*</span><span class="str">/g; &nbsp; # マッチングする; 'a' を食い取る<br>&nbsp; &nbsp; $x =~ /</span><span class="pun">\</span><span class="typ">Gab</span><span class="pun">/</span><span class="pln">g</span><span class="pun">;</span><span class="pln"> </span><span class="com"># マッチングしない; 'a' がない</span></code></pre>
<div class="original">
<p>Here <code>/g</code> and <code>\G</code> create a "tag team" handoff 
of the string from one regexp to the other. Regexps with an independent 
subexpression are much like this, with a handoff of the string to the 
independent subexpression, and a handoff of the string back to the 
enclosing regexp.</p>
</div>
<p>ここで、<code>/g</code> と <code>\G</code> は「タッグチーム」を結成していて、一つの 正規表現から別の正規表現へと文字列を手渡ししています。 独立部分式を持った正規表現はこれと同じようにマッチングし、独立部分式に文字列を 手渡しして、それにマッチングした文字列を戻します。</p>
<div class="original">
<p>The ability of an independent subexpression to prevent backtracking 
can be quite useful. Suppose we want to match a non-empty string 
enclosed in parentheses up to two levels deep. Then the following regexp
 matches:</p>
</div>
<p>バックトラッキングを阻止するという独立部分式の能力はとても便利です。 2 レベルの深さを持つカッコに囲まれた空でない文字列にマッチングさせることを 考えてみましょう。 それは以下のような正規表現になります:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"abc(de(fg)h"</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># unbalanced parentheses</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">[</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">]+</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="pun">\(</span><span class="pln"> </span><span class="pun">[</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">]*</span><span class="pln"> </span><span class="pun">\)</span><span class="pln"> </span><span class="pun">)+</span><span class="pln"> </span><span class="pun">\)/</span><span class="pln">xx</span><span class="pun">;</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"abc(de(fg)h"</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># 対応の取れていないかっこ</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">[</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">]+</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="pun">\(</span><span class="pln"> </span><span class="pun">[</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">]*</span><span class="pln"> </span><span class="pun">\)</span><span class="pln"> </span><span class="pun">)+</span><span class="pln"> </span><span class="pun">\)/</span><span class="pln">xx</span><span class="pun">;</span></code></pre>
<div class="original">
<p>The regexp matches an open parenthesis, one or more copies of an 
alternation, and a close parenthesis. The alternation is two-way, with 
the first alternative <code>[^()]+</code> matching a substring with no parentheses and the second alternative <code>\([^()]*\)</code>
 matching a substring delimited by parentheses. The problem with this 
regexp is that it is pathological: it has nested indeterminate 
quantifiers of the form <code>(a+|b)+</code>. We discussed in Part 1 how
 nested quantifiers like this could take an exponentially long time to 
execute if there was no match possible. To prevent the exponential 
blowup, we need to prevent useless backtracking at some point. This can 
be done by enclosing the inner quantifier as an independent 
subexpression:</p>
</div>
<p>この正規表現は開きかっこ、選択肢にある一つか二つのコピー、そして 閉じかっこにマッチングします。 この選択肢は二分岐で、最初の選択肢は括弧のない部分文字列にマッチングする <code>[^()]+</code> で、二番目の選択肢はかっこによって区切られた部分文字列に マッチングする <code>\([^()]*\)</code> です。 この正規表現の問題点は病理学的なものです: <code>(a+|b)+</code>
 のように非決定的な 量指定子がネストしています。 パート 1 において、ネストした量指定子はマッチングに失敗するときには実行に 
指数的な時間を要することについて言及しました。 これを防ぐために、不要なバックトラッキングを抑制することが必要となります。 
これは内側の量指定子を独立部分式としてやることで行うことができます:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/\(</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">(?&gt;</span><span class="pln"> </span><span class="pun">[</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">]+</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="pun">\([</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">]*</span><span class="pln"> </span><span class="pun">\)</span><span class="pln"> </span><span class="pun">)+</span><span class="pln"> </span><span class="pun">\)/</span><span class="pln">xx</span><span class="pun">;</span></code></pre>
<div class="original">
<p>Here, <code>(?&gt;[^()]+)</code> breaks the degeneracy of string 
partitioning by gobbling up as much of the string as possible and 
keeping it. Then match failures fail much more quickly.</p>
</div>
<p>ここで、<code>(?&gt;[^()]+)</code> は可能な限りマッチングしたものをつかみとって 保持することによって文字列の分割の退行を邪魔しています。 それからマッチングは即座に失敗することになります。</p>
<h2 id="Conditional32expressions">条件式<a href="#Conditional32expressions" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>A <i>conditional expression</i> is a form of if-then-else statement 
that allows one to choose which patterns are to be matched, based on 
some condition. There are two types of conditional expression: <code>(?(<i>condition</i>)<i>yes-regexp</i>)</code> and <code>(?(condition)<i>yes-regexp</i>|<i>no-regexp</i>)</code>. <code>(?(<i>condition</i>)<i>yes-regexp</i>)</code> is like an <span style="white-space: nowrap;"><code>'if () {}'</code></span> statement in Perl. If the <i>condition</i> is true, the <i>yes-regexp</i> will be matched. If the <i>condition</i> is false, the <i>yes-regexp</i> will be skipped and Perl will move onto the next regexp element. The second form is like an <span style="white-space: nowrap;"><code>'if () {} else {}'</code></span> statement in Perl. If the <i>condition</i> is true, the <i>yes-regexp</i> will be matched, otherwise the <i>no-regexp</i> will be matched.</p>
</div>
<p><i>条件式</i> (conditional expression) は if-the-else の形式の文で、何らかの 条件に基づいてどちらのパターンをマッチングさせるかを選択できます。 条件式には二つのタイプがあります: <code>(?(<i>condition</i>)<i>yes-regexp</i>)</code> と <code>(?(condition)<i>yes-regexp</i>|<i>no-regexp</i>)</code> です。 <code>(?(<i>condition</i>)<i>yes-regexp</i>)</code> は Perl の <span style="white-space: nowrap;"><code>'if () {}'</code></span> 文のようなものです。 もし <i>condition</i> が真であれば、<i>yes-regexp</i> がマッチングの対象となります。 <i>condition</i> が偽であった場合、<i>yes-regexp</i> はスキップされて、 Perl は次の正規表現要素へと進みます。 二番目の形式は Perl の <span style="white-space: nowrap;"><code>'if () {} else {}'</code></span> 文のようなものです。 <i>conditon</i> が真であれば <i>yes-regexp</i> がマッチングの対象となり、偽であれば <i>no-regexp</i> がマッチングの対象となります。</p>
<div class="original">
<p>The <i>condition</i> can have several forms. The first form is simply an integer in parentheses <code>(<i>integer</i>)</code>. It is true if the corresponding backreference <code>\<i>integer</i></code> matched earlier in the regexp. The same thing can be done with a name associated with a capture group, written as <code>(&lt;<i>name</i>&gt;)</code> or <code>('<i>name</i>')</code>. The second form is a bare zero-width assertion <code>(?...)</code>,
 either a lookahead, a lookbehind, or a code assertion (discussed in the
 next section). The third set of forms provides tests that return true 
if the expression is executed within a recursion (<code>(R)</code>) or is being called from some capturing group, referenced either by number (<code>(R1)</code>, <code>(R2)</code>,...) or by name (<code>(R&amp;<i>name</i>)</code>).</p>
</div>
<p><i>condition</i> はいくつかのの形式を取ることができます。 最初の形式は単純な整数をカッコでくくったもの <code>(<i>integer</i>)</code> です。 これは対応する後方参照 <code>\<i>integer</i></code> が先行する正規表現の部分の中で マッチングしていれば真となります。 同じことは、捕捉グループに結び付けられた名前を使って、 <code>(&lt;<i>name</i>&gt;)</code> や <code>('<i>name</i>')</code> のように書くことでもできます。 二番目の形式はゼロ幅の表明 <code>(?...)</code> で、先読み、戻り読み、もしくは コード表明 (code assertion 次のセクションで説明します)のいずれかです。 3番目の形式は、もし式が再帰 (<code>(R)</code>) の中で実行されるか、 数値 (<code>(R1)</code>, <code>(R2)</code>,...) か名前 (<code>(R&amp;<i>name</i>)</code>) で参照される捕捉グループから 呼び出されていると真を返すというテストを提供します。</p>
<div class="original">
<p>The integer or name form of the <code>condition</code> allows us to 
choose, with more flexibility, what to match based on what matched 
earlier in the regexp. This searches for words of the form <code>"$x$x"</code> or <code>"$x$y$y$x"</code>:</p>
</div>
<p>整数または名前形式の <code>condition</code> はより一層の融通性を伴って選択することを 可能にします; マッチングするかどうかは正規表現の先行する部分が マッチングするかどうかに依存します。 以下の例は <code>"$x$x"</code> や <code>"$x$y$y$x"</code> という形式の単語を検索します。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> simple_grep </span><span class="str">'^(\w+)(\w+)?(?(2)\g2\g1|\g1)$'</span><span class="pln"> </span><span class="pun">/</span><span class="pln">usr</span><span class="pun">/</span><span class="pln">dict</span><span class="pun">/</span><span class="pln">words<br>&nbsp; &nbsp; beriberi<br>&nbsp; &nbsp; coco<br>&nbsp; &nbsp; couscous<br>&nbsp; &nbsp; deed<br>&nbsp; &nbsp; </span><span class="pun">...</span><span class="pln"><br>&nbsp; &nbsp; toot<br>&nbsp; &nbsp; toto<br>&nbsp; &nbsp; tutu</span></code></pre>
<div class="original">
<p>The lookbehind <code>condition</code> allows, along with backreferences, an earlier part of the match to influence a later part of the match. For instance,</p>
</div>
<p>戻り読みの <code>condition</code> は後方参照といっしょで、マッチングの先行する部分が マッチングの後ろの部分に影響を及ぼします。 たとえば</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/[</span><span class="pln">ATGC</span><span class="pun">]+(?(?&lt;=</span><span class="pln">AA</span><span class="pun">)</span><span class="pln">G</span><span class="pun">|</span><span class="pln">C</span><span class="pun">)</span><span class="pln">$</span><span class="pun">/;</span></code></pre>
<div class="original">
<p>matches a DNA sequence such that it either ends in <code>AAG</code>, or some other base pair combination and <code>'C'</code>. Note that the form is <code>(?(?&lt;=AA)G|C)</code> and not <code>(?((?&lt;=AA))G|C)</code>; for the lookahead, lookbehind or code assertions, the parentheses around the conditional are not needed.</p>
</div>
<p>これは <code>AAG</code> で終わるかその他の <code>'C'</code> とのコンビネーションのペアと なっている DNA シーケンスにマッチングします。 この形式は <code>(?(?&lt;=AA)G|C)</code> であって、 <code>(?((?&lt;=AA))G|C)</code> でないことに注意してください; 先読み、戻り読み、コードの表明に対しては条件部分を囲むカッコは 必要ありません。</p>
<h2 id="Defining32named32patterns">名前付きパターンを定義する<a href="#Defining32named32patterns" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Some regular expressions use identical subpatterns in several places.
 Starting with Perl 5.10, it is possible to define named subpatterns in a
 section of the pattern so that they can be called up by name anywhere 
in the pattern. This syntactic pattern for this definition group is <code>(?(DEFINE)(?&lt;<i>name</i>&gt;<i>pattern</i>)...)</code>. An insertion of a named pattern is written as <code>(?&amp;<i>name</i>)</code>.</p>
</div>
<p>同じ部分パターンを複数の箇所で使う正規表現もあります。 Perl 5.10 から、パターンのどこでも名前で呼び出せるようにするために、 パターンの一部で名前付き部分パターンを定義できるようになっています。 この定義グループのためのパターン文法は <code>(?(DEFINE)(?&lt;<i>name</i>&gt;<i>pattern</i>)...)</code> です。 名前付きパターンの挿入は <code>(?&amp;<i>name</i>)</code> のように書きます。</p>
<div class="original">
<p>The example below illustrates this feature using the pattern for 
floating point numbers that was presented earlier on. The three 
subpatterns that are used more than once are the optional sign, the 
digit sequence for an integer and the decimal fraction. The <code>DEFINE</code>
 group at the end of the pattern contains their definition. Notice that 
the decimal fraction pattern is the first place where we can reuse the 
integer pattern.</p>
</div>
<p>以下の例では以前に説明した浮動小数点数のためのパターンを使った この機能を示しています。 複数回使われる 3 つの副パターンは、省略可能の符号、整数のための 数字並び、小数点です。 パターンの末尾の <code>DEFINE</code> グループはこれらの定義を含んでいます。 小数点のパターンは整数のパターンを再利用できる最初の位置であることに 注意してください。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">/^</span><span class="pln"> </span><span class="pun">(?&amp;</span><span class="pln">osg</span><span class="pun">)\</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="pun">(?&amp;</span><span class="pln">int</span><span class="pun">)(?&amp;</span><span class="pln">dec</span><span class="pun">)?</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="pun">(?&amp;</span><span class="pln">dec</span><span class="pun">)</span><span class="pln"> </span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(?:</span><span class="pln"> </span><span class="pun">[</span><span class="pln">eE</span><span class="pun">](?&amp;</span><span class="pln">osg</span><span class="pun">)(?&amp;</span><span class="pln">int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">)?</span><span class="pln"><br>&nbsp; &nbsp; $<br>&nbsp; &nbsp; </span><span class="pun">(?(</span><span class="pln">DEFINE</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(?&lt;</span><span class="pln">osg</span><span class="pun">&gt;[-+]?)</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># optional sign</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(?&lt;</span><span class="pln">int</span><span class="pun">&gt;\</span><span class="pln">d</span><span class="pun">++)</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># integer</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="pun">(?&lt;</span><span class="pln">dec</span><span class="pun">&gt;\.(?&amp;</span><span class="pln">int</span><span class="pun">))</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># decimal fraction</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">)/</span><span class="pln">x</span></code></pre>
<h2 id="Recursive32patterns">再帰的パターン<a href="#Recursive32patterns" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>This feature (introduced in Perl 5.10) significantly extends the 
power of Perl's pattern matching. By referring to some other capture 
group anywhere in the pattern with the construct <code>(?<i>group-ref</i>)</code>, the <i>pattern</i>
 within the referenced group is used as an independent subpattern in 
place of the group reference itself. Because the group reference may be 
contained <i>within</i> the group it refers to, it is now possible to apply pattern matching to tasks that hitherto required a recursive parser.</p>
</div>
<p>(Perl 5.10 から導入された)この機能は、Perl のパターンマッチングの力を 大きく拡張します。 パターン中の任意の位置の捕捉グループを <code>(?<i>group-ref</i>)</code> 定数で 参照することで、 参照されたグループ内の <i>パターン</i> はグループ参照自身の代わりに 独立した副パターンとして使われます。 グループ参照は参照しているグループの <i>内側</i> に含まれる場合もあるので、 今までは再帰パーサが必要であった処理に対してパターンマッチングを 適用できるようになります。</p>
<div class="original">
<p>To illustrate this feature, we'll design a pattern that matches if a 
string contains a palindrome. (This is a word or a sentence that, while 
ignoring spaces, interpunctuation and case, reads the same backwards as 
forwards. We begin by observing that the empty string or a string 
containing just one word character is a palindrome. Otherwise it must 
have a word character up front and the same at its end, with another 
palindrome in between.</p>
</div>
<p>この機能を説明するために、文字列が回文である場合にマッチングするパターンを 設計します。 
(回文とは、空白、句読点、大文字小文字を無視したとき、 先頭から読んでも末尾から読んでも同じになる単語や文のことです。) 
まず、空文字列あるいは一つの単語文字からなる文字列を回文として 観測することから始めます。 
さもなければ、回文とは先頭と末尾に同じ単語文字があって、その間に 回文があるものです。</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/(?:</span><span class="pln"> </span><span class="pun">(\</span><span class="pln">w</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(?...</span><span class="typ">Here</span><span class="pln"> be a palindrome</span><span class="pun">...)</span><span class="pln"> </span><span class="pun">\</span><span class="pln">g</span><span class="pun">{-</span><span class="lit">1</span><span class="pun">}</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="pun">\</span><span class="pln">w</span><span class="pun">?</span><span class="pln"> </span><span class="pun">)/</span><span class="pln">x</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/(?:</span><span class="pln"> </span><span class="pun">(\</span><span class="pln">w</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(?...ここは回文...)</span><span class="pln"> </span><span class="pun">\</span><span class="pln">g</span><span class="pun">{-</span><span class="lit">1</span><span class="pun">}</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="pun">\</span><span class="pln">w</span><span class="pun">?</span><span class="pln"> </span><span class="pun">)/</span><span class="pln">x</span></code></pre>
<div class="original">
<p>Adding <code>\W*</code> at either end to eliminate what is to be ignored, we already have the full pattern:</p>
</div>
<p>無視するべきものを削除するためにどちらかの側に <code>\W*</code> を追加して、すでに 完全なパターンを得ています:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">my</span><span class="pln"> $pp </span><span class="pun">=</span><span class="pln"> qr</span><span class="pun">/^(\</span><span class="pln">W</span><span class="pun">*</span><span class="pln"> </span><span class="pun">(?:</span><span class="pln"> </span><span class="pun">(\</span><span class="pln">w</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(?</span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">\</span><span class="pln">g</span><span class="pun">{-</span><span class="lit">1</span><span class="pun">}</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="pun">\</span><span class="pln">w</span><span class="pun">?</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">\</span><span class="pln">W</span><span class="pun">*)</span><span class="pln">$</span><span class="pun">/</span><span class="pln">ix</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">for</span><span class="pln"> $s </span><span class="pun">(</span><span class="pln"> </span><span class="str">"saippuakauppias"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"A man, a plan, a canal: Panama!"</span><span class="pln"> </span><span class="pun">){</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"'$s' is a palindrome\n"</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> $s </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$pp</span><span class="pun">/;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span></code></pre>
<div class="original">
<p>In <code>(?...)</code> both absolute and relative backreferences may be used. The entire pattern can be reinserted with <code>(?R)</code> or <code>(?0)</code>. If you prefer to name your groups, you can use <code>(?&amp;<i>name</i>)</code> to recurse into that group.</p>
</div>
<p><code>(?...)</code> の中では絶対と相対の両方の後方参照が使えます。 パターン全体は <code>(?R)</code> または <code>(?0)</code> で再挿入できます。 グループに名前を付けたいなら、そのグループを再帰させるために <code>(?&amp;<i>name</i>)</code> が 使えます。</p>
<h2 id="A32bit32of32magic:32executing32Perl32code32in32a32regular32expression">ちょっとした魔法: 正規表現の中で Perl のコードを実行する<a href="#A32bit32of32magic:32executing32Perl32code32in32a32regular32expression" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Normally, regexps are a part of Perl expressions. <i>Code evaluation</i> expressions turn that around by allowing arbitrary Perl code to be a part of a regexp. A code evaluation expression is denoted <code>(?{<i>code</i>})</code>, with <i>code</i> a string of Perl statements.</p>
</div>
<p>通常、正規表現は Perl の式の一部です。 <i>コード評価</i> (code evaluation) 式は任意の Perl のコードを正規表現の 一部として使うことができるようにします。 コード評価式は <code>(?{<i>code</i>})</code> で表され、<i>code</i> は Perl の文である 文字列です。</p>
<div class="original">
<p>Code expressions are zero-width assertions, and the value they return
 depends on their environment. There are two possibilities: either the 
code expression is used as a conditional in a conditional expression <code>(?(<i>condition</i>)...)</code>, or it is not. If the code expression is a conditional, the code is evaluated and the result (<i>i.e.</i>,
 the result of the last statement) is used to determine truth or 
falsehood. If the code expression is not used as a conditional, the 
assertion always evaluates true and the result is put into the special 
variable <code>$^R</code>. The variable <code>$^R</code> can then be used in code expressions later in the regexp. Here are some silly examples:</p>
</div>
<p>コード式はゼロ幅の表明で、その値は環境に依存したものです。 そこには二つの可能性があります: コード式が条件式の中で <code>(?(<i>condition</i>)...)</code> のように使われるかそうでないかです。 もしコード式が条件式に使われていれば、そのコードは評価された後その結果 (最後の文の結果)が真か偽かを決定するのに使われます。 コード式が条件式として使われていなければ、その表明は常に真であり その結果は特殊変数 <code>$^R</code> に格納されます。 変数 <code>$^R</code> は正規表現の後の部分のコード式で使うことができます。 以下に単純な例を挙げます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"abcdef"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">abc</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Hi Mom!"</span><span class="pun">;})</span><span class="pln">def</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># prints 'Hi Mom!'</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">aaa</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Hi Mom!"</span><span class="pun">;})</span><span class="pln">def</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># doesn't match,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># no 'Hi Mom!'</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"abcdef"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">abc</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Hi Mom!"</span><span class="pun">;})</span><span class="pln">def</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># 'Hi Mom!' を主力</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">aaa</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Hi Mom!"</span><span class="pun">;})</span><span class="pln">def</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># マッチングしない</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># 'Hi Mom!'は出力されない</span></code></pre>
<div class="original">
<p>Pay careful attention to the next example:</p>
</div>
<p>次の例に注目してください:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">abc</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Hi Mom!"</span><span class="pun">;})</span><span class="pln">ddd</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># doesn't match,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># no 'Hi Mom!'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># but why not?</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">abc</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Hi Mom!"</span><span class="pun">;})</span><span class="pln">ddd</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># マッチングしない;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># 'Hi Mom!' は出力されない</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># でもなぜ?</span></code></pre>
<div class="original">
<p>At first glance, you'd think that it shouldn't print, because obviously the <code>ddd</code> isn't going to match the target string. But look at this example:</p>
</div>
<p>ぱっと見て、出力されないとは思わなかったでしょう; なぜなら <code>ddd</code> は 明らかにターゲット文字列にマッチングするものではないからです。 しかし次の例を見ると:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">abc</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Hi Mom!"</span><span class="pun">;})[</span><span class="pln">dD</span><span class="pun">]</span><span class="pln">dd</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># doesn't match,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># but _does_ print</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">abc</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Hi Mom!"</span><span class="pun">;})[</span><span class="pln">dD</span><span class="pun">]</span><span class="pln">dd</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># マッチングしない;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># しかし出力「される」</span></code></pre>
<div class="original">
<p>Hmm. What happened here? If you've been following along, you know 
that the above pattern should be effectively (almost) the same as the 
last one; enclosing the <code>'d'</code> in a character class isn't going to change what it matches. So why does the first not print while the second one does?</p>
</div>
<p>ふーむ。 何が起きたのでしょう? 先のパターンが効果としては最後のものと (ほとんど) 同じであることをあなたは 知っています; 文字クラスの中に閉じ込められた <code>'d'</code> はマッチングを 変えるものではありません。 では、なぜ最初のパターンは出力されないのに二番目のものは 出力されたのでしょう?</p>
<div class="original">
<p>The answer lies in the optimizations the regexp engine makes. In the 
first case, all the engine sees are plain old characters (aside from the
 <code>?{}</code> construct). It's smart enough to realize that the string <code>'ddd'</code>
 doesn't occur in our target string before actually running the pattern 
through. But in the second case, we've tricked it into thinking that our
 pattern is more complicated. It takes a look, sees our character class,
 and decides that it will have to actually run the pattern to determine 
whether or not it matches, and in the process of running it hits the 
print statement before it discovers that we don't have a match.</p>
</div>
<p>その答えは正規表現エンジンが行う最適化にあります。 最初のケースでは、 エンジンが見ているものは普通の古い文字(<code>?{}</code> 構造は別として) です。 パターンを実際に実行するよりも前にターゲット文字列が <code>'ddd'</code>
 という 文字列を含んでいないことがわかるくらい賢いのです。 しかし二番目のケースでは、より複雑なパターンであると 
思わせるようなトリックを使いました。 文字クラスを見て、エンジンはマッチングするかどうかは実際にパターンを 
実行してみなければならないと判断し、その実行の最中にマッチングしないことが わかるよりも前にある print 文にヒットするのです。</p>
<div class="original">
<p>To take a closer look at how the engine does optimizations, see the section <a href="#Pragmas32and32debugging">"Pragmas and debugging"</a> below.</p>
</div>
<p>エンジンがどのように最適化を行うかについては後にあるセクション <a href="#Pragmas32and32debugging">"Pragmas and debugging"</a> を参照してください。</p>
<div class="original">
<p>More fun with <code>?{}</code>:</p>
</div>
<p><code>?{}</code> でもっと楽しいことが起きます:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Hi Mom!"</span><span class="pun">;})/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># prints 'Hi Mom!'</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?{</span><span class="pln">$c </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;})(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"$c"</span><span class="pun">;})/;</span><span class="pln"> &nbsp;</span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># prints '1'</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?{</span><span class="pln">$c </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;})(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"$^R"</span><span class="pun">;})/;</span><span class="pln"> </span><span class="com"># matches,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># prints '1'</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Hi Mom!"</span><span class="pun">;})/;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># 'Hi Mom!' を出力</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?{</span><span class="pln">$c </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;})(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"$c"</span><span class="pun">;})/;</span><span class="pln"> &nbsp;</span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># '1' を出力</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?{</span><span class="pln">$c </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;})(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"$^R"</span><span class="pun">;})/;</span><span class="pln"> </span><span class="com"># マッチングする</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># '1' を出力</span></code></pre>
<div class="original">
<p>The bit of magic mentioned in the section title occurs when the 
regexp backtracks in the process of searching for a match. If the regexp
 backtracks over a code expression and if the variables used within are 
localized using <code>local</code>, the changes in the variables 
produced by the code expression are undone! Thus, if we wanted to count 
how many times a character got matched inside a group, we could use, <i>e.g.</i>,</p>
</div>
<p>このセクションのタイトルにある「ちょっとした魔法」というのは マッチングのために検索処理をしているときのバックトラックが 起きたときのことを言っています。 もしバックトラックがコード式をまたいで発生して、<code>local</code> によって その中に局所化された変数を使っていた場合、コード式による変数の変更は 巻き戻されます! したがって、グループの中にある文字の数を数えたい場合には</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"aaaa"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $count </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># initialize 'a' count</span><span class="pln"><br>&nbsp; &nbsp; $c </span><span class="pun">=</span><span class="pln"> </span><span class="str">"bob"</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># test if $c gets clobbered</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?{</span><span class="kwd">local</span><span class="pln"> $c </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;})</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># initialize count</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">(</span><span class="pln"> a &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># match 'a'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">(?{</span><span class="kwd">local</span><span class="pln"> $c </span><span class="pun">=</span><span class="pln"> $c </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;})</span><span class="pln"> &nbsp;</span><span class="com"># increment count</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">)*</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># do this any number of times,</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;aa &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># but match 'aa' at the end</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">(?{</span><span class="pln">$count </span><span class="pun">=</span><span class="pln"> $c</span><span class="pun">;})</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># copy local $c var into $count</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"'a' count is $count, \$c variable is '$c'\n"</span><span class="pun">;</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"aaaa"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $count </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># 'a' のカウントを初期化する</span><span class="pln"><br>&nbsp; &nbsp; $c </span><span class="pun">=</span><span class="pln"> </span><span class="str">"bob"</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># $c が上書きされているかを調べる</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?{</span><span class="kwd">local</span><span class="pln"> $c </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;})</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># カウントを初期化</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">(</span><span class="pln"> a &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># 'a' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">(?{</span><span class="kwd">local</span><span class="pln"> $c </span><span class="pun">=</span><span class="pln"> $c </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;})</span><span class="pln"> &nbsp;</span><span class="com"># カウントをインクリメント</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">)*</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># これを任意回繰り返すが</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;aa &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># 最後に 'aa' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">(?{</span><span class="pln">$count </span><span class="pun">=</span><span class="pln"> $c</span><span class="pun">;})</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com"># ローカルの $c を $count にコピー</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"'a' count is $count, \$c variable is '$c'\n"</span><span class="pun">;</span></code></pre>
<div class="original">
<p>This prints</p>
</div>
<p>これは</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">'a'</span><span class="pln"> count is </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> $c variable is </span><span class="str">'bob'</span></code></pre>
<div class="original">
<p>If we replace the <span style="white-space: nowrap;"><code> (?{local $c = $c + 1;})</code></span> with <span style="white-space: nowrap;"><code> (?{$c = $c + 1;})</code></span>, the variable changes are <i>not</i> undone during backtracking, and we get</p>
</div>
<p>もし <span style="white-space: nowrap;"><code> (?{local $c = $c + 1;})</code></span> を <span style="white-space: nowrap;"><code> (?{$c = $c + 1;})</code></span> にすると、 バックトラックによって変数の変更は <i>巻き戻されず</i>、結果は 以下のようになります</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">'a'</span><span class="pln"> count is </span><span class="lit">4</span><span class="pun">,</span><span class="pln"> $c variable is </span><span class="str">'bob'</span></code></pre>
<div class="original">
<p>Note that only localized variable changes are undone. Other side effects of code expression execution are permanent. Thus</p>
</div>
<p>局所化された変数の変更だけが巻き戻されるということに注意してください。 コード式の別の副作用は恒久的です。 したがって</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"aaaa"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(</span><span class="pln">a</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Yow\n"</span><span class="pun">;}))*</span><span class="pln">aa</span><span class="pun">/;</span></code></pre>
<div class="original">
<p>produces</p>
</div>
<p>これは以下の結果となります</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="typ">Yow</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="typ">Yow</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="typ">Yow</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="typ">Yow</span></code></pre>
<div class="original">
<p>The result <code>$^R</code> is automatically localized, so that it will behave properly in the presence of backtracking.</p>
</div>
<p>結果である <code>$^R</code> は自動的に局所化されるので、バックトラックが 行われても適切に振舞います。</p>
<div class="original">
<p>This example uses a code expression in a conditional to match a definite article, either <code>'the'</code> in English or <code>'der|die|das'</code> in German:</p>
</div>
<p>以下の例は、条件にコード式を使って英語の <code>'the'</code> か ドイツ語の <code>'der|die|das'</code> にマッチングさせるものです:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $lang </span><span class="pun">=</span><span class="pln"> </span><span class="str">'DE'</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># use German</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">...</span><span class="pln"><br>&nbsp; &nbsp; $text </span><span class="pun">=</span><span class="pln"> </span><span class="str">"das"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"matched\n"</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> $text </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?(?{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $lang eq </span><span class="str">'EN'</span><span class="pun">;</span><span class="pln"> </span><span class="com"># is the language English?</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the </span><span class="pun">|</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># if so, then match 'the'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">(</span><span class="pln">der</span><span class="pun">|</span><span class="kwd">die</span><span class="pun">|</span><span class="pln">das</span><span class="pun">)</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># else, match 'der|die|das'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">xi</span><span class="pun">;</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $lang </span><span class="pun">=</span><span class="pln"> </span><span class="str">'DE'</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># ドイツ語を使う</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">...</span><span class="pln"><br>&nbsp; &nbsp; $text </span><span class="pun">=</span><span class="pln"> </span><span class="str">"das"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"matched\n"</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> $text </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(?(?{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $lang eq </span><span class="str">'EN'</span><span class="pun">;</span><span class="pln"> </span><span class="com"># 言語は英語か?</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the </span><span class="pun">|</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># そうなら 'the' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">(</span><span class="pln">der</span><span class="pun">|</span><span class="kwd">die</span><span class="pun">|</span><span class="pln">das</span><span class="pun">)</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># そうでないなら 'der|die|das' にマッチング</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">xi</span><span class="pun">;</span></code></pre>
<div class="original">
<p>Note that the syntax here is <code>(?(?{...})<i>yes-regexp</i>|<i>no-regexp</i>)</code>, not <code>(?((?{...}))<i>yes-regexp</i>|<i>no-regexp</i>)</code>. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</p>
</div>
<p>ここでの構文が <code>(?((?{...}))<i>yes-regexp</i>|<i>no-regexp</i>)</code> ではなく <code>(?(?{...})<i>yes-regexp</i>|<i>no-regexp</i>)</code> であることに注意してください。 言い換えれば、コード式の場合には条件を囲む余計なかっこは いらないということです。</p>
<div class="original">
<p>If you try to use code expressions where the code text is contained 
within an interpolated variable, rather than appearing literally in the 
pattern, Perl may surprise you:</p>
</div>
<p>コード式を、パターン中にリテラルに書くのではなく、展開された変数の中に 入れると、Perl はあなたを驚かせるかもしれません:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $bar </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $pat </span><span class="pun">=</span><span class="pln"> </span><span class="str">'(?{ 1 })'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">/foo(?{ $bar })bar/</span><span class="pun">;</span><span class="pln"> </span><span class="com"># compiles ok, $bar not interpolated</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">foo</span><span class="pun">(?{</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">})</span><span class="pln">$bar</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># compiles ok, $bar interpolated</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">foo$</span><span class="pun">{</span><span class="pln">pat</span><span class="pun">}</span><span class="pln">bar</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># compile error!</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $bar </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $pat </span><span class="pun">=</span><span class="pln"> </span><span class="str">'(?{ 1 })'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">/foo(?{ $bar })bar/</span><span class="pun">;</span><span class="pln"> </span><span class="com"># コンパイル ok; $bar は展開されない</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">foo</span><span class="pun">(?{</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">})</span><span class="pln">$bar</span><span class="pun">/;</span><span class="pln"> &nbsp; </span><span class="com"># コンパイル ok; $bar は展開される</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">foo$</span><span class="pun">{</span><span class="pln">pat</span><span class="pun">}</span><span class="pln">bar</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># コンパイルエラー!</span></code></pre>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $pat </span><span class="pun">=</span><span class="pln"> qr</span><span class="pun">/(?{</span><span class="pln"> $foo </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">})/;</span><span class="pln"> &nbsp;</span><span class="com"># precompile code regexp</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">foo$</span><span class="pun">{</span><span class="pln">pat</span><span class="pun">}</span><span class="pln">bar</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># compiles ok</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $pat </span><span class="pun">=</span><span class="pln"> qr</span><span class="pun">/(?{</span><span class="pln"> $foo </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">})/;</span><span class="pln"> &nbsp;</span><span class="com"># コード正規表現をプリコンパイル</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">/</span><span class="pln">foo$</span><span class="pun">{</span><span class="pln">pat</span><span class="pun">}</span><span class="pln">bar</span><span class="pun">/;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># コンパイル ok</span></code></pre>
<div class="original">
<p>If a regexp has a variable that interpolates a code expression, Perl 
treats the regexp as an error. If the code expression is precompiled 
into a variable, however, interpolating is ok. The question is, why is 
this an error?</p>
</div>
<p>もし正規表現がコード式に展開される変数を持っているなら、Perl はその正規表現を エラーとします。 しかしながら、コード式が変数にプリコンパイルされていた場合には、 変数展開は ok です。 疑問は、これがなぜエラーになるかです。</p>
<div class="original">
<p>The reason is that variable interpolation and code expressions 
together pose a security risk. The combination is dangerous because many
 programmers who write search engines often take user input and plug it 
directly into a regexp:</p>
</div>
<p>その理由は、変数展開とコード式を組み合わせることでセキュリティ上の リスクが発生するからです。 この組み合わせは検索エンジンを記述する多くのプログラマがしばしば ユーザーからの入力を取り、それをダイレクトに変数に押し込むから 危険なのです。</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $regexp </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;&gt;;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># read user-supplied regexp</span><span class="pln"><br>&nbsp; &nbsp; $chomp $regexp</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># get rid of possible newline</span><span class="pln"><br>&nbsp; &nbsp; $text </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$regexp</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># search $text for the $regexp</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $regexp </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;&gt;;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># ユーザーが提供する正規表現を読み込む</span><span class="pln"><br>&nbsp; &nbsp; $chomp $regexp</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; </span><span class="com"># 改行があれば取り除く</span><span class="pln"><br>&nbsp; &nbsp; $text </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/</span><span class="pln">$regexp</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># $text から $regexp を探し出す</span></code></pre>
<div class="original">
<p>If the <code>$regexp</code> variable contains a code expression, the 
user could then execute arbitrary Perl code. For instance, some joker 
could search for <span style="white-space: nowrap;"><code>system('rm -rf *');</code></span> to erase your files. In this sense, the combination of interpolation and code expressions <i>taints</i>
 your regexp. So by default, using both interpolation and code 
expressions in the same regexp is not allowed. If you're not concerned 
about malicious users, it is possible to bypass this security check by 
invoking <span style="white-space: nowrap;"><code>use re 'eval'</code></span>:</p>
</div>
<p>もし変数 <code>$regexp</code> がコード式を含んでいたら、ユーザーは任意の Perl コードを実行することが可能となります。 たとえば、一部の不心得者が <code>system('rm -rf *');</code> を検索したら、 あなたのファイルを消すことになります。 このため、変数展開とコード式の組み合わせは正規表現を <i>汚染する</i> ものと みなされます。 そのためデフォルトでは、同じ正規表現の中で変数展開とコード式の両方を 使うことを許していないのです。 もし悪意あるユーザーを考慮しないのであれば、<span style="white-space: nowrap;"><code>use re 'eval'</code></span>を 実行することによってセキュリティチェックをバイパスすることが可能です:</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">use</span><span class="pln"> re </span><span class="str">'eval'</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># throw caution out the door</span><span class="pln"><br>&nbsp; &nbsp; $bar </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $pat </span><span class="pun">=</span><span class="pln"> </span><span class="str">'(?{ 1 })'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">/foo${pat}bar/</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># compiles ok</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">use</span><span class="pln"> re </span><span class="str">'eval'</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># 注意を無視する</span><span class="pln"><br>&nbsp; &nbsp; $bar </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $pat </span><span class="pun">=</span><span class="pln"> </span><span class="str">'(?{ 1 })'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">/foo${pat}bar/</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="com"># コンパイル ok</span></code></pre>
<div class="original">
<p>Another form of code expression is the <i>pattern code expression</i>.
 The pattern code expression is like a regular code expression, except 
that the result of the code evaluation is treated as a regular 
expression and matched immediately. A simple example is</p>
</div>
<p>もう一つのコード式は <i>パターンコード式</i>(pattern code expression) です。 パターンコード式は通常のコード式に似ていますが、コードの評価結果が 正規表現として扱われ、即座にマッチングに使われる点が異なります。 単純な例を挙げましょう</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $length </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $char </span><span class="pun">=</span><span class="pln"> </span><span class="str">'a'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">'aaaaabb'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(??{</span><span class="pln">$char x $length</span><span class="pun">})/</span><span class="pln">x</span><span class="pun">;</span><span class="pln"> </span><span class="com"># matches, there are 5 of 'a'</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $length </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $char </span><span class="pun">=</span><span class="pln"> </span><span class="str">'a'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">'aaaaabb'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(??{</span><span class="pln">$char x $length</span><span class="pun">})/</span><span class="pln">x</span><span class="pun">;</span><span class="pln"> </span><span class="com"># マッチングする; 5個の 'a'がある</span></code></pre>
<div class="original">
<p>This final example contains both ordinary and pattern code expressions. It detects whether a binary string <code>1101010010001...</code> has a Fibonacci spacing 0,1,1,2,3,5,... of the <code>'1'</code>'s:</p>
</div>
<p>最後の例はコード式とパターンコード式の両方を含んだものです。 これは 2 進文字列 <code>1101010010001...</code> に、<code>'1'</code> の フィボナッチ空白 0,1,1,2,3,5,... があるかを見つけ出します:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; $x </span><span class="pun">=</span><span class="pln"> </span><span class="str">"1101010010001000001"</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $z0 </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pun">;</span><span class="pln"> $z1 </span><span class="pun">=</span><span class="pln"> </span><span class="str">'0'</span><span class="pun">;</span><span class="pln"> &nbsp; </span><span class="com"># initial conditions</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">print</span><span class="pln"> </span><span class="str">"It is a Fibonacci sequence\n"</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">if</span><span class="pln"> $x </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="lit">1</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># match an initial '1'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">(?:</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">((??{</span><span class="pln"> $z0 </span><span class="pun">}))</span><span class="pln"> </span><span class="com"># match some '0'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">1</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com"># and then a '1'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">(?{</span><span class="pln"> $z0 </span><span class="pun">=</span><span class="pln"> $z1</span><span class="pun">;</span><span class="pln"> $z1 </span><span class="pun">.=</span><span class="pln"> $</span><span class="pun">^</span><span class="pln">N</span><span class="pun">;</span><span class="pln"> </span><span class="pun">})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">)+</span><span class="pln"> &nbsp; </span><span class="com"># repeat as needed</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $ &nbsp; &nbsp; &nbsp;</span><span class="com"># that is all there is</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">/</span><span class="pln">x</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; printf </span><span class="str">"Largest sequence matched was %d\n"</span><span class="pun">,</span><span class="pln"> length</span><span class="pun">(</span><span class="pln">$z1</span><span class="pun">)-</span><span class="pln">length</span><span class="pun">(</span><span class="pln">$z0</span><span class="pun">);</span></code></pre>
<div class="original">
<p>Remember that <code>$^N</code> is set to whatever was matched by the last completed capture group. This prints</p>
</div>
<p><code>$^N</code> は最後に完了した捕捉グループでマッチングしたものがセットされることを 忘れないでください。 これは以下を表示します</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="typ">It</span><span class="pln"> is a </span><span class="typ">Fibonacci</span><span class="pln"> sequence<br>&nbsp; &nbsp; </span><span class="typ">Largest</span><span class="pln"> sequence matched was </span><span class="lit">5</span></code></pre>
<div class="original">
<p>Ha! Try that with your garden variety regexp package...</p>
</div>
<p>ほら! これを、ありふれた正規表現パッケージで試してみてください…</p>
<div class="original">
<p>Note that the variables <code>$z0</code> and <code>$z1</code> are not
 substituted when the regexp is compiled, as happens for ordinary 
variables outside a code expression. Rather, the whole code block is 
parsed as perl code at the same time as perl is compiling the code 
containing the literal regexp pattern.</p>
</div>
<p><code>$z0</code> と <code>$z1</code> という変数は正規表現がコンパイルされたときには、 
コード式の外側で通常の変数が使われたときのような置換は行われないということに 注意してください。 
代わりに、コードブロック全体は、リテラルな正規表現が含まれたコードが コンパイルされるのと同時に perl によって perl 
コードとしてパースされます。</p>
<div class="original">
<p>This regexp without the <code>/x</code> modifier is</p>
</div>
<p>この <code>/x</code> 修飾子がない正規表現は</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">/^</span><span class="lit">1</span><span class="pun">(?:((??{</span><span class="pln"> $z0 </span><span class="pun">}))</span><span class="lit">1</span><span class="pun">(?{</span><span class="pln"> $z0 </span><span class="pun">=</span><span class="pln"> $z1</span><span class="pun">;</span><span class="pln"> $z1 </span><span class="pun">.=</span><span class="pln"> $</span><span class="pun">^</span><span class="pln">N</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}))+</span><span class="pln">$</span><span class="pun">/</span></code></pre>
<div class="original">
<p>which shows that spaces are still possible in the code parts. 
Nevertheless, when working with code and conditional expressions, the 
extended form of regexps is almost necessary in creating and debugging 
regexps.</p>
</div>
<p>のようになり、それでもコード部分には空白を入れることが可能です。 それでもなお、コード式と条件式を使ったときには、正規表現の拡張された形式は 正規表現を生成してデバッグする必要があるでしょう。</p>
<h2 id="Backtracking32control32verbs">バックトラッキング制御動詞<a href="#Backtracking32control32verbs" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Perl 5.10 introduced a number of control verbs intended to provide 
detailed control over the backtracking process, by directly influencing 
the regexp engine and by providing monitoring techniques. See <a href="https://perldoc.jp/pod/perlre#Special32Backtracking32Control32Verbs">"Special Backtracking Control Verbs" in perlre</a> for a detailed description.</p>
</div>
<p>Perl 5.10 から、正規表現エンジンに直接影響を与えることと、監視技術を 提供することによって、バックトラッキング処理を詳細に制御するための 制御同士が導入されました。 <a href="https://perldoc.jp/pod/perlre#Special32Backtracking32Control32Verbs">"Special Backtracking Control Verbs" in perlre</a> を参照してください。</p>
<div class="original">
<p>Below is just one example, illustrating the control verb <code>(*FAIL)</code>, which may be abbreviated as <code>(*F)</code>.
 If this is inserted in a regexp it will cause it to fail, just as it 
would at some mismatch between the pattern and the string. Processing of
 the regexp continues as it would after any "normal" failure, so that, 
for instance, the next position in the string or another alternative 
will be tried. As failing to match doesn't preserve capture groups or 
produce results, it may be necessary to use this in combination with 
embedded code.</p>
</div>
<p>以下は、制御動詞 <code>(*FAIL)</code> (<code>(*F)</code> と省略できます) を例示した 
単なる一つの例です。 これが正規表現に挿入されると、パターンと文字列で不一致があったかのように、 失敗を引き起こします。 
正規表現の処理は「通常の」失敗の後のように続行され、 例えば、文字列内の次の位置や、他の選択肢が試行されます。 
マッチングの失敗は捕捉グループに保存されたり結果を生成したりしないので、 これは組み込みコードと組み合わせて使う必要があるでしょう。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;</span><span class="pun">%</span><span class="pln">count </span><span class="pun">=</span><span class="pln"> </span><span class="pun">();</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="str">"supercalifragilisticexpialidocious"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">/([</span><span class="pln">aeiou</span><span class="pun">])(?{</span><span class="pln"> $count</span><span class="pun">{</span><span class="pln">$1</span><span class="pun">}++;</span><span class="pln"> </span><span class="pun">})(*</span><span class="pln">FAIL</span><span class="pun">)/</span><span class="pln">i</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp;printf </span><span class="str">"%3d '%s'\n"</span><span class="pun">,</span><span class="pln"> $count</span><span class="pun">{</span><span class="pln">$_</span><span class="pun">},</span><span class="pln"> $_ </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sort keys </span><span class="pun">%</span><span class="pln">count</span><span class="pun">);</span></code></pre>
<div class="original">
<p>The pattern begins with a class matching a subset of letters. Whenever this matches, a statement like <code>$count{'a'}++;</code> is executed, incrementing the letter's counter. Then <code>(*FAIL)</code>
 does what it says, and the regexp engine proceeds according to the 
book: as long as the end of the string hasn't been reached, the position
 is advanced before looking for another vowel. Thus, match or no match 
makes no difference, and the regexp engine proceeds until the entire 
string has been inspected. (It's remarkable that an alternative solution
 using something like</p>
</div>
<p>パターンは文字のサブクラスにマッチングするクラスで始まります。 どこでマッチングしても、<code>$count{'a'}++;</code> のような分が実行され、 その文字のカウンタをインクリメントします。 それから <code>(*FAIL)</code>
 がその名前の通りのことを行い、正規表現エンジンは 本に従って続行します: 文字列の末尾に到達するまで、次の母音を探す前の 位置まで進みます。 
従って、マッチングしたかどうかには違いはなく、正規表現エンジンは文字列全体が 検査されるまで続行します。 
(注意することは、以下のような代替手段は</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp;$count</span><span class="pun">{</span><span class="pln">lc</span><span class="pun">(</span><span class="pln">$_</span><span class="pun">)}++</span><span class="pln"> </span><span class="kwd">for</span><span class="pln"> split</span><span class="pun">(</span><span class="str">''</span><span class="pun">,</span><span class="pln"> </span><span class="str">"supercalifragilisticexpialidocious"</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp;printf </span><span class="str">"%3d '%s'\n"</span><span class="pun">,</span><span class="pln"> $count2</span><span class="pun">{</span><span class="pln">$_</span><span class="pun">},</span><span class="pln"> $_ </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> qw</span><span class="pun">{</span><span class="pln"> a e i o u </span><span class="pun">}</span><span class="pln"> </span><span class="pun">);</span></code></pre>
<div class="original">
<p>is considerably slower.)</p>
</div>
<p>かなり遅いということです。)</p>
<h2 id="Pragmas32and32debugging">プラグマとデバッグ<a href="#Pragmas32and32debugging" class="toc_link">¶</a></h2>
<p></p>
<div class="original">
<p>Speaking of debugging, there are several pragmas available to control
 and debug regexps in Perl. We have already encountered one pragma in 
the previous section, <span style="white-space: nowrap;"><code>use re 'eval';</code></span>, that allows variable interpolation and code expressions to coexist in a regexp. The other pragmas are</p>
</div>
<p>デバッグに関して、Perlで正規表現を制御したりデバッグするために幾つかの プラグマがあります。 前のセクションですでに <span style="white-space: nowrap;"><code>use re 'eval';</code></span> という正規表現の中で 変数展開とコード式を共存させることを許可するプラグマが登場しています。 他のプラグマには以下のものがあります</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">use</span><span class="pln"> re </span><span class="str">'taint'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $tainted </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;&gt;;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="lit">@parts</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$tainted </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(\</span><span class="pln">w</span><span class="pun">+)\</span><span class="pln">s</span><span class="pun">+(\</span><span class="pln">w</span><span class="pun">+)/;</span><span class="pln"> </span><span class="com"># @parts is now tainted</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">use</span><span class="pln"> re </span><span class="str">'taint'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; $tainted </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;&gt;;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="lit">@parts</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">$tainted </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/(\</span><span class="pln">w</span><span class="pun">+)\</span><span class="pln">s</span><span class="pun">+(\</span><span class="pln">w</span><span class="pun">+)/;</span><span class="pln"> </span><span class="com"># @parts は汚染されている</span></code></pre>
<div class="original">
<p>The <code>taint</code> pragma causes any substrings from a match with
 a tainted variable to be tainted as well. This is not normally the 
case, as regexps are often used to extract the safe bits from a tainted 
variable. Use <code>taint</code> when you are not extracting safe bits, but are performing some other processing. Both <code>taint</code> and <code>eval</code> pragmas are lexically scoped, which means they are in effect only until the end of the block enclosing the pragmas.</p>
</div>
<p><code>taint</code> プラグマは汚染された変数に対するマッチングによる部分文字列を 同様に汚染されたものにするというものです。 これは通常の場合では行われず、正規表現はしばしば汚染された変数から 安全な情報を取り出すのに使われています。 安全な情報を取り出すのではないとき <code>taint</code> を使いますが、他の処理を 行います。 プラグマ <code>taint</code> と <code>eval</code> は両方ともレキシカルスコープで、その プラグマを囲むブロックの最後までしか影響が及びません。</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">use</span><span class="pln"> re </span><span class="str">'/m'</span><span class="pun">;</span><span class="pln"> &nbsp;</span><span class="com"># or any other flags</span><span class="pln"><br>&nbsp; &nbsp; $multiline_string </span><span class="pun">=~</span><span class="pln"> </span><span class="pun">/^</span><span class="pln">foo</span><span class="pun">/;</span><span class="pln"> </span><span class="com"># /m is implied</span></code></pre>
<div class="original">
<p>The <code>re '/flags'</code> pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See <a href="https://perldoc.jp/pod/re#47flags32mode">"'/flags' mode" in re</a> for more detail.</p>
</div>
<p>(Perl 5.14 で導入された) <code>re '/flags'</code> プラグマは、レキシカルスコープの 終わりまで、与えられた正規表現フラグを有効にします。 さらなる詳細は <a href="https://perldoc.jp/pod/re#47flags32mode">"'/flags' mode" in re</a> を参照してください。</p>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">use</span><span class="pln"> re </span><span class="str">'debug'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">/^(.*)$/</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># output debugging info</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">use</span><span class="pln"> re </span><span class="str">'debug'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">/^(.*)$/</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># デバッグ情報を出力する</span></code></pre>
<div class="original">
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">use</span><span class="pln"> re </span><span class="str">'debugcolor'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">/^(.*)$/</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># output debugging info in living color</span></code></pre>
</div>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="kwd">use</span><span class="pln"> re </span><span class="str">'debugcolor'</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="str">/^(.*)$/</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> &nbsp; &nbsp; &nbsp; </span><span class="com"># デバッグ情報を色つきで出力する</span></code></pre>
<div class="original">
<p>The global <code>debug</code> and <code>debugcolor</code> pragmas allow one to get detailed debugging info about regexp compilation and execution. <code>debugcolor</code>
 is the same as debug, except the debugging information is displayed in 
color on terminals that can display termcap color sequences. Here is 
example output:</p>
</div>
<p><code>debug</code> プラグマと <code>debugcolor</code> プラグマは正規表現のコンパイルと 実行に関する詳細なデバッグ情報を提供します。 <code>debugcolor</code> は <code>debug</code> と同じですが、デバッグ情報を色付きで (termcap のカラーシーケンスを出力することのできる)ターミナルに出力します。 以下は出力の例です:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="pun">%</span><span class="pln"> perl </span><span class="pun">-</span><span class="pln">e </span><span class="str">'use re "debug"; "abc" =~ /a*b+c/;'</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Compiling</span><span class="pln"> </span><span class="typ">REx</span><span class="pln"> </span><span class="str">'a*b+c'</span><span class="pln"><br>&nbsp; &nbsp; size </span><span class="lit">9</span><span class="pln"> first at </span><span class="lit">1</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">1</span><span class="pun">:</span><span class="pln"> STAR</span><span class="pun">(</span><span class="lit">4</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">2</span><span class="pun">:</span><span class="pln"> &nbsp; EXACT </span><span class="pun">&lt;</span><span class="pln">a</span><span class="pun">&gt;(</span><span class="lit">0</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">4</span><span class="pun">:</span><span class="pln"> PLUS</span><span class="pun">(</span><span class="lit">7</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">5</span><span class="pun">:</span><span class="pln"> &nbsp; EXACT </span><span class="pun">&lt;</span><span class="pln">b</span><span class="pun">&gt;(</span><span class="lit">0</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">7</span><span class="pun">:</span><span class="pln"> EXACT </span><span class="pun">&lt;</span><span class="pln">c</span><span class="pun">&gt;(</span><span class="lit">9</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">9</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">END</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; floating </span><span class="str">'bc'</span><span class="pln"> at </span><span class="lit">0.</span><span class="pun">.</span><span class="lit">2147483647</span><span class="pln"> </span><span class="pun">(</span><span class="pln">checking floating</span><span class="pun">)</span><span class="pln"> minlen </span><span class="lit">2</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Guessing</span><span class="pln"> start of match</span><span class="pun">,</span><span class="pln"> </span><span class="typ">REx</span><span class="pln"> </span><span class="str">'a*b+c'</span><span class="pln"> against </span><span class="str">'abc'</span><span class="pun">...</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Found</span><span class="pln"> floating substr </span><span class="str">'bc'</span><span class="pln"> at offset </span><span class="lit">1.</span><span class="pun">..</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Guessed</span><span class="pun">:</span><span class="pln"> match at offset </span><span class="lit">0</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Matching</span><span class="pln"> </span><span class="typ">REx</span><span class="pln"> </span><span class="str">'a*b+c'</span><span class="pln"> against </span><span class="str">'abc'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="typ">Setting</span><span class="pln"> an EVAL scope</span><span class="pun">,</span><span class="pln"> savestack</span><span class="pun">=</span><span class="lit">3</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">0</span><span class="pln"> </span><span class="pun">&lt;&gt;</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">abc</span><span class="pun">&gt;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">|</span><span class="pln"> &nbsp;</span><span class="lit">1</span><span class="pun">:</span><span class="pln"> &nbsp;STAR<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EXACT </span><span class="pun">&lt;</span><span class="pln">a</span><span class="pun">&gt;</span><span class="pln"> can match </span><span class="lit">1</span><span class="pln"> times out of </span><span class="lit">32767.</span><span class="pun">..</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="typ">Setting</span><span class="pln"> an EVAL scope</span><span class="pun">,</span><span class="pln"> savestack</span><span class="pun">=</span><span class="lit">3</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">a</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bc</span><span class="pun">&gt;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">|</span><span class="pln"> &nbsp;</span><span class="lit">4</span><span class="pun">:</span><span class="pln"> &nbsp; &nbsp;PLUS<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EXACT </span><span class="pun">&lt;</span><span class="pln">b</span><span class="pun">&gt;</span><span class="pln"> can match </span><span class="lit">1</span><span class="pln"> times out of </span><span class="lit">32767.</span><span class="pun">..</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="typ">Setting</span><span class="pln"> an EVAL scope</span><span class="pun">,</span><span class="pln"> savestack</span><span class="pun">=</span><span class="lit">3</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">2</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">ab</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">c</span><span class="pun">&gt;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">|</span><span class="pln"> &nbsp;</span><span class="lit">7</span><span class="pun">:</span><span class="pln"> &nbsp; &nbsp; &nbsp;EXACT </span><span class="pun">&lt;</span><span class="pln">c</span><span class="pun">&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">3</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">abc</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">&lt;&gt;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">|</span><span class="pln"> &nbsp;</span><span class="lit">9</span><span class="pun">:</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="kwd">END</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Match</span><span class="pln"> successful</span><span class="pun">!</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Freeing</span><span class="pln"> </span><span class="typ">REx</span><span class="pun">:</span><span class="pln"> </span><span class="str">'a*b+c'</span></code></pre>
<div class="original">
<p>If you have gotten this far into the tutorial, you can probably guess
 what the different parts of the debugging output tell you. The first 
part</p>
</div>
<p>このチュートリアルを読み進めてきたのであれば、デバッグ出力の異なる部分が あなたに情報を伝えているのではないかと思うかも知れません。 最初の部分</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="typ">Compiling</span><span class="pln"> </span><span class="typ">REx</span><span class="pln"> </span><span class="str">'a*b+c'</span><span class="pln"><br>&nbsp; &nbsp; size </span><span class="lit">9</span><span class="pln"> first at </span><span class="lit">1</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">1</span><span class="pun">:</span><span class="pln"> STAR</span><span class="pun">(</span><span class="lit">4</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">2</span><span class="pun">:</span><span class="pln"> &nbsp; EXACT </span><span class="pun">&lt;</span><span class="pln">a</span><span class="pun">&gt;(</span><span class="lit">0</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">4</span><span class="pun">:</span><span class="pln"> PLUS</span><span class="pun">(</span><span class="lit">7</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">5</span><span class="pun">:</span><span class="pln"> &nbsp; EXACT </span><span class="pun">&lt;</span><span class="pln">b</span><span class="pun">&gt;(</span><span class="lit">0</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">7</span><span class="pun">:</span><span class="pln"> EXACT </span><span class="pun">&lt;</span><span class="pln">c</span><span class="pun">&gt;(</span><span class="lit">9</span><span class="pun">)</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">9</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">END</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)</span></code></pre>
<div class="original">
<p>describes the compilation stage. <code>STAR(4)</code> means that there is a starred object, in this case <code>'a'</code>, and if it matches, goto line 4, <i>i.e.</i>, <code>PLUS(7)</code>. The middle lines describe some heuristics and optimizations performed before a match:</p>
</div>
<p>はコンパイルステージのものです。 <code>STAR(4)</code> は star のついたオブジェクト、この場合は <code>'a'</code> があって、 それがマッチングした場合には line 4、つまり <code>PLUS(7)</code> へ 移動することを意味しています。 真中の数行はマッチング前の幾つかの発見的手法(heuristics)と 最適化が行われたことを示しています:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; floating </span><span class="str">'bc'</span><span class="pln"> at </span><span class="lit">0.</span><span class="pun">.</span><span class="lit">2147483647</span><span class="pln"> </span><span class="pun">(</span><span class="pln">checking floating</span><span class="pun">)</span><span class="pln"> minlen </span><span class="lit">2</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Guessing</span><span class="pln"> start of match</span><span class="pun">,</span><span class="pln"> </span><span class="typ">REx</span><span class="pln"> </span><span class="str">'a*b+c'</span><span class="pln"> against </span><span class="str">'abc'</span><span class="pun">...</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Found</span><span class="pln"> floating substr </span><span class="str">'bc'</span><span class="pln"> at offset </span><span class="lit">1.</span><span class="pun">..</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Guessed</span><span class="pun">:</span><span class="pln"> match at offset </span><span class="lit">0</span></code></pre>
<div class="original">
<p>Then the match is executed and the remaining lines describe the process:</p>
</div>
<p>その後でマッチングが実行され、残りの行はそのプロセスを説明しています:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="typ">Matching</span><span class="pln"> </span><span class="typ">REx</span><span class="pln"> </span><span class="str">'a*b+c'</span><span class="pln"> against </span><span class="str">'abc'</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="typ">Setting</span><span class="pln"> an EVAL scope</span><span class="pun">,</span><span class="pln"> savestack</span><span class="pun">=</span><span class="lit">3</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">0</span><span class="pln"> </span><span class="pun">&lt;&gt;</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">abc</span><span class="pun">&gt;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">|</span><span class="pln"> &nbsp;</span><span class="lit">1</span><span class="pun">:</span><span class="pln"> &nbsp;STAR<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EXACT </span><span class="pun">&lt;</span><span class="pln">a</span><span class="pun">&gt;</span><span class="pln"> can match </span><span class="lit">1</span><span class="pln"> times out of </span><span class="lit">32767.</span><span class="pun">..</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="typ">Setting</span><span class="pln"> an EVAL scope</span><span class="pun">,</span><span class="pln"> savestack</span><span class="pun">=</span><span class="lit">3</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">a</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bc</span><span class="pun">&gt;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">|</span><span class="pln"> &nbsp;</span><span class="lit">4</span><span class="pun">:</span><span class="pln"> &nbsp; &nbsp;PLUS<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EXACT </span><span class="pun">&lt;</span><span class="pln">b</span><span class="pun">&gt;</span><span class="pln"> can match </span><span class="lit">1</span><span class="pln"> times out of </span><span class="lit">32767.</span><span class="pun">..</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; </span><span class="typ">Setting</span><span class="pln"> an EVAL scope</span><span class="pun">,</span><span class="pln"> savestack</span><span class="pun">=</span><span class="lit">3</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">2</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">ab</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">c</span><span class="pun">&gt;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">|</span><span class="pln"> &nbsp;</span><span class="lit">7</span><span class="pun">:</span><span class="pln"> &nbsp; &nbsp; &nbsp;EXACT </span><span class="pun">&lt;</span><span class="pln">c</span><span class="pun">&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="lit">3</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">abc</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">&lt;&gt;</span><span class="pln"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">|</span><span class="pln"> &nbsp;</span><span class="lit">9</span><span class="pun">:</span><span class="pln"> &nbsp; &nbsp; &nbsp;</span><span class="kwd">END</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Match</span><span class="pln"> successful</span><span class="pun">!</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">Freeing</span><span class="pln"> </span><span class="typ">REx</span><span class="pun">:</span><span class="pln"> </span><span class="str">'a*b+c'</span></code></pre>
<div class="original">
<p>Each step is of the form <span style="white-space: nowrap;"><code>n &lt;x&gt; &lt;y&gt;</code></span>, with <code>&lt;x&gt;</code> the part of the string matched and <code>&lt;y&gt;</code> the part not yet matched. The <span style="white-space: nowrap;"><code>| 1: STAR</code></span> says that Perl is at line number 1 in the compilation list above. See <a href="https://perldoc.jp/pod/perldebguts#Debugging32Regular32Expressions">"Debugging Regular Expressions" in perldebguts</a> for much more detail.</p>
</div>
<p>各ステップは <span style="white-space: nowrap;"><code>n &lt;x&gt; &lt;y&gt;</code></span> という形式で、<code>&lt;x&gt;</code> は マッチングした文字列の部分で、<code>&lt;y&gt;</code> はまだマッチングしていない部分です。 <span style="white-space: nowrap;"><code>| 1: STAR</code></span> は Perl が先のコンパイルリストの中の行番号 1 の 位置にあることを示しています。 詳細は <a href="https://perldoc.jp/pod/perldebguts#Debugging32regular32expressions">"Debugging regular expressions" in perldebguts</a> を参照してください。</p>
<div class="original">
<p>An alternative method of debugging regexps is to embed <code>print</code> statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</p>
</div>
<p>これとは別の正規表現のデバッグ手法は正規表現の中に <code>print</code> 文を 埋め込むことです。 以下の例は選択肢の中のバックトラッキングを逐一数えるものです:</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="str">"that this"</span><span class="pln"> </span><span class="pun">=~</span><span class="pln"> m@</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Start at position "</span><span class="pun">,</span><span class="pln"> pos</span><span class="pun">,</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"t1\n"</span><span class="pun">;})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;h</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"h1\n"</span><span class="pun">;})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"i1\n"</span><span class="pun">;})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"s1\n"</span><span class="pun">;})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">|</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"t2\n"</span><span class="pun">;})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;h</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"h2\n"</span><span class="pun">;})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"a2\n"</span><span class="pun">;})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"t2\n"</span><span class="pun">;})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">(?{</span><span class="kwd">print</span><span class="pln"> </span><span class="str">"Done at position "</span><span class="pun">,</span><span class="pln"> pos</span><span class="pun">,</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;})</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="lit">@x</span><span class="pun">;</span></code></pre>
<div class="original">
<p>prints</p>
</div>
<p>以下の出力を行います</p>
<pre class="prettyprint lang-perl"><code><span class="pln">&nbsp; &nbsp; </span><span class="typ">Start</span><span class="pln"> at position </span><span class="lit">0</span><span class="pln"><br>&nbsp; &nbsp; t1<br>&nbsp; &nbsp; h1<br>&nbsp; &nbsp; t2<br>&nbsp; &nbsp; h2<br>&nbsp; &nbsp; a2<br>&nbsp; &nbsp; t2<br>&nbsp; &nbsp; </span><span class="typ">Done</span><span class="pln"> at position </span><span class="lit">4</span></code></pre>
<h1 id="SEE32ALSO">SEE ALSO<a href="#SEE32ALSO" class="toc_link">¶</a></h1>
<div class="original">
<p>This is just a tutorial. For the full story on Perl regular expressions, see the <a href="https://perldoc.jp/pod/perlre">perlre</a> regular expressions reference page.</p>
</div>
<p>本ドキュメントはチュートリアルです。 Perl の正規表現に関する完全な説明は正規表現に関する リファレンスページである <a href="https://perldoc.jp/pod/perlre">perlre</a> を参照してください。</p>
<div class="original">
<p>For more information on the matching <code>m//</code> and substitution <code>s///</code> operators, see <a href="https://perldoc.jp/pod/perlop#Regexp32Quote-Like32Operators">"Regexp Quote-Like Operators" in perlop</a>. For information on the <code>split</code> operation, see <a href="https://perldoc.jp/pod/perlfunc#split">"split" in perlfunc</a>.</p>
</div>
<p>マッチング <code>m//</code> や置換 <code>s///</code> に関するより詳細な情報は <a href="https://perldoc.jp/pod/perlop#Regexp32Quote-Like32Operators">"Regexp Quote-Like Operators" in perlop</a> を参照してください。 <code>split</code> 操作に関する情報は <a href="https://perldoc.jp/pod/perlfunc#split">"split" in perlfunc</a> を参照してください。</p>
<div class="original">
<p>For an excellent all-around resource on the care and feeding of regular expressions, see the book <i>Mastering Regular Expressions</i> by Jeffrey Friedl (published by O'Reilly, ISBN 1556592-257-3).</p>
</div>
<p>正規表現に関するすばらしい情報源として Jeffrey Friedl による書籍 <i>Mastering Regular Expressions</i> があります(O'Reillyから出版; ISBN 1556592-257-3)(日本語版は 「詳説 正規表現」ISBN4-87311-130-7 (第二版のもの))。</p>
<h1 id="AUTHOR32AND32COPYRIGHT">AUTHOR AND COPYRIGHT<a href="#AUTHOR32AND32COPYRIGHT" class="toc_link">¶</a></h1>
<p>Copyright (c) 2000 Mark Kvale. All rights reserved. Now maintained by Perl porters.</p>
<p>This document may be distributed under the same terms as Perl itself.</p>
<h2 id="Acknowledgments">Acknowledgments<a href="#Acknowledgments" class="toc_link">¶</a></h2>
<p>The inspiration for the stop codon DNA example came from the ZIP code example in chapter 7 of <i>Mastering Regular Expressions</i>.</p>
<p>The author would like to thank Jeff Pinyan, Andrew Johnson, Peter 
Haworth, Ronald J Kimball, and Joe Smith for all their helpful comments.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="footer span-24 last">
Powered by Amon2, <a href="https://sourceforge.jp/projects/perldocjp/">perldocjp project</a>. Operated by <a href="http://japan.perlassociation.org/">Japan Perl Association</a>
</div>
</div>


<div id="DownloadStatusBarContainer" style="height: auto; width: auto; display: block; --background:#EFEFEF; --backgroundHover:#FFFFFF; --button:transparent; --buttonHover:#CCCCCC; --buttonBorder:#AAAAAA; --border:#888888; --download:#AAAAAA; --progress:#2A911F; --text:#111111; --error:#FF574F;"></div><link rel="stylesheet" type="text/css" href="perlretut%20-%20Perl%20%E3%81%AE%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE%E3%81%AE%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%20-%20perldoc.jp_files/s3downbar.css"><link rel="stylesheet" type="text/css" href="perlretut%20-%20Perl%20%E3%81%AE%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE%E3%81%AE%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%20-%20perldoc.jp_files/contextmenu.css"><link rel="stylesheet" type="text/css" href="perlretut%20-%20Perl%20%E3%81%AE%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE%E3%81%AE%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%20-%20perldoc.jp_files/tooltip.css"><div id="s3downbar-ibmbeeacmbeeaebmfjpmnlgkhoejinha" style="box-sizing: initial !important; position: fixed; white-space: nowrap; width: 140% !important; left: 0px; bottom: 0px; border-top: 1px solid rgb(153, 153, 153); transform-origin: left bottom 0px; z-index: 2147483647; margin: 0px; padding: 2px 0px; background-color: rgb(238, 238, 238); color: rgb(34, 34, 34); display: flex !important; transform: scale(0.714286) !important;"><style type="text/css" media="print">#s3downbar-ibmbeeacmbeeaebmfjpmnlgkhoejinha { display: none !important; }</style><div style="box-sizing: initial !important; position: absolute !important;" id="s3downbar_resize_pane" is_top="false"><div style="box-sizing: initial !important;" class="tooltip_box" is_top="false"></div><div style="box-sizing: initial !important;" class="tooltip_arrow" is_top="false"></div></div><div style="box-sizing: initial !important; color: rgb(34, 34, 34) !important; position: relative !important; order: 4 !important;" class="s3dmBox" id="s3downbar_hide_button" is_hidden="false"><div id="s3downbar_hide_button_img" style="box-sizing: initial !important; background-image: url(&quot;moz-extension://23811b7e-3b61-4d29-be41-d247d903121b/skin/s3dm_icons.png&quot;) !important; display: inline-block !important;"></div><div style="box-sizing: initial !important;" class="tooltip_box" is_top="false"><div style="box-sizing: initial !important;" class="tooltipText">Hide Download Bar</div><div style="box-sizing: initial !important;" class="tooltipText">Ctrl + Shift + Z = Show/Hide Download Bar</div></div><div style="box-sizing: initial !important;" class="tooltip_arrow" is_top="false"></div></div><div style="box-sizing: initial !important; color: rgb(34, 34, 34) !important; position: relative !important;" class="s3dmBox" id="s3downbar_main_menu_button" is_hidden="false"><img style="box-sizing: initial !important;" src="perlretut%20-%20Perl%20%E3%81%AE%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE%E3%81%AE%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB%20-%20perldoc.jp_files/logo16.png"><span style="box-sizing: initial !important;">ダウンロード</span><div style="box-sizing: initial !important;" class="tooltip_box" is_top="false"><div style="box-sizing: initial !important;" class="tooltipText">Download Manager (S3)</div></div><div style="box-sizing: initial !important;" class="tooltip_arrow" is_top="false"></div></div><div style="box-sizing: initial !important; color: rgb(34, 34, 34) !important; position: relative !important; order: 2 !important;" class="s3dmBox" id="s3downbar_clear_button" is_hidden="false">クリア<div style="box-sizing: initial !important;" class="tooltip_box" is_top="false"><div style="box-sizing: initial !important;" class="tooltipText">左クリック: 完了したダウンロードをすべてクリア</div><div style="box-sizing: initial !important;" class="tooltipText">右クリック: 最後のクリアを元に戻す</div></div><div style="box-sizing: initial !important;" class="tooltip_arrow" is_top="false"></div></div><div style="box-sizing: initial !important; color: rgb(34, 34, 34) !important; position: relative !important; order: 1 !important;" class="s3dmBox" id="s3downbar_holder_summary_progress" is_hidden="false"><div style="box-sizing: initial !important;">0%</div><div style="box-sizing: initial !important;" class="tooltip_box" is_top="false"><div style="box-sizing: initial !important;" class="tooltipText">ダウンロード履歴</div></div><div style="box-sizing: initial !important;" class="tooltip_arrow" is_top="false"></div></div><div style="box-sizing: initial !important;" id="s3downbar_download_data_listbox"><div style="box-sizing: initial !important; max-height: 25px !important;" id="s3downbar_download_data_listbox_scroll" list_count="4"><div style="box-sizing: initial !important;" id="s3downbar_download_data_list_empty">Download list is empty</div><div id="s3db_C4CA4238A0B923820DCC509A6F75849B" class="download_data_box db_finishedHbox" style="background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0), rgba(255, 255, 255, 0)) !important;" click_handle="finished_click_handle">
		<div class="download_data_box_iframe_box"><div id="s3downbar_download_box_iframe" is_hidden="true" class="download_data_box_iframe"></div></div>
		<div id="s3downbar_download_box_progressremainder" class="download_data_box_progressremainder" is_hidden="true"></div>
		<div id="s3downbar_download_box_progress" class="download_data_box_progress" style="background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0), rgba(255, 255, 255, 0)) !important; width: 100% !important;" is_hidden="true"></div>
		<div id="s3downbar_download_box_data" class="download_data_box_data">
			<img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" id="s3downbar_download_box_img" class="download_data_box_img" style="background: rgba(0, 0, 0, 0) url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABB0lEQVQ4jWNgQAPtLU2bKstL/uPC1ZVlv6sqShPQ9cFBZXnJ/1+/fuHEMINwGkKMASdPnsBtCCEDVq5YhuIdBoEaxwsCNY7/cWHrycl4XcOATzMME2VAx74F/z9+//JfvsX3/6P3L/5PP7YGxYD1z878Nz7S+N/+eMf/iHPTMQ2Aabz8/A7cIGQDrn54/P/h59f/p93f+9/4SCN2L3TsW/D//////zv2LcDwAkxjysX52A2Qb/H9//H7F5wuMD7S+P/Emzv/H35+jd2A6cfW/H/0/sV/gRrH/4/ev/i/7NwOFAMKry777316Am4XEBMLVz88xhoLlKUDUlMi7Q0glJ2RcXtL0yYA9KCEMWzgpGwAAAAASUVORK5CYII=&quot;) no-repeat scroll 50% 50% / contain !important;" no_image="false" is_hidden="false">
			<img src="" id="s3downbar_download_box_img_queue" class="download_data_box_img" is_hidden="true">
			<img src="" id="s3downbar_download_box_picToShrink" pictoshrink="true" is_hidden="true" class="download_data_box_img">
			<div id="s3downbar_download_box_filename" class="download_data_box_filename">test101.csv</div>
			<div id="s3downbar_download_box_progress_data" class="download_data_box_progress_data" is_hidden="true">
				<div id="s3downbar_download_box_progress_percent" class="download_data_box_progress_percent" is_hidden="true">100%</div>
				<div id="s3downbar_download_box_progress_remaintime" class="download_data_box_progress_remaintime" is_hidden="false">--:--</div>
				<div id="s3downbar_download_box_progress_bytesReceived" class="download_data_box_progress_bytesReceived" is_hidden="true">227 bytes</div>
				<div id="s3downbar_download_box_progress_speed" class="download_data_box_progress_speed" is_hidden="false">-.--</div>
			</div>
		</div>
	<div style="box-sizing: initial !important; position: fixed !important; z-index: 50 !important;"><div style="box-sizing: initial !important;" class="tooltip_box" is_top="false"><div id="download_data_tooltip" class="download_data_tooltip">
		<div class="download_data_tooltip_head">
			<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABv0lEQVRYhe3XP0sCYRwH8F6C76B34OILMOdqL1wanNwEwy68wRA8w6FBbBIlSWpIIepoSKcTFUUSMxoODhXUMEgxCJ7l23QPalrXPZdZ+MCPO57l+fD7c39WVhZxBfwHl5zHDb2xv7e7wwTgPG4QQnSFIQhWQLFYYEOwAgghbAgjAEwIowC6EUYCNCFM/NqOyWuDnjgpXY0ddn6W/HREpwN0Hq7Gd7Kz+ABzaBuDt1cAQLJyQ/c3oi6oayPq+tkMCNk4Pcwc2obJa0OtIwMArh+k+ZSg+dKlWXBeBAEAg7dXrPo35wOwn/I0CyqGE8Mze6Ax7GG9dASL5INF8oF/TLE3oaTcUUStI3/ahPV+C4lmDo1hD7dP97BIPmMBzZful1OQbpdxKItwVGPsAE4M07qrJRCy8ZkA/jEFa17AoSwi3S6zAUZHkRPDtAlHp2IS4KjGEFEyIIQg0cxRQETJ0HvNgOsH6UPa1SxIyt1UQETJwJoXsFU5HiuBoxqDq57UDhjtfudFcOq+/ZSf2gP1fguFZxmEEHq15gWk2+U/9Cj+HYCBr2NdgMnF8kGyBCwB/wPA+nM6KwL+g0tNgHmud/L6xD5HneDTAAAAAElFTkSuQmCC" id="s3downbar_download_tooltip_img" class="download_data_tooltip_img" no_image="false">
			<div id="s3downbar_download_tooltip_filename" class="download_data_tooltip_filename">test101.csv </div>
		</div>
		<div class="download_data_tooltip_data_box" id="s3downbar_download_tooltip_data_box" is_hidden_progress="true" is_hidden_finish="false">
			<table class="download_data_tooltip_data">
				<tbody><tr id="s3downbar_download_tooltip_source_box"><td><div>Source:</div></td><td><input type="text" id="s3downbar_download_tooltip_source" class="download_data_tooltip_url" readonly="true" title="http://www.ken3.org/asp/backno/asp101.html#google_vignette" value="http://www.ken3.org/asp/backno/asp101.html#google_vignette"></td></tr>
				<tr><td><div>転送元:</div></td><td><input type="text" id="s3downbar_download_tooltip_from" class="download_data_tooltip_url" readonly="true" title="http://www.ken3.org/cgi-bin/test/test101.csv" value="http://www.ken3.org/cgi-bin/test/test101.csv"></td></tr>
				<tr><td><div>転送先:</div></td><td><div id="s3downbar_download_tooltip_to">C:\Users\yossy\AppData\Local\Temp\test101.csv</div></td></tr>
				<tr class="download_progress"><td><div>状態:</div></td><td><div id="s3downbar_download_tooltip_status">227 bytes / 227 bytes ( -.-- )</div></td></tr>
				<tr class="download_finish"><td><div>ファイルのサイズ:</div></td><td><div id="s3downbar_download_tooltip_size" filenotfound="false">227 bytes</div></td></tr>
				<tr class="download_finish" id="s3downbar_download_virus_scan_box" is_hidden="true"><td><div id="s3downbar_download_virus_scan_label">Virus scan:</div></td><td><a id="s3downbar_download_virus_scan" target="_blank"></a></td></tr>
				<tr><td><div>開始時刻:</div></td><td><div id="s3downbar_download_tooltip_timeStart">2020.12.13 - 13:53:59</div></td></tr>
				<tr class="download_finish"><td><div>所要時間:</div></td><td><div id="s3downbar_download_tooltip_timeEnd">&lt;00:01</div></td></tr>
				<tr class="download_progress"><td><div>残り時間:</div></td><td><div id="s3downbar_download_tooltip_timeLeft">--:--</div></td></tr>
				<tr class="download_progress"><td><div>進行率:</div></td><td><div id="s3downbar_download_tooltip_percent">100%</div></td></tr>
				<tr class="download_finish"><td><div>平均転送速度:</div></td><td><div id="s3downbar_download_tooltip_speed">2 KB/秒</div></td></tr>
			</tbody></table>
			<div class="download_data_tooltip_img_preview_box download_finish"><div class="download_data_tooltip_img_box">
				<img src="" id="s3downbar_download_tooltip_img_preview" is_hidden="true" class="download_data_tooltip_img_preview download_finish" width="120" height="120">
				<div id="s3downbar_download_tooltip_img_size" class="download_data_tooltip_img_size"></div>
			</div></div>
		</div>
		<div class="download_data_tooltip_hint" id="s3downbar_download_tooltip_hint_progress" is_hidden="true">
			<div>mouse double click: download pause/resume</div>
			<div>mouse middle click: download cancel</div>
		</div>
		<div class="download_data_tooltip_hint" id="s3downbar_download_tooltip_hint_finish" is_hidden="false">
			<div>mouse double click: open file</div>
			<div>mouse double click + Ctrl: open dir</div>
			<div style="padding-top: 4px !important;">mouse middle click: delete from list</div>
			<div>mouse middle click + Ctrl: delete from system</div>
			<div style="padding-top: 4px !important;">press mouse button + Ctrl: drag &amp; drop</div>
		</div>
	</div></div><div style="box-sizing: initial !important;" class="tooltip_arrow" is_top="false"></div></div></div><div id="s3db_C81E728D9D4C2F636F067F89CC14862C" class="download_data_box db_finishedHbox" style="background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0), rgba(255, 255, 255, 0)) !important;" click_handle="finished_click_handle">
		<div class="download_data_box_iframe_box"><div id="s3downbar_download_box_iframe" is_hidden="true" class="download_data_box_iframe"></div></div>
		<div id="s3downbar_download_box_progressremainder" class="download_data_box_progressremainder" is_hidden="true"></div>
		<div id="s3downbar_download_box_progress" class="download_data_box_progress" style="background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0), rgba(255, 255, 255, 0)) !important; width: 100% !important;" is_hidden="true"></div>
		<div id="s3downbar_download_box_data" class="download_data_box_data">
			<img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" id="s3downbar_download_box_img" class="download_data_box_img" style="background: rgba(0, 0, 0, 0) url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABB0lEQVQ4jWNgQAPtLU2bKstL/uPC1ZVlv6sqShPQ9cFBZXnJ/1+/fuHEMINwGkKMASdPnsBtCCEDVq5YhuIdBoEaxwsCNY7/cWHrycl4XcOATzMME2VAx74F/z9+//JfvsX3/6P3L/5PP7YGxYD1z878Nz7S+N/+eMf/iHPTMQ2Aabz8/A7cIGQDrn54/P/h59f/p93f+9/4SCN2L3TsW/D//////zv2LcDwAkxjysX52A2Qb/H9//H7F5wuMD7S+P/Emzv/H35+jd2A6cfW/H/0/sV/gRrH/4/ev/i/7NwOFAMKry777316Am4XEBMLVz88xhoLlKUDUlMi7Q0glJ2RcXtL0yYA9KCEMWzgpGwAAAAASUVORK5CYII=&quot;) no-repeat scroll 50% 50% / contain !important;" no_image="false" is_hidden="false">
			<img src="" id="s3downbar_download_box_img_queue" class="download_data_box_img" is_hidden="true">
			<img src="" id="s3downbar_download_box_picToShrink" pictoshrink="true" is_hidden="true" class="download_data_box_img">
			<div id="s3downbar_download_box_filename" class="download_data_box_filename">test101.csv</div>
			<div id="s3downbar_download_box_progress_data" class="download_data_box_progress_data" is_hidden="true">
				<div id="s3downbar_download_box_progress_percent" class="download_data_box_progress_percent" is_hidden="true">100%</div>
				<div id="s3downbar_download_box_progress_remaintime" class="download_data_box_progress_remaintime" is_hidden="false">--:--</div>
				<div id="s3downbar_download_box_progress_bytesReceived" class="download_data_box_progress_bytesReceived" is_hidden="true">227 bytes</div>
				<div id="s3downbar_download_box_progress_speed" class="download_data_box_progress_speed" is_hidden="false">-.--</div>
			</div>
		</div>
	<div style="box-sizing: initial !important; position: fixed !important; z-index: 50 !important;"><div style="box-sizing: initial !important;" class="tooltip_box" is_top="false"><div id="download_data_tooltip" class="download_data_tooltip">
		<div class="download_data_tooltip_head">
			<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABv0lEQVRYhe3XP0sCYRwH8F6C76B34OILMOdqL1wanNwEwy68wRA8w6FBbBIlSWpIIepoSKcTFUUSMxoODhXUMEgxCJ7l23QPalrXPZdZ+MCPO57l+fD7c39WVhZxBfwHl5zHDb2xv7e7wwTgPG4QQnSFIQhWQLFYYEOwAgghbAgjAEwIowC6EUYCNCFM/NqOyWuDnjgpXY0ddn6W/HREpwN0Hq7Gd7Kz+ABzaBuDt1cAQLJyQ/c3oi6oayPq+tkMCNk4Pcwc2obJa0OtIwMArh+k+ZSg+dKlWXBeBAEAg7dXrPo35wOwn/I0CyqGE8Mze6Ax7GG9dASL5INF8oF/TLE3oaTcUUStI3/ahPV+C4lmDo1hD7dP97BIPmMBzZful1OQbpdxKItwVGPsAE4M07qrJRCy8ZkA/jEFa17AoSwi3S6zAUZHkRPDtAlHp2IS4KjGEFEyIIQg0cxRQETJ0HvNgOsH6UPa1SxIyt1UQETJwJoXsFU5HiuBoxqDq57UDhjtfudFcOq+/ZSf2gP1fguFZxmEEHq15gWk2+U/9Cj+HYCBr2NdgMnF8kGyBCwB/wPA+nM6KwL+g0tNgHmud/L6xD5HneDTAAAAAElFTkSuQmCC" id="s3downbar_download_tooltip_img" class="download_data_tooltip_img" no_image="false">
			<div id="s3downbar_download_tooltip_filename" class="download_data_tooltip_filename">test101.csv </div>
		</div>
		<div class="download_data_tooltip_data_box" id="s3downbar_download_tooltip_data_box" is_hidden_progress="true" is_hidden_finish="false">
			<table class="download_data_tooltip_data">
				<tbody><tr id="s3downbar_download_tooltip_source_box"><td><div>Source:</div></td><td><input type="text" id="s3downbar_download_tooltip_source" class="download_data_tooltip_url" readonly="true" title="http://www.ken3.org/asp/backno/asp101.html" value="http://www.ken3.org/asp/backno/asp101.html"></td></tr>
				<tr><td><div>転送元:</div></td><td><input type="text" id="s3downbar_download_tooltip_from" class="download_data_tooltip_url" readonly="true" title="http://www.ken3.org/cgi-bin/test/test101.csv" value="http://www.ken3.org/cgi-bin/test/test101.csv"></td></tr>
				<tr><td><div>転送先:</div></td><td><div id="s3downbar_download_tooltip_to">C:\Users\yossy\Downloads\test101.csv</div></td></tr>
				<tr class="download_progress"><td><div>状態:</div></td><td><div id="s3downbar_download_tooltip_status">227 bytes / 227 bytes ( -.-- )</div></td></tr>
				<tr class="download_finish"><td><div>ファイルのサイズ:</div></td><td><div id="s3downbar_download_tooltip_size" filenotfound="false">227 bytes</div></td></tr>
				<tr class="download_finish" id="s3downbar_download_virus_scan_box" is_hidden="true"><td><div id="s3downbar_download_virus_scan_label">Virus scan:</div></td><td><a id="s3downbar_download_virus_scan" target="_blank"></a></td></tr>
				<tr><td><div>開始時刻:</div></td><td><div id="s3downbar_download_tooltip_timeStart">2020.12.13 - 13:54:19</div></td></tr>
				<tr class="download_finish"><td><div>所要時間:</div></td><td><div id="s3downbar_download_tooltip_timeEnd">&lt;00:01</div></td></tr>
				<tr class="download_progress"><td><div>残り時間:</div></td><td><div id="s3downbar_download_tooltip_timeLeft">--:--</div></td></tr>
				<tr class="download_progress"><td><div>進行率:</div></td><td><div id="s3downbar_download_tooltip_percent">100%</div></td></tr>
				<tr class="download_finish"><td><div>平均転送速度:</div></td><td><div id="s3downbar_download_tooltip_speed">3 KB/秒</div></td></tr>
			</tbody></table>
			<div class="download_data_tooltip_img_preview_box download_finish"><div class="download_data_tooltip_img_box">
				<img src="" id="s3downbar_download_tooltip_img_preview" is_hidden="true" class="download_data_tooltip_img_preview download_finish" width="120" height="120">
				<div id="s3downbar_download_tooltip_img_size" class="download_data_tooltip_img_size"></div>
			</div></div>
		</div>
		<div class="download_data_tooltip_hint" id="s3downbar_download_tooltip_hint_progress" is_hidden="true">
			<div>mouse double click: download pause/resume</div>
			<div>mouse middle click: download cancel</div>
		</div>
		<div class="download_data_tooltip_hint" id="s3downbar_download_tooltip_hint_finish" is_hidden="false">
			<div>mouse double click: open file</div>
			<div>mouse double click + Ctrl: open dir</div>
			<div style="padding-top: 4px !important;">mouse middle click: delete from list</div>
			<div>mouse middle click + Ctrl: delete from system</div>
			<div style="padding-top: 4px !important;">press mouse button + Ctrl: drag &amp; drop</div>
		</div>
	</div></div><div style="box-sizing: initial !important;" class="tooltip_arrow" is_top="false"></div></div></div><div id="s3db_ECCBC87E4B5CE2FE28308FD9F2A7BAF3" class="download_data_box db_finishedHbox" style="background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0), rgba(255, 255, 255, 0)) !important;" click_handle="finished_click_handle">
		<div class="download_data_box_iframe_box"><div id="s3downbar_download_box_iframe" is_hidden="true" class="download_data_box_iframe"></div></div>
		<div id="s3downbar_download_box_progressremainder" class="download_data_box_progressremainder" is_hidden="true"></div>
		<div id="s3downbar_download_box_progress" class="download_data_box_progress" style="background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0), rgba(255, 255, 255, 0)) !important; width: 100% !important; background-color: rgb(112, 143, 181) !important; border-right: 1px solid rgb(255, 0, 0) !important;" is_hidden="true"></div>
		<div id="s3downbar_download_box_data" class="download_data_box_data">
			<img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" id="s3downbar_download_box_img" class="download_data_box_img" style="background: rgba(0, 0, 0, 0) url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACBElEQVQ4jY3RQUiTcRjH8T/4+ILQIWmSjd75OoZups18dWy5933nlmuoyVBsKRMGkgctyYMQhVFQBAkGHguSDhV0LrxFBw9FpwJZeTCKCCzIDtnJ+e0QEbF30gPf4/O5/JT6e4f37ws4lVKq+phSqkbtcWZP+1US4fmyIsEpxu3HRaWqzcqISMxpn6fFGC7LqHe4NvSZMefhW6WqO90RkbgdvkyoYagso97h1unt34j14J1SqsEdaLtIyJctyzhooddF0euitBo5lEivG2DFW+cI6oP/9PJpho03GQLeNAFvmkhwChHpcQW6Q7PY/gyPCh3MDTjEghl2PyRha4C1lSTxcD/doVmUiOUG2LHmGdaz3XDDy4+lECsD93k1c4+dYhI+pvi62keseQYlYrsBTrRpmtJYJ6XrTezePcL35UGepDfZXs3Ca4vd9TTRpmmUiOPyL4lIYJJSbxIKR3men+XK8CaLZ3ZYv30enkXYeeEQCUwiIglXoKtxgk/+Apy02MqdYGFkkTsTS/xcaIPlNrYWEnQ1TlQEekyjwIXaUb4F8mCnoC8OwxEYNfkyEuPm8QSmUXBfQUSSpm8cv8fmXG2Ooucs7/URNnynWPMOcelQP36PjekbR0SSrkCHnqfxgLVnHXq+IpBq10f5n0QkVT6jprVUaVq2SqvJ7Z2WVZrW8uftF7z9KaH0ajk5AAAAAElFTkSuQmCC&quot;) no-repeat scroll 50% 50% / contain !important;" no_image="false" is_hidden="false">
			<img src="" id="s3downbar_download_box_img_queue" class="download_data_box_img" is_hidden="true">
			<img src="" id="s3downbar_download_box_picToShrink" pictoshrink="true" is_hidden="true" class="download_data_box_img">
			<div id="s3downbar_download_box_filename" class="download_data_box_filename">perldebtut - Perl でのデバッグのチュートリアル - perldoc.jp.html</div>
			<div id="s3downbar_download_box_progress_data" class="download_data_box_progress_data" is_hidden="true">
				<div id="s3downbar_download_box_progress_percent" class="download_data_box_progress_percent" is_hidden="true">100%</div>
				<div id="s3downbar_download_box_progress_remaintime" class="download_data_box_progress_remaintime" is_hidden="false">00:01</div>
				<div id="s3downbar_download_box_progress_bytesReceived" class="download_data_box_progress_bytesReceived" is_hidden="true">6 KB</div>
				<div id="s3downbar_download_box_progress_speed" class="download_data_box_progress_speed" is_hidden="false">10 KB/秒</div>
			</div>
		</div>
	<div style="box-sizing: initial !important; position: fixed !important; z-index: 50 !important;"><div style="box-sizing: initial !important;" class="tooltip_box" is_top="false"><div id="download_data_tooltip" class="download_data_tooltip">
		<div class="download_data_tooltip_head">
			<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAGYElEQVRYhe2Wa2xT5xmAU37sosUm+NhOfE5i+xzn4ksaAiHBiY/t+BI7TsjFuZGUS7gkIeGaZmysiEWjlJRsQAgIreoqdVInVLFOm4TWy4bWqlM3aVqh68q2jsvabYxL0Rhkg7IYP/thJ0C1SXGZ9muf9Oh9v/f9Pr3POefPycr6//o3SyvkL9UK0urMMa3SLBA9Go2of0gBaXWVZT2Z4HcMUb9k+G53bPulXFNx/+eFfOlTC2gEqbfK0oesU5F1HhQhFWWdiiyoyDoVZXbvudfTq5S5goz3vXpbKnAM5eTkWT/N/Ec0grSmytqHIqhYBU8KnSc1TPAgp+szuXxfb4Egc6gHxteevGM2L9o6PzdXyVRgnkaQ1ritgyiCNzVAULHqU084s/9PzAhM9CQZX/36dJFt6fb5xgJbZgI6ca1bGcSm9yELXmR9mnSu6O/VlE/UZwQOPZbgwPI77H3s9USp3b8zkzcxT6MT19UoG1EMfhS9D0U/E9MYfMh6H7LB90Bd1vtYIMgP4Cj2sTw88g+tXmrMSEAt3ILNEEhJGPwohtoHc70/hcHPiRei3LnWRKnZj2zwIRu8s9Fm8BFZvBWNTlyXicB6tWgbNmMQm7E2haEWxRjAZgzct6/l8K5a+NsyuNnMn09H7p03BlCMAQoNATy2TWh04vpMBPrUkmEKjSFsuUFsxiArl1TjK/amBYKz9en3/fBRDK4vg2sN/PRYLTZjkEJjMB1DqEXDaHRi39wF9KZ+b8kIhblhCo0hNi9USR7No7+mmlNfqeLJLjeFuSEGYh74TQ18GIDLUbhaDxfDvLTfx1c31FOYG6IoN4y3ZASN3tSficCAt+RLFOXVUSHV8c+RYviGkdtjVjhSxnMrVA7Xfpkfdx/it6N7uPydNXChFj4Mwp9CJH9fy8e/XkaTN0JRbgR/yXY0etPAnAWy9dIGv2MHxaYoL6sR2G6D3flwUA/PCyResPFmxw94zfMXTnou8Ub8FGcPjMJ71fC+D86FSV6o54NXAxTnRfE7dpCtlzZkIjDodz1BsRjjepMfNjpI7HCRnLDDEQc8b4aXzPz12TZO1F3lleAlbpzsIXk2AG+r8E4IzsZIvOOn2FSP3/UE2XppcO4CgjQUKN1FidhAMl4NvQtJDJeRfE6BH9pIvlzG1IuNnDm4l2+33OZYbIoXQx+QfLcaTtfAGyF4N8rdM1FKxAYCpbvIFqShDATEjYHSUUqkRu7WBaCjEnoXwiY7NybcPBn+BaPtV3hq5W0Odic4Gr/FN4MX+fgVN/x8MXy3Dk55SbxVT4nYSKBslGxB3JiJwKZg+W7sUhM3y7sgpkJ7FaxaxLmBOIM1P2FD/D02rvoj21deYXfrFca955j+vh1OlMFxP7xVxfTxRuzSMoLlu8kWxE1zFtAK4uZw+R7s+c2cyRsCXxCiXmh1M716Kfvi++kOvUZP/Gesi59muO40P1q7E56xw7fK4fhiEt/zcGO8EXt+M8HyPWgFcXMmAlvCi8ZwFLQwZhhgqngFeMIQ8kOjh0RXDW/GB5hsfJojrU/xds8KEkPlsHMhjJfD0SX8/Wsxji2P4ShoIVy+F60gbslEYGu4YgxnQSv2ghZ+N3+EKUcPLI2ALwRhPzSo0FKd+jTLl0BPBaytgK2VTA0GuLaqCZe5FYe5lciiMbSCuHXuAjrTtkjFPpzmNuzmViJSN3/QbOOqpZfE4qaUiBqC2kBKJuqFBpVkTOWaO8JHNZ202FtwWOI4zXEiFfvQ6kzbMhOo3I/T3I7DEsdhiRMo6OaMdpjzul4umldwvaSbW4+2cWthKzcfbeZyUTMXTJ1cEFfRoLTNDnea24hWfD1jgeFo5QGclg6c1naclnacljaclnZ25fXzy5xtnJ+/gXM5azib08v5nH5+pRtit9g7e9ZhSd1zyR1EKw+g1ZmGMxCQHo9WTeCSO3Fa0xL3R0s7LmtHuvYJLGnSuUvuJFo5gVYnPZ6ZgHuSUqUTl9xFqdKFS+nEJXdSKnfhUrrSeYrZXEn1Z5i5G6uazExAo5NGYu7DxNyTxKomiVWlc/ckUfdhZnrR2d7h1LmZujuVR9337ml00sicBbJ1UqdGL33xv4lWZ4rOVSBLo5EEzQJR1RryGx6WLwhiOP1bPm/OAllZWY9kZbk+k2W1fu6hKSz8bKbD/6frXxrUMwwLLuzqAAAAAElFTkSuQmCC" id="s3downbar_download_tooltip_img" class="download_data_tooltip_img" no_image="false">
			<div id="s3downbar_download_tooltip_filename" class="download_data_tooltip_filename">perldebtut - Perl でのデバッグのチュートリアル - perldoc.jp.html </div>
		</div>
		<div class="download_data_tooltip_data_box" id="s3downbar_download_tooltip_data_box" is_hidden_progress="true" is_hidden_finish="false">
			<table class="download_data_tooltip_data">
				<tbody><tr id="s3downbar_download_tooltip_source_box" is_hidden="true"><td><div>Source:</div></td><td><input type="text" id="s3downbar_download_tooltip_source" class="download_data_tooltip_url" readonly="true"></td></tr>
				<tr><td><div>転送元:</div></td><td><input type="text" id="s3downbar_download_tooltip_from" class="download_data_tooltip_url" readonly="true" title="https://perldoc.jp/docs/perl/5.26.1/perldebtut.pod" value="https://perldoc.jp/docs/perl/5.26.1/perldebtut.pod"></td></tr>
				<tr><td><div>転送先:</div></td><td><div id="s3downbar_download_tooltip_to">Z:\Documsnts\asciidoc\asciidoc\perl\perldebtut - Perl でのデバッグのチュートリアル - perldoc.jp.html</div></td></tr>
				<tr class="download_progress"><td><div>状態:</div></td><td><div id="s3downbar_download_tooltip_status">6 KB / 17 KB ( 10 KB/秒 )</div></td></tr>
				<tr class="download_finish"><td><div>ファイルのサイズ:</div></td><td><div id="s3downbar_download_tooltip_size" filenotfound="false">141 KB</div></td></tr>
				<tr class="download_finish" id="s3downbar_download_virus_scan_box" is_hidden="true"><td><div id="s3downbar_download_virus_scan_label">Virus scan:</div></td><td><a id="s3downbar_download_virus_scan" target="_blank"></a></td></tr>
				<tr><td><div>開始時刻:</div></td><td><div id="s3downbar_download_tooltip_timeStart">2020.12.15 - 06:30:17</div></td></tr>
				<tr class="download_finish"><td><div>所要時間:</div></td><td><div id="s3downbar_download_tooltip_timeEnd">00:01</div></td></tr>
				<tr class="download_progress"><td><div>残り時間:</div></td><td><div id="s3downbar_download_tooltip_timeLeft">00:01</div></td></tr>
				<tr class="download_progress"><td><div>進行率:</div></td><td><div id="s3downbar_download_tooltip_percent">100%</div></td></tr>
				<tr class="download_finish"><td><div>平均転送速度:</div></td><td><div id="s3downbar_download_tooltip_speed">211 KB/秒</div></td></tr>
			</tbody></table>
			<div class="download_data_tooltip_img_preview_box download_finish"><div class="download_data_tooltip_img_box">
				<img src="" id="s3downbar_download_tooltip_img_preview" is_hidden="true" class="download_data_tooltip_img_preview download_finish" width="120" height="120">
				<div id="s3downbar_download_tooltip_img_size" class="download_data_tooltip_img_size"></div>
			</div></div>
		</div>
		<div class="download_data_tooltip_hint" id="s3downbar_download_tooltip_hint_progress" is_hidden="true">
			<div>mouse double click: download pause/resume</div>
			<div>mouse middle click: download cancel</div>
		</div>
		<div class="download_data_tooltip_hint" id="s3downbar_download_tooltip_hint_finish" is_hidden="false">
			<div>mouse double click: open file</div>
			<div>mouse double click + Ctrl: open dir</div>
			<div style="padding-top: 4px !important;">mouse middle click: delete from list</div>
			<div>mouse middle click + Ctrl: delete from system</div>
			<div style="padding-top: 4px !important;">press mouse button + Ctrl: drag &amp; drop</div>
		</div>
	</div></div><div style="box-sizing: initial !important;" class="tooltip_arrow" is_top="false"></div></div></div><div id="s3db_A87FF679A2F3E71D9181A67B7542122C" class="download_data_box db_progressStack" style="background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0), rgba(255, 255, 255, 0)) !important;" click_handle="progress_click_handle">
		<div class="download_data_box_iframe_box"><div id="s3downbar_download_box_iframe" is_hidden="true" class="download_data_box_iframe"></div></div>
		<div id="s3downbar_download_box_progressremainder" class="download_data_box_progressremainder" is_hidden="false"></div>
		<div id="s3downbar_download_box_progress" class="download_data_box_progress" style="background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0), rgba(255, 255, 255, 0)) !important;" is_hidden="false"></div>
		<div id="s3downbar_download_box_data" class="download_data_box_data">
			<img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" id="s3downbar_download_box_img" class="download_data_box_img" style="background: rgba(0, 0, 0, 0) url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACBElEQVQ4jY3RQUiTcRjH8T/4+ILQIWmSjd75OoZups18dWy5933nlmuoyVBsKRMGkgctyYMQhVFQBAkGHguSDhV0LrxFBw9FpwJZeTCKCCzIDtnJ+e0QEbF30gPf4/O5/JT6e4f37ws4lVKq+phSqkbtcWZP+1US4fmyIsEpxu3HRaWqzcqISMxpn6fFGC7LqHe4NvSZMefhW6WqO90RkbgdvkyoYagso97h1unt34j14J1SqsEdaLtIyJctyzhooddF0euitBo5lEivG2DFW+cI6oP/9PJpho03GQLeNAFvmkhwChHpcQW6Q7PY/gyPCh3MDTjEghl2PyRha4C1lSTxcD/doVmUiOUG2LHmGdaz3XDDy4+lECsD93k1c4+dYhI+pvi62keseQYlYrsBTrRpmtJYJ6XrTezePcL35UGepDfZXs3Ca4vd9TTRpmmUiOPyL4lIYJJSbxIKR3men+XK8CaLZ3ZYv30enkXYeeEQCUwiIglXoKtxgk/+Apy02MqdYGFkkTsTS/xcaIPlNrYWEnQ1TlQEekyjwIXaUb4F8mCnoC8OwxEYNfkyEuPm8QSmUXBfQUSSpm8cv8fmXG2Ooucs7/URNnynWPMOcelQP36PjekbR0SSrkCHnqfxgLVnHXq+IpBq10f5n0QkVT6jprVUaVq2SqvJ7Z2WVZrW8uftF7z9KaH0ajk5AAAAAElFTkSuQmCC&quot;) no-repeat scroll 50% 50% / contain !important;" no_image="false" is_hidden="true">
			<img src="" id="s3downbar_download_box_img_queue" class="download_data_box_img" is_hidden="true">
			<img src="" id="s3downbar_download_box_picToShrink" pictoshrink="true" is_hidden="true" class="download_data_box_img">
			<div id="s3downbar_download_box_filename" class="download_data_box_filename">perlretut - Perl の正規表現のチュートリアル - perldoc.jp.html</div>
			<div id="s3downbar_download_box_progress_data" class="download_data_box_progress_data" is_hidden="false">
				<div id="s3downbar_download_box_progress_percent" class="download_data_box_progress_percent" is_hidden="true">不明</div>
				<div id="s3downbar_download_box_progress_remaintime" class="download_data_box_progress_remaintime" is_hidden="false">不明</div>
				<div id="s3downbar_download_box_progress_bytesReceived" class="download_data_box_progress_bytesReceived" is_hidden="true">-.--</div>
				<div id="s3downbar_download_box_progress_speed" class="download_data_box_progress_speed" is_hidden="false">-.--</div>
			</div>
		</div>
	<div style="box-sizing: initial !important; position: fixed !important; z-index: 50 !important;"><div style="box-sizing: initial !important;" class="tooltip_box" is_top="false"><div id="download_data_tooltip" class="download_data_tooltip">
		<div class="download_data_tooltip_head">
			<img src="" id="s3downbar_download_tooltip_img" class="download_data_tooltip_img" no_image="true">
			<div id="s3downbar_download_tooltip_filename" class="download_data_tooltip_filename">perlretut - Perl の正規表現のチュートリアル - perldoc.jp.html </div>
		</div>
		<div class="download_data_tooltip_data_box" id="s3downbar_download_tooltip_data_box" is_hidden_progress="false" is_hidden_finish="true">
			<table class="download_data_tooltip_data">
				<tbody><tr id="s3downbar_download_tooltip_source_box" is_hidden="true"><td><div>Source:</div></td><td><input type="text" id="s3downbar_download_tooltip_source" class="download_data_tooltip_url" readonly="true"></td></tr>
				<tr><td><div>転送元:</div></td><td><input type="text" id="s3downbar_download_tooltip_from" class="download_data_tooltip_url" readonly="true" title="https://perldoc.jp/docs/perl/5.26.1/perlretut.pod" value="https://perldoc.jp/docs/perl/5.26.1/perlretut.pod"></td></tr>
				<tr><td><div>転送先:</div></td><td><div id="s3downbar_download_tooltip_to">Z:\Documsnts\asciidoc\asciidoc\perl\perlretut - Perl の正規表現のチュートリアル - perldoc.jp.html</div></td></tr>
				<tr class="download_progress"><td><div>状態:</div></td><td><div id="s3downbar_download_tooltip_status">-.-- / 不明 ( -.-- )</div></td></tr>
				<tr class="download_finish"><td><div>ファイルのサイズ:</div></td><td><div id="s3downbar_download_tooltip_size" filenotfound="true">ファイルが見つかりません</div></td></tr>
				<tr class="download_finish" id="s3downbar_download_virus_scan_box" is_hidden="true"><td><div id="s3downbar_download_virus_scan_label">Virus scan:</div></td><td><a id="s3downbar_download_virus_scan" target="_blank"></a></td></tr>
				<tr><td><div>開始時刻:</div></td><td><div id="s3downbar_download_tooltip_timeStart">2020.12.15 - 06:30:40</div></td></tr>
				<tr class="download_finish"><td><div>所要時間:</div></td><td><div id="s3downbar_download_tooltip_timeEnd">不明</div></td></tr>
				<tr class="download_progress"><td><div>残り時間:</div></td><td><div id="s3downbar_download_tooltip_timeLeft">不明</div></td></tr>
				<tr class="download_progress"><td><div>進行率:</div></td><td><div id="s3downbar_download_tooltip_percent">不明</div></td></tr>
				<tr class="download_finish"><td><div>平均転送速度:</div></td><td><div id="s3downbar_download_tooltip_speed">不明</div></td></tr>
			</tbody></table>
			<div class="download_data_tooltip_img_preview_box download_finish"><div class="download_data_tooltip_img_box">
				<img src="" id="s3downbar_download_tooltip_img_preview" is_hidden="true" class="download_data_tooltip_img_preview download_finish" width="120" height="120">
				<div id="s3downbar_download_tooltip_img_size" class="download_data_tooltip_img_size"></div>
			</div></div>
		</div>
		<div class="download_data_tooltip_hint" id="s3downbar_download_tooltip_hint_progress" is_hidden="false">
			<div>mouse double click: download pause/resume</div>
			<div>mouse middle click: download cancel</div>
		</div>
		<div class="download_data_tooltip_hint" id="s3downbar_download_tooltip_hint_finish" is_hidden="true">
			<div>mouse double click: open file</div>
			<div>mouse double click + Ctrl: open dir</div>
			<div style="padding-top: 4px !important;">mouse middle click: delete from list</div>
			<div>mouse middle click + Ctrl: delete from system</div>
			<div style="padding-top: 4px !important;">press mouse button + Ctrl: drag &amp; drop</div>
		</div>
	</div></div><div style="box-sizing: initial !important;" class="tooltip_arrow" is_top="false"></div></div></div></div></div></div></body></html>